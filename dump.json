[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/backoff/backoff.js",
    "memberof": null,
    "longname": "src/backoff/backoff.js",
    "access": null,
    "description": null,
    "lineNumber": 0,
    "content": ""
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/backoff/exponential.js",
    "memberof": null,
    "longname": "src/backoff/exponential.js",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "content": "/**\n * @class\n * @implements {BackoffStrategy}\n */\nexport class ExponentialBackoff {\n    /**\n     * Creates a new exponential backoff strategy.\n     * @see https://en.wikipedia.org/wiki/Exponential_backoff\n     * @param {ExponentialOptions} options\n     */\n    constructor(options) {\n        this.options = options;\n        this.counter = 0;\n    }\n    /**\n     * @inheritDoc\n     */\n    getDelay() {\n        const count = this.counter - Math.round(Math.random() * this.options.random);\n        return Math.min(this.options.max, this.options.initial * Math.pow(2, Math.max(count, 0)));\n    }\n    /**\n     * @inheritDoc\n     */\n    next() {\n        const next = new ExponentialBackoff(this.options);\n        next.counter = this.counter + 1;\n        return next;\n    }\n    /**\n     * @inheritDoc\n     */\n    reset() {\n        return new ExponentialBackoff(this.options);\n    }\n}\n"
  },
  {
    "__docId__": 2,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ExponentialBackoff",
    "memberof": "src/backoff/exponential.js",
    "longname": "src/backoff/exponential.js~ExponentialBackoff",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{ExponentialBackoff}",
    "description": "",
    "lineNumber": 5,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "implements": [
      "BackoffStrategy"
    ]
  },
  {
    "__docId__": 3,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#constructor",
    "access": null,
    "description": "Creates a new exponential backoff strategy.",
    "see": [
      "https://en.wikipedia.org/wiki/Exponential_backoff"
    ],
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "ExponentialOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 4,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#options",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "counter",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#counter",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDelay",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#getDelay",
    "access": null,
    "description": "",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 7,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "next",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#next",
    "access": null,
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 8,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "reset",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#reset",
    "access": null,
    "description": "",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 9,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/builder.js",
    "memberof": null,
    "longname": "src/builder.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { escape, formatDate } from \"./grammar\";\n/**\n * Expression is used to build filtering expressions, like those used in WHERE\n * clauses. It can be used for fluent and safe building of queries using\n * untrusted input.\n *\n * @example\n * e => e\n *   .field('host').equals.value('ares.peet.io')\n *   .or\n *   .field('host').matches(/example\\.com$/)\n *   .or\n *   .expr(e => e\n *     .field('country').equals.value('US')\n *     .and\n *     .field('state').equals.value('WA'));\n *\n * // Generates:\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\n */\nexport class Expression {\n    constructor() {\n        this.query = new Array();\n    }\n    /**\n     * Inserts a tag reference into the expression; the name will be\n     * automatically escaped.\n     * @param  {String} name\n     * @return {Expression}\n     */\n    tag(name) {\n        this.field(name);\n        return this;\n    }\n    /**\n     * Inserts a field reference into the expression; the name will be\n     * automatically escaped.\n     * @param  {String} name\n     * @return {Expression}\n     */\n    field(name) {\n        this.query.push(escape.quoted(name));\n        return this;\n    }\n    /**\n     * Inserts a subexpression; invokes the function with a new expression\n     * that can be chained on.\n     * @param  {function(e: Expression): Expression}  fn\n     * @return {Expression}\n     * @example\n     * e.field('a').equals.value('b')\n     *   .or.expr(e =>\n     *     e.field('b').equals.value('b')\n     *     .and.field('a').equals.value('c'))\n     *   .toString()\n     * // \"a\" = 'b' OR (\"b\" = 'b' AND 'a' = \"c\")\n     */\n    exp(fn) {\n        this.query.push(\"(\" + fn(new Expression()).toString() + \")\");\n        return this;\n    }\n    /**\n     * Value chains on a value to the expression.\n     *\n     *  - Numbers will be inserted verbatim\n     *  - Strings will be escaped and inserted\n     *  - Booleans will be inserted correctly\n     *  - Dates will be formatted and inserted correctly, including NanoDates.\n     *  - Regular expressions will be inserted correctly, however an error will\n     *    be thrown if they contain flags, as regex flags do not work in Influx\n     *  - Otherwise we'll try to call `.toString()` on the value, throwing\n     *    if we cannot do so.\n     *\n     * @param  {*}  value\n     * @return {Expression}\n     */\n    value(value) {\n        switch (typeof value) {\n            case \"number\":\n                this.query.push(value);\n                return this;\n            case \"string\":\n                this.query.push(escape.stringLit(value));\n                return this;\n            case \"boolean\":\n                this.query.push(value ? \"TRUE\" : \"FALSE\");\n                return this;\n            default:\n                if (value instanceof Date) {\n                    this.query.push(formatDate(value));\n                    return this;\n                }\n                if (value instanceof RegExp) {\n                    if (value.flags) {\n                        throw new Error(\"Attmempted to query using a regex with flags, \" +\n                            \"but Influx doesn't support flags in queries.\");\n                    }\n                    this.query.push(\"/\" + value.source + \"/\");\n                    return this;\n                }\n                if (value && typeof value.toString === \"function\") {\n                    this.query.push(value.toString());\n                    return this;\n                }\n                throw new Error(`node-influx doesn't know how to encode the provided value into a ` +\n                    \"query. If you think this is a bug, open an issue here: https://git.io/influx-err\");\n        }\n    }\n    /**\n     * Chains on an AND clause to the expression.\n     * @type {Expression}\n     */\n    get and() {\n        this.query.push(\"AND\");\n        return this;\n    }\n    /**\n     * Chains on an OR clause to the expression.\n     * @type {Expression}\n     */\n    get or() {\n        this.query.push(\"OR\");\n        return this;\n    }\n    /**\n     * Chains on a `+` operator to the expression.\n     * @type {Expression}\n     */\n    get plus() {\n        this.query.push(\"+\");\n        return this;\n    }\n    /**\n     * Chains on a `*` operator to the expression.\n     * @type {Expression}\n     */\n    get times() {\n        this.query.push(\"*\");\n        return this;\n    }\n    /**\n     * Chains on a `-` operator to the expression.\n     * @type {Expression}\n     */\n    get minus() {\n        this.query.push(\"-\");\n        return this;\n    }\n    /**\n     * Chains on a `/` operator to the expression.\n     * @type {Expression}\n     */\n    get div() {\n        this.query.push(\"/\");\n        return this;\n    }\n    /**\n     * Chains on a `=` conditional to the expression.\n     * @type {Expression}\n     */\n    get equals() {\n        this.query.push(\"=\");\n        return this;\n    }\n    /**\n     * Chains on a `=~` conditional to the expression to match regexes.\n     * @type {Expression}\n     */\n    get matches() {\n        this.query.push(\"=~\");\n        return this;\n    }\n    /**\n     * Chains on a `!`` conditional to the expression to match regexes.\n     * @type {Expression}\n     */\n    get doesntMatch() {\n        this.query.push(\"!~\");\n        return this;\n    }\n    /**\n     * Chains on a `!=` conditional to the expression.\n     * @type {Expression}\n     */\n    get notEqual() {\n        this.query.push(\"!=\");\n        return this;\n    }\n    /**\n     * Chains on a `>` conditional to the expression.\n     * @type {Expression}\n     */\n    get gt() {\n        this.query.push(\">\");\n        return this;\n    }\n    /**\n     * Chains on a `>=` conditional to the expression.\n     * @type {Expression}\n     */\n    get gte() {\n        this.query.push(\">=\");\n        return this;\n    }\n    /**\n     * Chains on a `<` conditional to the expression.\n     * @type {Expression}\n     */\n    get lt() {\n        this.query.push(\"<\");\n        return this;\n    }\n    /**\n     * Chains on a `<=` conditional to the expression.\n     * @type {Expression}\n     */\n    get lte() {\n        this.query.push(\"<=\");\n        return this;\n    }\n    /**\n     * Converts the expression into its InfluxQL representation.\n     * @return {String}\n     */\n    toString() {\n        return this.query.join(\" \");\n    }\n}\n/**\n * Measurement creates a reference to a particular measurement. You can\n * reference it solely by its name, but you can also specify the retention\n * policy and database it lives under.\n *\n * @example\n * m.name(\"my_measurement\") // \"my_measurement\"\n * m.name(\"my_measurement\").policy(\"one_day\") // \"one_day\".\"my_measurement\"\n * m.name(\"my_measurement\").policy(\"one_day\").db(\"mydb\") // \"mydb\".one_day\".\"my_measurement\"\n */\nexport class Measurement {\n    constructor() {\n        this.parts = new Array(3);\n    }\n    /**\n     * Sets the measurement name.\n     * @param  {String} name\n     * @return {Measurement}\n     */\n    name(name) {\n        this.parts[2] = name;\n        return this;\n    }\n    /**\n     * Sets the retention policy name.\n     * @param  {String} retentionPolicy\n     * @return {Measurement}\n     */\n    policy(retentionPolicy) {\n        this.parts[1] = retentionPolicy;\n        return this;\n    }\n    /**\n     * Sets the database name.\n     * @param  {String} db\n     * @return {Measurement}\n     */\n    db(db) {\n        this.parts[0] = db;\n        return this;\n    }\n    /**\n     * Converts the measurement into its InfluxQL representation.\n     * @return {String}\n     * @throws {Error} if a measurement name is not provided\n     */\n    toString() {\n        if (!this.parts[2]) {\n            throw new Error(`You must specify a measurement name to query! Got \\`${this.parts[2]}\\``);\n        }\n        return this.parts.filter(p => !!p)\n            .map(p => escape.quoted(p))\n            .join(\".\");\n    }\n}\nexport function parseMeasurement(q) {\n    if (typeof q.measurement === \"function\") {\n        return q.measurement(new Measurement()).toString();\n    }\n    return q.measurement;\n}\nexport function parseWhere(q) {\n    if (typeof q.where === \"function\") {\n        return q.where(new Expression()).toString();\n    }\n    return q.where;\n}\n"
  },
  {
    "__docId__": 10,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Expression",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~Expression",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Expression}",
    "description": "Expression is used to build filtering expressions, like those used in WHERE\nclauses. It can be used for fluent and safe building of queries using\nuntrusted input.",
    "examples": [
      "e => e\n  .field('host').equals.value('ares.peet.io')\n  .or\n  .field('host').matches(/example\\.com$/)\n  .or\n  .expr(e => e\n    .field('country').equals.value('US')\n    .and\n    .field('state').equals.value('WA'));\n\n// Generates:\n// \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n//   (\"county\" = 'US' AND \"state\" = 'WA')"
    ],
    "lineNumber": 22,
    "interface": false
  },
  {
    "__docId__": 11,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#constructor",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 12,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "query",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#query",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "tag",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#tag",
    "access": null,
    "description": "Inserts a tag reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 14,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "field",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#field",
    "access": null,
    "description": "Inserts a field reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 15,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "exp",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#exp",
    "access": null,
    "description": "Inserts a subexpression; invokes the function with a new expression\nthat can be chained on.",
    "examples": [
      "e.field('a').equals.value('b')\n  .or.expr(e =>\n    e.field('b').equals.value('b')\n    .and.field('a').equals.value('c'))\n  .toString()\n// \"a\" = 'b' OR (\"b\" = 'b' AND 'a' = \"c\")"
    ],
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(e: Expression): Expression"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 16,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "value",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#value",
    "access": null,
    "description": "Value chains on a value to the expression.\n\n - Numbers will be inserted verbatim\n - Strings will be escaped and inserted\n - Booleans will be inserted correctly\n - Dates will be formatted and inserted correctly, including NanoDates.\n - Regular expressions will be inserted correctly, however an error will\n   be thrown if they contain flags, as regex flags do not work in Influx\n - Otherwise we'll try to call `.toString()` on the value, throwing\n   if we cannot do so.",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 17,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "and",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#and",
    "access": null,
    "description": "Chains on an AND clause to the expression.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 18,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "or",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#or",
    "access": null,
    "description": "Chains on an OR clause to the expression.",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "plus",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#plus",
    "access": null,
    "description": "Chains on a `+` operator to the expression.",
    "lineNumber": 130,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "times",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#times",
    "access": null,
    "description": "Chains on a `*` operator to the expression.",
    "lineNumber": 138,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 21,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "minus",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#minus",
    "access": null,
    "description": "Chains on a `-` operator to the expression.",
    "lineNumber": 146,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 22,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "div",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#div",
    "access": null,
    "description": "Chains on a `/` operator to the expression.",
    "lineNumber": 154,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 23,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "equals",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#equals",
    "access": null,
    "description": "Chains on a `=` conditional to the expression.",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 24,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "matches",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#matches",
    "access": null,
    "description": "Chains on a `=~` conditional to the expression to match regexes.",
    "lineNumber": 170,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 25,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "doesntMatch",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#doesntMatch",
    "access": null,
    "description": "Chains on a `!`` conditional to the expression to match regexes.",
    "lineNumber": 178,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 26,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "notEqual",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#notEqual",
    "access": null,
    "description": "Chains on a `!=` conditional to the expression.",
    "lineNumber": 186,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 27,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "gt",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#gt",
    "access": null,
    "description": "Chains on a `>` conditional to the expression.",
    "lineNumber": 194,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 28,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "gte",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#gte",
    "access": null,
    "description": "Chains on a `>=` conditional to the expression.",
    "lineNumber": 202,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 29,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "lt",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#lt",
    "access": null,
    "description": "Chains on a `<` conditional to the expression.",
    "lineNumber": 210,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 30,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "lte",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#lte",
    "access": null,
    "description": "Chains on a `<=` conditional to the expression.",
    "lineNumber": 218,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false
  },
  {
    "__docId__": 31,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toString",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#toString",
    "access": null,
    "description": "Converts the expression into its InfluxQL representation.",
    "lineNumber": 226,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 32,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Measurement",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~Measurement",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Measurement}",
    "description": "Measurement creates a reference to a particular measurement. You can\nreference it solely by its name, but you can also specify the retention\npolicy and database it lives under.",
    "examples": [
      "m.name(\"my_measurement\") // \"my_measurement\"\nm.name(\"my_measurement\").policy(\"one_day\") // \"one_day\".\"my_measurement\"\nm.name(\"my_measurement\").policy(\"one_day\").db(\"mydb\") // \"mydb\".one_day\".\"my_measurement\""
    ],
    "lineNumber": 240,
    "interface": false
  },
  {
    "__docId__": 33,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#constructor",
    "access": null,
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 34,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "parts",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#parts",
    "access": null,
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "name",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#name",
    "access": null,
    "description": "Sets the measurement name.",
    "lineNumber": 249,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 36,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "policy",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#policy",
    "access": null,
    "description": "Sets the retention policy name.",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "retentionPolicy",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 37,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "db",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#db",
    "access": null,
    "description": "Sets the database name.",
    "lineNumber": 267,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "db",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 38,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toString",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#toString",
    "access": null,
    "description": "Converts the measurement into its InfluxQL representation.",
    "lineNumber": 276,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if a measurement name is not provided"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 39,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseMeasurement",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~parseMeasurement",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{parseMeasurement}",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 40,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseWhere",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~parseWhere",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{parseWhere}",
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 41,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/doc.js",
    "memberof": null,
    "longname": "src/doc.js",
    "access": null,
    "description": null,
    "lineNumber": 189,
    "content": "/**\n * Pool options can be passed into the database to configure the behaviour\n * of the connection pool.\n * @typedef {Object} PoolOptions\n * @property {Number} [maxRetries=2] Number of times we should retry running\n *     a query before calling back with an error.\n * @property {Number} [requestTimeout=30000] The length of time after which\n *     HTTP requests will error if they do not receive a response.\n * @property {BackoffStrategy} [backoff] The backoff strategy to use for\n *     unhealthy connections. Defaults to an exponential backoff with an\n *     initial delay of 300ms and a maximum delay of 10 seconds.\n */\n/**\n * A SingleHostConfig can be provided into `new InfluxDB(config)` when you\n * have a single Influx address to connect to.\n *\n * @public\n * @typedef {Object} SingleHostConfig\n * @property {String} [username='root'] Username for connecting to the database.\n * @property {String} [password='root'] Password for connecting to the database.\n * @property {String} [database] Default database to operate on. Providing this\n *     will let you omit database names in most operations, and is convenient\n *     if your app is primarily dealing with a single database.\n * @property {String} [host='127.0.0.1'] Influx host to connect to.\n * @property {Number} [port=8060] Influx port to connect to.\n * @property {String} [protocol=\"http\"] Protocol to connect over, either\n *     \"http\" or \"https\".\n * @property {PoolOptions} [pool] Options for the connection pool.\n * @property {SchemaOptions[]} [schema] An optional list of data schema to use.\n *\n * @example\n * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n *\n * // Connect to a single host with a full set of config details and\n * a custom schema\n * const client = new InfluxDB({\n *   database: 'my_db',\n *   host: 'localhost',\n *   port: 8086,\n *   username: 'connor',\n *   password: 'pa$$w0rd',\n *   schema: [{\n *     measurement: 'perf',\n *     tags: ['hostname'],\n *     fields: {\n *       memory_usage: FieldType.INTEGER,\n *       cpu_usage: FieldType.FLOAT,\n *       is_online: FieldType.BOOLEAN,\n *     }\n *   }]\n * })\n */\n/**\n * A ClusterConfig can be provided into `new InfluxDB(config)` when you\n * have a multiple Influx nodes to connect to.\n *\n * @typedef {Object} ClusterConfig\n * @property {String} [username='root'] Username for connecting to the database.\n * @property {String} [password='root'] Password for connecting to the database.\n * @property {String} [database] Default database to operate on. Providing this\n *     will let you omit database names in most operations, and is convenient\n *     if your app is primarily dealing with a single database.\n * @property {Array} hosts A list of Influx hosts to connect to.\n * @property {String} [hosts.host='127.0.0.1'] Influx host to connect to.\n * @property {Number} [hosts.port=8060] Influx port to connect to.\n * @property {String} [hosts.protocol=\"http\"] Protocol to connect over, either\n *     \"http\" or \"https\".\n * @property {PoolOptions} [pool] Options for the connection pool.\n * @property {SchemaOptions[]} [schema] An optional list of data schema to use.\n *\n * @example\n * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n *\n * // Connect to a single host with a full set of config details and\n * a custom schema\n * const client = new InfluxDB({\n *   database: 'my_db',\n *   username: 'connor',\n *   password: 'pa$$w0rd',\n *   hosts: [\n *     { host: 'db1.example.com' },\n *     { host: 'db2.example.com' },\n *   ]\n *   schema: [{\n *     measurement: 'perf',\n *     tags: ['hostname'],\n *     fields: {\n *       memory_usage: FieldType.INTEGER,\n *       cpu_usage: FieldType.FLOAT,\n *       is_online: FieldType.BOOLEAN,\n *     }\n *   }]\n * })\n */\n/**\n * Schema options can be passed into the `new InfluxDB()` constructor to\n * help define the shape of your data. Each schema config corresponds to\n * a measurement in Influx\n *\n * It's recommended, but not required, that you make use of schema; internally\n * we use them to be smarter about coercing your data, and providing immediate\n * error feedback if you try to write data which doesn't fit in your schema:\n * either if you include tags of fields which are not present in your schema,\n * or you enter the wrong datatype for one of your schema fields.\n *\n * @typedef {Object} SchemaOptions\n * @param {String} [database] The database where the measurement lives. This is\n *     required if you don't provide a default database in Influx.\n * @param {String} measurement The measurement name in Influx this refers to\n * @param {Object.<String, FieldType>} fields A mapping of fields names to\n *     their data types. It's assumed that this is a comprehensive mapping of\n *     every field you might write.\n * @param {String[]} tags A list of tag names in this measurement. It's assumed\n *     that this is a comprehensive list of every tag you might write.\n *\n * @example\n * {\n *   measurement: 'perf',\n *   tags: ['hostname'],\n *   fields: {\n *     memory_usage: FieldType.INTEGER,\n *     cpu_usage: FieldType.FLOAT,\n *     is_online: FieldType.BOOLEAN,\n *   }\n * }\n */\n/**\n * Point is passed to the client's write methods to store a point in InfluxDB.\n *\n * @typedef {Object} Point\n * @property {String} measurement Measurement is the Influx measurement name.\n * @property {Object.<String, String>} [tags] Tags is the list of tag\n *     values to insert.\n * @property {Object.<String, *>} [fields] Fields is the list of\n *     field values to insert.\n * @property {Date|string|number} [fields] Timestamp tags this measurement with\n *     a date. This can be a Date object, in which case we'll adjust it to the\n *     desired precision, or a numeric string or number, in which case\n *     it gets passed directly to Influx.\n */\n/**\n * WriteOptions configure how points are written in the database.\n *\n * @typedef {Object} WriteOptions\n * @property {TimePrecision} [precision] Precision at which the points are\n *     written, defaults to milliseconds \"ms\". Influx recommends that you use\n *     the coarsest precision possible in order to maximize efficiency.\n * @property {String} [retentionPolicy] The retention policy to insert\n *     the points under, uses the DEFAULT policy if not provided.\n * @property {String} [database] The database to insert the points in, uses the\n *     adapter's default database if not provided.\n */\n/**\n * The QueryOptions allow you to configure how queries are run against Influx.\n *\n * --\n *\n * Warning: if the epoch is set to nanoseconds `ns`, timestamps will be unable\n * to correctly be represented in JavaScript due to precision limitations. If\n * you wish to read nanosecond-precision timstamps, simply leave it unset; this\n * will cause Influx to return ISO formatted dates which we can parse. See the\n * {@link Results} type for more information about how to access them.\n *\n * @typedef {Object} QueryOptions\n * @property {TimePrecision} [epoch] Epoch defining the precision at which\n *     to query points.\n * @property {String} [retentionPolicy] Retention policy to query from,\n *     defaults to the DEFAULT retention policy.\n * @property {String} [database]  Database under which to query the points.\n *     This is required if a database is not provided in Influx client.\n */\n/**\n * The BackoffStrategy dictates behaviour to use when hosts in the connection\n * pool start failing. We remove them from the pool for a duration of time\n * specified by the backoff strategy.\n *\n * The strategy itself is immutable, and each method call should return a new\n * strategy without modifying the original one.\n *\n * @interface\n * @example\n * let backoff = new MyBackoffStrategy();\n * console.log(backoff.getDelay()); // => 10\n * backoff = backoff.next();\n * console.log(backoff.getDelay()); // => 20\n * backoff = backoff.reset();\n * console.log(backoff.getDelay()); // => 10\n */\nexport class BackoffStrategy {\n    /**\n     * getDelay returns the amount of delay of the current backoff.\n     * @return {Number}\n     */\n    getDelay() { return 0; }\n    /**\n     * Next is called when a failure occurs on a host to\n     * return the next backoff amount.\n     * @return {BackoffStrategy}\n     */\n    next() { return this; }\n    /**\n     * Returns a strategy with a reset backoff counter.\n     * @return {BackoffStrategy}\n     */\n    reset() { return this; }\n}\n"
  },
  {
    "__docId__": 42,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "PoolOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~PoolOptions",
    "access": null,
    "description": "Pool options can be passed into the database to configure the behaviour\nof the connection pool.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2",
        "defaultRaw": 2,
        "name": "maxRetries",
        "description": "Number of times we should retry running\n    a query before calling back with an error."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "30000",
        "defaultRaw": 30000,
        "name": "requestTimeout",
        "description": "The length of time after which\n    HTTP requests will error if they do not receive a response."
      },
      {
        "nullable": null,
        "types": [
          "BackoffStrategy"
        ],
        "spread": false,
        "optional": true,
        "name": "backoff",
        "description": "The backoff strategy to use for\n    unhealthy connections. Defaults to an exponential backoff with an\n    initial delay of 300ms and a maximum delay of 10 seconds."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "PoolOptions"
    }
  },
  {
    "__docId__": 43,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "SingleHostConfig",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~SingleHostConfig",
    "access": "public",
    "description": "A SingleHostConfig can be provided into `new InfluxDB(config)` when you\nhave a single Influx address to connect to.",
    "examples": [
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a full set of config details and\na custom schema\nconst client = new InfluxDB({\n  database: 'my_db',\n  host: 'localhost',\n  port: 8086,\n  username: 'connor',\n  password: 'pa$$w0rd',\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "username",
        "description": "Username for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "password",
        "description": "Password for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Default database to operate on. Providing this\n    will let you omit database names in most operations, and is convenient\n    if your app is primarily dealing with a single database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'127.0.0.1'",
        "defaultRaw": "'127.0.0.1'",
        "name": "host",
        "description": "Influx host to connect to."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8060",
        "defaultRaw": 8060,
        "name": "port",
        "description": "Influx port to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"http\"",
        "defaultRaw": "http",
        "name": "protocol",
        "description": "Protocol to connect over, either\n    \"http\" or \"https\"."
      },
      {
        "nullable": null,
        "types": [
          "PoolOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "pool",
        "description": "Options for the connection pool."
      },
      {
        "nullable": null,
        "types": [
          "SchemaOptions[]"
        ],
        "spread": false,
        "optional": true,
        "name": "schema",
        "description": "An optional list of data schema to use."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "SingleHostConfig"
    }
  },
  {
    "__docId__": 44,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "ClusterConfig",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~ClusterConfig",
    "access": null,
    "description": "A ClusterConfig can be provided into `new InfluxDB(config)` when you\nhave a multiple Influx nodes to connect to.",
    "examples": [
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a full set of config details and\na custom schema\nconst client = new InfluxDB({\n  database: 'my_db',\n  username: 'connor',\n  password: 'pa$$w0rd',\n  hosts: [\n    { host: 'db1.example.com' },\n    { host: 'db2.example.com' },\n  ]\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "username",
        "description": "Username for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "password",
        "description": "Password for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Default database to operate on. Providing this\n    will let you omit database names in most operations, and is convenient\n    if your app is primarily dealing with a single database."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "hosts",
        "description": "A list of Influx hosts to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'127.0.0.1'",
        "defaultRaw": "'127.0.0.1'",
        "name": "hosts.host",
        "description": "Influx host to connect to."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8060",
        "defaultRaw": 8060,
        "name": "hosts.port",
        "description": "Influx port to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"http\"",
        "defaultRaw": "http",
        "name": "hosts.protocol",
        "description": "Protocol to connect over, either\n    \"http\" or \"https\"."
      },
      {
        "nullable": null,
        "types": [
          "PoolOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "pool",
        "description": "Options for the connection pool."
      },
      {
        "nullable": null,
        "types": [
          "SchemaOptions[]"
        ],
        "spread": false,
        "optional": true,
        "name": "schema",
        "description": "An optional list of data schema to use."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ClusterConfig"
    }
  },
  {
    "__docId__": 45,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "SchemaOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~SchemaOptions",
    "access": null,
    "description": "Schema options can be passed into the `new InfluxDB()` constructor to\nhelp define the shape of your data. Each schema config corresponds to\na measurement in Influx\n\nIt's recommended, but not required, that you make use of schema; internally\nwe use them to be smarter about coercing your data, and providing immediate\nerror feedback if you try to write data which doesn't fit in your schema:\neither if you include tags of fields which are not present in your schema,\nor you enter the wrong datatype for one of your schema fields.",
    "examples": [
      "{\n  measurement: 'perf',\n  tags: ['hostname'],\n  fields: {\n    memory_usage: FieldType.INTEGER,\n    cpu_usage: FieldType.FLOAT,\n    is_online: FieldType.BOOLEAN,\n  }\n}"
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database where the measurement lives. This is\n    required if you don't provide a default database in Influx."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "The measurement name in Influx this refers to"
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, FieldType>"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "A mapping of fields names to\n    their data types. It's assumed that this is a comprehensive mapping of\n    every field you might write."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "A list of tag names in this measurement. It's assumed\n    that this is a comprehensive list of every tag you might write."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "SchemaOptions"
    }
  },
  {
    "__docId__": 46,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "Point",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~Point",
    "access": null,
    "description": "Point is passed to the client's write methods to store a point in InfluxDB.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "Measurement is the Influx measurement name."
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, String>"
        ],
        "spread": false,
        "optional": true,
        "name": "tags",
        "description": "Tags is the list of tag\n    values to insert."
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, *>"
        ],
        "spread": false,
        "optional": true,
        "name": "fields",
        "description": "Fields is the list of\n    field values to insert."
      },
      {
        "nullable": null,
        "types": [
          "Date",
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "fields",
        "description": "Timestamp tags this measurement with\n    a date. This can be a Date object, in which case we'll adjust it to the\n    desired precision, or a numeric string or number, in which case\n    it gets passed directly to Influx."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Point"
    }
  },
  {
    "__docId__": 47,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "WriteOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~WriteOptions",
    "access": null,
    "description": "WriteOptions configure how points are written in the database.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TimePrecision"
        ],
        "spread": false,
        "optional": true,
        "name": "precision",
        "description": "Precision at which the points are\n    written, defaults to milliseconds \"ms\". Influx recommends that you use\n    the coarsest precision possible in order to maximize efficiency."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "retentionPolicy",
        "description": "The retention policy to insert\n    the points under, uses the DEFAULT policy if not provided."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database to insert the points in, uses the\n    adapter's default database if not provided."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WriteOptions"
    }
  },
  {
    "__docId__": 48,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "QueryOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~QueryOptions",
    "access": null,
    "description": "The QueryOptions allow you to configure how queries are run against Influx.\n\n--\n\nWarning: if the epoch is set to nanoseconds `ns`, timestamps will be unable\nto correctly be represented in JavaScript due to precision limitations. If\nyou wish to read nanosecond-precision timstamps, simply leave it unset; this\nwill cause Influx to return ISO formatted dates which we can parse. See the\n{@link Results} type for more information about how to access them.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TimePrecision"
        ],
        "spread": false,
        "optional": true,
        "name": "epoch",
        "description": "Epoch defining the precision at which\n    to query points."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "retentionPolicy",
        "description": "Retention policy to query from,\n    defaults to the DEFAULT retention policy."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Database under which to query the points.\n    This is required if a database is not provided in Influx client."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "QueryOptions"
    }
  },
  {
    "__docId__": 49,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "BackoffStrategy",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~BackoffStrategy",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{BackoffStrategy}",
    "description": "The BackoffStrategy dictates behaviour to use when hosts in the connection\npool start failing. We remove them from the pool for a duration of time\nspecified by the backoff strategy.\n\nThe strategy itself is immutable, and each method call should return a new\nstrategy without modifying the original one.",
    "examples": [
      "let backoff = new MyBackoffStrategy();\nconsole.log(backoff.getDelay()); // => 10\nbackoff = backoff.next();\nconsole.log(backoff.getDelay()); // => 20\nbackoff = backoff.reset();\nconsole.log(backoff.getDelay()); // => 10"
    ],
    "lineNumber": 189,
    "interface": true
  },
  {
    "__docId__": 50,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDelay",
    "memberof": "src/doc.js~BackoffStrategy",
    "longname": "src/doc.js~BackoffStrategy#getDelay",
    "access": null,
    "description": "getDelay returns the amount of delay of the current backoff.",
    "lineNumber": 194,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 51,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "next",
    "memberof": "src/doc.js~BackoffStrategy",
    "longname": "src/doc.js~BackoffStrategy#next",
    "access": null,
    "description": "Next is called when a failure occurs on a host to\nreturn the next backoff amount.",
    "lineNumber": 200,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "BackoffStrategy"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 52,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "reset",
    "memberof": "src/doc.js~BackoffStrategy",
    "longname": "src/doc.js~BackoffStrategy#reset",
    "access": null,
    "description": "Returns a strategy with a reset backoff counter.",
    "lineNumber": 205,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "BackoffStrategy"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 53,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/ds.js",
    "memberof": null,
    "longname": "src/grammar/ds.js",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "content": "/**\n * FieldType is an enumeration of InfluxDB field data types.\n * @typedef {Number} FieldType\n * @example\n * import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n *\n * const schema = {\n *   measurement: 'my_measurement',\n *   fields: {\n *     my_int: FieldType.INTEGER,\n *     my_float: FieldType.FLOAT,\n *     my_string: FieldType.STRING,\n *     my_boolean: FieldType.BOOLEAN,\n *   }\n * }\n */\nexport var FieldType;\n(function (FieldType) {\n    FieldType[FieldType[\"FLOAT\"] = 0] = \"FLOAT\";\n    FieldType[FieldType[\"INTEGER\"] = 1] = \"INTEGER\";\n    FieldType[FieldType[\"STRING\"] = 2] = \"STRING\";\n    FieldType[FieldType[\"BOOLEAN\"] = 3] = \"BOOLEAN\";\n})(FieldType || (FieldType = {}));\n;\nconst numericRe = /^[0-9]+$/;\nexport function isNumeric(value) {\n    return numericRe.test(value);\n}\n/**\n * You can provide Raw values to Influx methods to prevent it from escaping\n * your provided string.\n * @class\n * @example\n * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n */\nexport class Raw {\n    /**\n     * Wraps a string so that it is not escaped in Influx queries.\n     * @param {String} value\n     * @example\n     * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Returns the wrapped string.\n     * @return {String}\n     */\n    getValue() {\n        return this.value;\n    }\n}\n"
  },
  {
    "__docId__": 54,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "FieldType",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~FieldType",
    "access": null,
    "description": "FieldType is an enumeration of InfluxDB field data types.",
    "examples": [
      "import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n\nconst schema = {\n  measurement: 'my_measurement',\n  fields: {\n    my_int: FieldType.INTEGER,\n    my_float: FieldType.FLOAT,\n    my_string: FieldType.STRING,\n    my_boolean: FieldType.BOOLEAN,\n  }\n}"
    ],
    "lineNumber": 17,
    "type": {
      "types": [
        "Number"
      ],
      "optional": false,
      "name": "FieldType"
    }
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "numericRe",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~numericRe",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "object"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "isNumeric",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~isNumeric",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{isNumeric}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 57,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Raw",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~Raw",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Raw}",
    "description": "You can provide Raw values to Influx methods to prevent it from escaping\nyour provided string.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 58,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#constructor",
    "access": null,
    "description": "Wraps a string so that it is not escaped in Influx queries.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 59,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "value",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#value",
    "access": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getValue",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#getValue",
    "access": null,
    "description": "Returns the wrapped string.",
    "lineNumber": 50,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 61,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/escape.js",
    "memberof": null,
    "longname": "src/grammar/escape.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Raw } from \"./ds\";\nconst reEscape = /[-|\\\\{()[\\]^$+*?.]/g;\n/**\n * The Escaper escapes the special characters in the provided list\n * with backslashes. Much of the code here is inspired by that in the\n * sqlstring packet found here: https://github.com/mysqljs/sqlstring\n *\n * Instances of the Escaper are derived from the documentation of escape\n * sequences found here: https://aka.ms/co1m4k\n *\n * sqlstring is made available under the following license:\n *\n *   Copyright (c) 2012 Felix Geisendrfer (felix@debuggable.com) and contributors\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *   THE SOFTWARE.\n *\n */\nclass Escaper {\n    constructor(chars, wrap = \"\", escaper = \"\\\\\") {\n        this.wrap = wrap;\n        this.escaper = escaper;\n        const patterns = chars.join(\"\").replace(reEscape, \"\\\\$&\");\n        this.re = new RegExp(\"[\" + patterns + \"]\", \"g\");\n    }\n    /**\n     * Escape replaces occurrences of special characters within the target\n     * string with the necessary escape codes.\n     */\n    escape(val) {\n        if (val instanceof Raw) {\n            return val.getValue();\n        }\n        let chunkIndex = this.re.lastIndex = 0;\n        let escapedVal = \"\";\n        let match = this.re.exec(val);\n        while (match) {\n            escapedVal += val.slice(chunkIndex, match.index) + this.escaper + match[0];\n            chunkIndex = this.re.lastIndex;\n            match = this.re.exec(val);\n        }\n        if (chunkIndex === 0) {\n            return this.wrap + val + this.wrap;\n        }\n        if (chunkIndex < val.length) {\n            return this.wrap + escapedVal + val.slice(chunkIndex) + this.wrap;\n        }\n        return this.wrap + escapedVal + this.wrap;\n    }\n}\nconst bindEsc = (e) => e.escape.bind(e);\n/**\n * tagEscaper escapes tag keys, tag values, and field keys.\n * @type {Object}\n * @property {function(s: string): string } quoted Escapes and wraps quoted\n *     values, such as database names.\n * @property {function(s: string): string } stringLit Escapes and\n *     wraps string literals.\n * @property {function(s: string): string } measurement Escapes measurement\n *     names on the line protocol.\n * @property {function(s: string): string } tag Escapes tag keys, take values,\n *     and field keys on the line protocol.\n *\n * @example\n * console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\n * console.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n *\n * console.log(escape.measurement('my measurement')); // => my\\ measurement\n * console.log(escape.tag('my tag=')); // => my\\ tag\\=\n */\nexport const escape = {\n    /**\n     * measurement escapes measurement names.\n     */\n    measurement: bindEsc(new Escaper([\",\", \" \"])),\n    /**\n     * quoted escapes quoted values, such as database names.\n     */\n    quoted: bindEsc(new Escaper([\"\\\"\"], \"\\\"\")),\n    /**\n     * stringLitEscaper escapes single quotes in string literals.\n     */\n    stringLit: bindEsc(new Escaper([\"'\"], \"'\")),\n    /**\n     * tagEscaper escapes tag keys, tag values, and field keys.\n     */\n    tag: bindEsc(new Escaper([\",\", \"=\", \" \"])),\n};\n"
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "reEscape",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~reEscape",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "object"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Escaper",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~Escaper",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "The Escaper escapes the special characters in the provided list\nwith backslashes. Much of the code here is inspired by that in the\nsqlstring packet found here: https://github.com/mysqljs/sqlstring\n\nInstances of the Escaper are derived from the documentation of escape\nsequences found here: https://aka.ms/co1m4k\n\nsqlstring is made available under the following license:\n\n  Copyright (c) 2012 Felix Geisendrfer (felix@debuggable.com) and contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.",
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 64,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#constructor",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "chars",
        "types": [
          "*"
        ]
      },
      {
        "name": "wrap",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "escaper",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "\\",
        "defaultValue": "\\"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 65,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wrap",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#wrap",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "escaper",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#escaper",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "re",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#re",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "escape",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#escape",
    "access": null,
    "description": "Escape replaces occurrences of special characters within the target\nstring with the necessary escape codes.",
    "lineNumber": 45,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 69,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bindEsc",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~bindEsc",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "escape",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~escape",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{escape}",
    "description": "tagEscaper escapes tag keys, tag values, and field keys.",
    "examples": [
      "console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\nconsole.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n\nconsole.log(escape.measurement('my measurement')); // => my\\ measurement\nconsole.log(escape.tag('my tag=')); // => my\\ tag\\="
    ],
    "lineNumber": 86,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "quoted",
        "description": "Escapes and wraps quoted\n    values, such as database names."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "stringLit",
        "description": "Escapes and\n    wraps string literals."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "Escapes measurement\n    names on the line protocol."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "tag",
        "description": "Escapes tag keys, take values,\n    and field keys on the line protocol."
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 71,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/index.js",
    "memberof": null,
    "longname": "src/grammar/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "export * from \"./escape\";\nexport * from \"./ds\";\nexport * from \"./times\";\n"
  },
  {
    "__docId__": 72,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/times.js",
    "memberof": null,
    "longname": "src/grammar/times.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { isNumeric } from \"./ds\";\n/**\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\n * Influx uses three time formats:\n *  - ISO times with nanoseconds when querying where an epoch is not provided\n *  - Unix timestamps when querying with an epoch (specifying the precision\n *    in the given time unit)\n *  - Its own time format for time literals.\n *\n * To complicate matters, Influx operates on nanosecond precisions\n * by default, but we can't represent nanosecond timestamps in\n * JavaScript numbers as they're 64 bit uints.\n *\n * As a result we have several utilities to convert between these different\n * formats. When precision is required, we represent nanosecond timestamps\n * as strings and wrap default dates in the NanoDate interface which\n * lets the consumer read and write these more precise timestamps.\n *\n * Representing the timestamps as strings is definitely not a pure way to go\n * about it, but importing an arbitrary-precision integer library adds\n * bloat and is a massive hit to throughput. The operations we do do\n * are pretty trivial, so we stick with manipulating strings\n * and make sure to wash our hands when we're done.\n *\n * Vocabulary:\n *  Unix timestamp   = \"timestamp\", abbreviated as \"time\"\n *  ISO timestamp    = \"ISO time\", abbreviated as \"ISO\"\n *  Influx timestamp = \"Influx time\", abbreviated as \"Influx\"\n */\nfunction leftPad(str, length, pad = \"0\") {\n    if (typeof str === \"number\") {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str = pad + str;\n    }\n    return str;\n}\nfunction rightPad(str, length, pad = \"0\") {\n    if (typeof str === \"number\") {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str += pad;\n    }\n    return str;\n}\n/**\n * Covers a nanoseconds unix timestamp to a NanoDate for node-influx. The\n * timestamp is provided as a string to prevent precision loss.\n *\n * @param {String} timestamp\n * @returns {NanoDate}\n * @example\n * const date = toNanoDate('1475985480231035600')\n *\n * // You can use the returned Date as a normal date:\n * expect(date.getTime()).to.equal(1475985480231);\n *\n * // We decorate it with two additional methods to read\n * // nanosecond-precision results:\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n */\nexport function toNanoDate(timestamp) {\n    const date = new Date(Math.floor(Number(timestamp) / nsPer.ms));\n    date._nanoTime = timestamp;\n    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n    return date;\n}\nfunction asNanoDate(date) {\n    const d = date;\n    if (d.getNanoTime) {\n        return d;\n    }\n    return undefined;\n}\n/**\n * Precision is a map of available Influx time precisions.\n * @type {Object.<String, String>}\n * @example\n * console.log(Precision.Hours); // => \"h\"\n * console.log(Precision.Minutes); // => \"m\"\n * console.log(Precision.Seconds); // => \"s\"\n * console.log(Precision.Milliseconds); // => \"ms\"\n * console.log(Precision.Microseconds); // => \"u\"\n * console.log(Precision.Nanoseconds); // => \"ns\"\n */\nexport const Precision = Object.freeze({\n    Hours: \"h\",\n    Microseconds: \"u\",\n    Milliseconds: \"ms\",\n    Minutes: \"m\",\n    Nanoseconds: \"n\",\n    Seconds: \"s\",\n});\nclass MillisecondDateManipulator {\n    format(date) {\n        return \"\\\"\" + leftPad(date.getUTCFullYear(), 2)\n            + \"-\" + leftPad(date.getUTCMonth() + 1, 2)\n            + \"-\" + leftPad(date.getUTCDate(), 2)\n            + \" \" + leftPad(date.getUTCHours(), 2)\n            + \":\" + leftPad(date.getUTCMinutes(), 2)\n            + \":\" + leftPad(date.getUTCSeconds(), 2)\n            + \".\" + leftPad(date.getUTCMilliseconds(), 3) + \"\\\"\";\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case \"n\":\n                ms *= 1000;\n            case \"u\":\n                ms *= 1000;\n            case \"ms\":\n                return String(ms);\n            case \"h\":\n                ms /= 60;\n            case \"m\":\n                ms /= 60;\n            case \"s\":\n                ms /= 1000;\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision \"${precision}\"!`);\n        }\n    }\n    isoToDate(timestamp) {\n        return new Date(timestamp);\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case \"n\":\n                timestamp /= 1000;\n            case \"u\":\n                timestamp /= 1000;\n            case \"ms\":\n                return new Date(timestamp);\n            case \"h\":\n                timestamp *= 60;\n            case \"m\":\n                timestamp *= 60;\n            case \"s\":\n                timestamp *= 1000;\n                return new Date(timestamp);\n            default:\n                throw new Error(`Unknown precision \"${precision}\"!`);\n        }\n    }\n}\nconst nsPer = {\n    ms: Math.pow(10, 6),\n    s: Math.pow(10, 9),\n};\nfunction nanoIsoToTime(iso) {\n    const [secondsStr, decimalStr] = iso.split(\".\");\n    const seconds = Math.floor(new Date(secondsStr + \"Z\").getTime() / 1000);\n    const decimal = rightPad(decimalStr.slice(0, -1), 9);\n    return `${seconds}${decimal}`;\n}\nconst nanoDateMethods = {\n    getNanoTimeFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        return this._cachedNanoTime;\n    },\n    toNanoISOStringFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\n        return `${base}${this._cachedNanoTime.slice(-9)}Z`;\n    },\n    getNanoTimeFromStamp() {\n        return this._nanoTime;\n    },\n    toNanoISOStringFromStamp() {\n        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\n        return `${base}${this._nanoTime.slice(-9)}Z`;\n    },\n};\nclass NanosecondsDateManipulator {\n    format(date) {\n        return \"\\\"\" + leftPad(date.getUTCFullYear(), 2)\n            + \"-\" + leftPad(date.getUTCMonth() + 1, 2)\n            + \"-\" + leftPad(date.getUTCDate(), 2)\n            + \" \" + leftPad(date.getUTCHours(), 2)\n            + \":\" + leftPad(date.getUTCMinutes(), 2)\n            + \":\" + leftPad(date.getUTCSeconds(), 2)\n            + \".\" + date.getNanoTime().slice(-9) + \"\\\"\";\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case \"u\":\n                return date.getNanoTime().slice(0, -3);\n            case \"n\":\n                return date.getNanoTime();\n            case \"h\":\n                ms /= 60;\n            case \"m\":\n                ms /= 60;\n            case \"s\":\n                ms /= 1000;\n            case \"ms\":\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision \"${precision}\"!`);\n        }\n    }\n    isoToDate(timestamp) {\n        let date = new Date(timestamp);\n        date._nanoISO = timestamp;\n        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\n        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\n        return date;\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case \"h\":\n                timestamp *= 60;\n            case \"m\":\n                timestamp *= 60;\n            case \"s\":\n                timestamp *= 1000;\n            case \"ms\":\n                timestamp *= 1000;\n            case \"u\":\n                timestamp *= 1000;\n            case \"n\":\n                return toNanoDate(String(timestamp));\n            default:\n                throw new Error(`Unknown precision \"${precision}\"!`);\n        }\n    }\n}\nconst milliManipulator = new MillisecondDateManipulator();\nconst nanoManipulator = new NanosecondsDateManipulator();\n/**\n * formatDate converts the Date instance to Influx's date query format.\n * @private\n */\nexport function formatDate(date) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.format(nano);\n    }\n    else {\n        return milliManipulator.format(date);\n    }\n}\n/**\n * Converts a Date instance to a timestamp with the specified time precision.\n * @private\n */\nexport function dateToTime(date, precision) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.toTime(nano, precision);\n    }\n    else {\n        return milliManipulator.toTime(date, precision);\n    }\n}\n;\n/**\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\n * the precision is finer than \"ms\" the returned value will be a NanoDate.\n * @private\n */\nexport function isoOrTimeToDate(stamp, precision = \"n\") {\n    const manipulator = !precision || precision === \"u\" || precision === \"n\"\n        ? nanoManipulator\n        : milliManipulator;\n    if (typeof stamp === \"string\") {\n        return manipulator.isoToDate(stamp);\n    }\n    else {\n        return manipulator.timetoDate(stamp, precision);\n    }\n}\n;\n/**\n * Converts a timestamp to a string with the correct precision. Assumes\n * that raw number and string instances are already in the correct precision.\n * @private\n */\nexport function castTimestamp(timestamp, precision) {\n    if (typeof timestamp === \"string\") {\n        if (!isNumeric(timestamp)) {\n            throw new Error(`Expected numeric value for, timestamp, but got \"${timestamp}\"!`);\n        }\n        return timestamp;\n    }\n    if (typeof timestamp === \"number\") {\n        return String(timestamp);\n    }\n    return dateToTime(timestamp, precision);\n}\n;\n"
  },
  {
    "__docId__": 73,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "leftPad",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~leftPad",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "Just a quick overview of what's going on in this file. It's a bit of a mess.\nInflux uses three time formats:\n - ISO times with nanoseconds when querying where an epoch is not provided\n - Unix timestamps when querying with an epoch (specifying the precision\n   in the given time unit)\n - Its own time format for time literals.\n\nTo complicate matters, Influx operates on nanosecond precisions\nby default, but we can't represent nanosecond timestamps in\nJavaScript numbers as they're 64 bit uints.\n\nAs a result we have several utilities to convert between these different\nformats. When precision is required, we represent nanosecond timestamps\nas strings and wrap default dates in the NanoDate interface which\nlets the consumer read and write these more precise timestamps.\n\nRepresenting the timestamps as strings is definitely not a pure way to go\nabout it, but importing an arbitrary-precision integer library adds\nbloat and is a massive hit to throughput. The operations we do do\nare pretty trivial, so we stick with manipulating strings\nand make sure to wash our hands when we're done.\n\nVocabulary:\n Unix timestamp   = \"timestamp\", abbreviated as \"time\"\n ISO timestamp    = \"ISO time\", abbreviated as \"ISO\"\n Influx timestamp = \"Influx time\", abbreviated as \"Influx\"",
    "lineNumber": 30,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 74,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "rightPad",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~rightPad",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 75,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "toNanoDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~toNanoDate",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{toNanoDate}",
    "description": "Covers a nanoseconds unix timestamp to a NanoDate for node-influx. The\ntimestamp is provided as a string to prevent precision loss.",
    "examples": [
      "const date = toNanoDate('1475985480231035600')\n\n// You can use the returned Date as a normal date:\nexpect(date.getTime()).to.equal(1475985480231);\n\n// We decorate it with two additional methods to read\n// nanosecond-precision results:\nexpect(date.getNanoTime()).to.equal('1475985480231035600');\nexpect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');"
    ],
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{NanoDate}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "NanoDate"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 76,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "asNanoDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~asNanoDate",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "Precision",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~Precision",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Precision}",
    "description": "Precision is a map of available Influx time precisions.",
    "examples": [
      "console.log(Precision.Hours); // => \"h\"\nconsole.log(Precision.Minutes); // => \"m\"\nconsole.log(Precision.Seconds); // => \"s\"\nconsole.log(Precision.Milliseconds); // => \"ms\"\nconsole.log(Precision.Microseconds); // => \"u\"\nconsole.log(Precision.Nanoseconds); // => \"ns\""
    ],
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "Object.<String, String>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 78,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "MillisecondDateManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~MillisecondDateManipulator",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 79,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "format",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#format",
    "access": null,
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 80,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toTime",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#toTime",
    "access": null,
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 81,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#isoToDate",
    "access": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 82,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#timetoDate",
    "access": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nsPer",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nsPer",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "nanoIsoToTime",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoIsoToTime",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [
      {
        "name": "iso",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nanoDateMethods",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoDateMethods",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "NanosecondsDateManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 87,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "format",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#format",
    "access": null,
    "description": null,
    "lineNumber": 184,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 88,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toTime",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#toTime",
    "access": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 89,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#isoToDate",
    "access": null,
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 90,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#timetoDate",
    "access": null,
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "milliManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~milliManipulator",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "MillisecondDateManipulator"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nanoManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoManipulator",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 239,
    "undocument": true,
    "type": {
      "types": [
        "NanosecondsDateManipulator"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "formatDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~formatDate",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{formatDate}",
    "description": "formatDate converts the Date instance to Influx's date query format.",
    "lineNumber": 244,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 94,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "dateToTime",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~dateToTime",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{dateToTime}",
    "description": "Converts a Date instance to a timestamp with the specified time precision.",
    "lineNumber": 257,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 95,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "isoOrTimeToDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~isoOrTimeToDate",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{isoOrTimeToDate}",
    "description": "Converts an ISO-formatted data or unix timestamp to a Date instance. If\nthe precision is finer than \"ms\" the returned value will be a NanoDate.",
    "lineNumber": 272,
    "params": [
      {
        "name": "stamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "n",
        "defaultValue": "n"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 96,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "castTimestamp",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~castTimestamp",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{castTimestamp}",
    "description": "Converts a timestamp to a string with the correct precision. Assumes\nthat raw number and string instances are already in the correct precision.",
    "lineNumber": 289,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 97,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/host.js",
    "memberof": null,
    "longname": "src/host.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as urlModule from \"url\";\nexport default class Host {\n    /**\n     * Creates a new Host instance.\n     * @param {String} url\n     * @param {BackoffStrategy} backoff\n     */\n    constructor(url, backoff) {\n        this.backoff = backoff;\n        this.url = urlModule.parse(url);\n    }\n    /**\n     * Marks a failure on the host and returns the length of time it\n     * should be removed from the pool\n     * @return {Number} removal time in milliseconds\n     */\n    fail() {\n        const value = this.backoff.getDelay();\n        this.backoff = this.backoff.next();\n        return value;\n    }\n    /**\n     * Should be called when a successful operation is run against the host.\n     * It resets the host's backoff strategy.\n     */\n    success() {\n        this.backoff = this.backoff.reset();\n    }\n}\n"
  },
  {
    "__docId__": 98,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Host",
    "memberof": "src/host.js",
    "longname": "src/host.js~Host",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "Host",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 99,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#constructor",
    "access": null,
    "description": "Creates a new Host instance.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "BackoffStrategy"
        ],
        "spread": false,
        "optional": false,
        "name": "backoff",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 100,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "url",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#url",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fail",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#fail",
    "access": null,
    "description": "Marks a failure on the host and returns the length of time it\nshould be removed from the pool",
    "lineNumber": 17,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "removal time in milliseconds"
    },
    "generator": false
  },
  {
    "__docId__": 103,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "success",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#success",
    "access": null,
    "description": "Should be called when a successful operation is run against the host.\nIt resets the host's backoff strategy.",
    "lineNumber": 26,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 105,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/index.js",
    "memberof": null,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Pool } from \"./pool\";\nimport { assertNoErrors, parse, parseSingle } from \"./results\";\nimport { Schema, coerceBadly } from \"./schema\";\nimport * as b from \"./builder\";\nimport * as grammar from \"./grammar\";\nimport * as url from \"url\";\nconst defaultHost = Object.freeze({\n    host: \"127.0.0.1\",\n    port: 8086,\n    protocol: \"http\",\n});\nconst defaultOptions = Object.freeze({\n    database: null,\n    hosts: [],\n    password: \"root\",\n    schema: [],\n    username: \"root\",\n});\nexport * from \"./builder\";\nexport { FieldType, Precision, Raw, toNanoDate } from \"./grammar\";\nexport { ResultError } from \"./results\";\n/**\n * Parses the URL out into into a ClusterConfig object\n */\nfunction parseOptionsUrl(addr) {\n    const parsed = url.parse(addr);\n    const options = {\n        host: parsed.hostname,\n        port: Number(parsed.port),\n        protocol: parsed.protocol.slice(0, -1),\n    };\n    if (parsed.auth) {\n        [options.username, options.password] = parsed.auth.split(\":\");\n    }\n    if (parsed.pathname.length > 1) {\n        options.database = parsed.pathname.slice(1);\n    }\n    return options;\n}\n/**\n * Works similarly to Object.assign, but only overwrites\n * properties that resolve to undefined.\n */\nfunction defaults(target, ...srcs) {\n    srcs.forEach(src => {\n        Object.keys(src).forEach(key => {\n            if (target[key] === undefined) {\n                target[key] = src[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * InfluxDB is the public interface to run queries against the your database.\n * This is a \"driver-level\" module, not a a full-fleged ORM or ODM; you run\n * queries directly by calling methods on this class.\n *\n * Please check out some out [the tutorials](https://node-influx.github.io/manual/tutorial.html)\n * if you want help getting started!\n *\n * @example\n * const influx = new Influx.InfluxDB({\n *  host: 'localhost',\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * influx.writePoints([\n *   {\n *     measurement: 'response_times',\n *     tags: { host: os.hostname() },\n *     fields: { duration, path: req.path },\n *   }\n * ]).then(() => {\n *   return influx.query(`\n *     select * from response_times\n *     where host = ${Influx.escape.stringLit(os.hostname())}\n *     order by time desc\n *     limit 10\n *   `)\n * }).then(rows => {\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n * })\n */\nexport class InfluxDB {\n    /**\n     * Connect to a single InfluxDB instance by specifying\n     * a set of connection options.\n     * @param {ClusterConfig|SingleHostConfig|string} options\n     *\n     * @example\n     * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n     *\n     * // Connect to a single host with a DSN:\n     * const client = new InfluxDB('http://user:password@host:8086/database')\n     *\n     * @example\n     * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n     *\n     * // Connect to a single host with a full set of config details and\n     * a custom schema\n     * const client = new InfluxDB({\n     *   database: 'my_db',\n     *   host: 'localhost',\n     *   port: 8086,\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   schema: [{\n     *     measurement: 'perf',\n     *     tags: ['hostname'],\n     *     fields: {\n     *       memory_usage: FieldType.INTEGER,\n     *       cpu_usage: FieldType.FLOAT,\n     *       is_online: FieldType.BOOLEAN,\n     *     }\n     *   }]\n     * })\n     *\n     * @example\n     * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n     *\n     * // Use a pool of several host connections and balance queries across them:\n     * const client = new InfluxDB({\n     *   database: 'my_db',\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   hosts: [\n     *     { host: 'db1.example.com' },\n     *     { host: 'db2.example.com' },\n     *   ]\n     *   schema: [{\n     *     measurement: 'perf',\n     *     tags: ['hostname'],\n     *     fields: {\n     *       memory_usage: FieldType.INTEGER,\n     *       cpu_usage: FieldType.FLOAT,\n     *       is_online: FieldType.BOOLEAN,\n     *     }\n     *   }]\n     * })\n     *\n     */\n    constructor(options) {\n        /**\n         * Map of Schema instances defining measurements in Influx.\n         * @private\n         */\n        this.schema = Object.create(null);\n        // Figure out how to parse whatever we were passed in into a ClusterConfig.\n        if (typeof options === \"string\") {\n            options = parseOptionsUrl(options);\n        }\n        else if (!options) {\n            options = defaultHost;\n        }\n        if (!options.hasOwnProperty(\"hosts\")) {\n            options = {\n                database: options.database,\n                hosts: [options],\n                password: options.password,\n                pool: options.pool,\n                schema: options.schema,\n                username: options.username,\n            };\n        }\n        const resolved = options;\n        resolved.hosts = resolved.hosts.map(host => {\n            return defaults({\n                host: host.host,\n                port: host.port,\n                protocol: host.protocol,\n            }, defaultHost);\n        });\n        this.pool = new Pool(resolved.pool);\n        this.options = defaults(resolved, defaultOptions);\n        resolved.hosts.forEach(host => {\n            this.pool.addHost(`${host.protocol}://${host.host}:${host.port}`);\n        });\n        this.options.schema.forEach(schema => {\n            const db = schema.database || this.options.database;\n            if (!db) {\n                throw new Error(`Schema ${schema.measurement} doesn't have a database specified,` +\n                    \"and no default database is provided!\");\n            }\n            if (!this.schema[db]) {\n                this.schema[db] = Object.create(null);\n            }\n            this.schema[db][schema.measurement] = new Schema(schema);\n        });\n    }\n    /**\n     * Creates a new database with the provided name.\n     * @param {string} databaseName\n     * @return {Promise.<void>}\n     * @example\n     * return influx.createDatabase('mydb')\n     */\n    createDatabase(databaseName) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create database ${grammar.escape.quoted(databaseName)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Deletes a database with the provided name.\n     * @param {string} databaseName\n     * @return {Promise.<void>}\n     * @example\n     * return influx.createDatabase('mydb')\n     */\n    dropDatabase(databaseName) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop database ${grammar.escape.quoted(databaseName)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Returns array of database names. Requires cluster admin privileges.\n     * @returns {Promise<String[]>} a list of database names\n     * @example\n     * return influx.getMeasurements().then(names =>\n     *   console.log('My database names are: ' + names.join(', ')));\n     */\n    getDatabaseNames() {\n        return this.pool.json(this.getQueryOpts({ q: \"show databases\" }))\n            .then(res => parseSingle(res).map(r => r.name));\n    }\n    /**\n     * Returns array of measurements.\n     * @returns {Promise<String[]>} a list of measurement names\n     * @example\n     * return influx.getMeasurements().then(names =>\n     *   console.log('My measurement names are: ' + names.join(', ')));\n     */\n    getMeasurements() {\n        return this.pool.json(this.getQueryOpts({ q: \"show measurements\" }))\n            .then(res => parseSingle(res).map(r => r.name));\n    }\n    /**\n     * Returns a list of all series within the target measurement, or from the\n     * entire database if a measurement isn't provided.\n     * @param {String} [measurement] if provided, we'll only get series from\n     *     within that measurement.\n     * @returns {Promise<String[]>} a list of series names\n     * @example\n     * influx.getSeries().then(names =>\n     *   console.log('My series names are: ' + names.join(', ')));\n     *\n     * influx.getSeries(\"my_measurement\").then(names =>\n     *   console.log('My series names in my_measurement are: ' + names.join(', ')));\n     */\n    getSeries(measurement) {\n        let query = \"show series\";\n        if (measurement) {\n            query += ` from ${grammar.escape.quoted(measurement)}`;\n        }\n        return this.pool.json(this.getQueryOpts({ q: query }))\n            .then(res => parseSingle(res).map(r => r.key));\n    }\n    /**\n     * Removes a measurement from the database.\n     * @param {string} measurementName\n     * @return {Promise.<void>}\n     * @example\n     * dropMeasurement('my_measurement', err => done(err))\n     * // => DROP MEASUREMENT \"my_measurement\"\n     */\n    dropMeasurement(measurementName) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop measurement ${grammar.escape.quoted(measurementName)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Removes a one or more series from InfluxDB.\n     *\n     * @returns {Promise<void>}\n     * @example\n     * // The following pairs of queries are equivalent: you can chose either to\n     * // use our builder or pass in string directly. The builder takes care\n     * // of escaping and most syntax handling for you.\n     *\n     * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\n     * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n     * // DROP SERIES WHERE \"cpu\" = 'cpu8'\n     *\n     * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\n     * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n     * // DROP SERIES FROM \"autogen\".\"cpu\"\n     *\n     * influx.dropSeries({\n     *   measurement: m => m.name('cpu').policy('autogen'),\n     *   where: e => e.tag('cpu').equals.value('cpu8')\n     * })\n     * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\n     */\n    dropSeries(options) {\n        let q = \"drop series\";\n        if (\"measurement\" in options) {\n            q += \" from \" + b.parseMeasurement(options);\n        }\n        if (\"where\" in options) {\n            q += \" where \" + b.parseWhere(options);\n        }\n        return this.pool.json(this.getQueryOpts({ q }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Returns a list of users on the Influx database.\n     * @return {Promise<Array<{ user: String, admin: Boolean }>>}\n     * @example\n     * influx.getUsers().then(users => {\n     *   users.forEach(user => {\n     *     if (user.admin) {\n     *       console.log(user.user, 'is an admin!')\n     *     } else {\n     *       console.log(user.user, 'is not an admin!')\n     *     }\n     *   })\n     * })\n     */\n    getUsers() {\n        return this.pool.json(this.getQueryOpts({ q: \"show users\" })).then(parseSingle);\n    }\n    /**\n     * Creates a new InfluxDB user.\n     * @param {String} username\n     * @param {String} password\n     * @param {Boolean} [admin=false] If true, the user will be given all\n     *     privileges on all databases.\n     * @returns {Promise<void>}\n     * @example\n     * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n     *\n     * // make non-admins:\n     * influx.createUser('not_admin', 'pa55w0rd')\n     */\n    createUser(username, password, admin = false) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create user ${grammar.escape.quoted(username)} with password `\n                + grammar.escape.stringLit(password)\n                + (admin ? \" with all privileges\" : \"\"),\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Sets a password for an Influx user.\n     * @param {String} username\n     * @param {String} password\n     * @returns {Promise<void>}\n     * @example\n     * influx.setPassword('connor', 'pa55w0rd')\n     */\n    setPassword(username, password) {\n        return this.pool.json(this.getQueryOpts({\n            q: `set password for ${grammar.escape.quoted(username)} = `\n                + grammar.escape.stringLit(password),\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Grants a privilege to a specified user.\n     * @param {String} username\n     * @param {String} privilege Should be one of \"READ\" or \"WRITE\"\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\n     */\n    grantPrivilege(username, privilege, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `grant ${privilege} to ${grammar.escape.quoted(username)} on `\n                + grammar.escape.quoted(database),\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Removes a privilege from a specified user.\n     * @param {String} username\n     * @param {String} privilege Should be one of \"READ\" or \"WRITE\"\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\n     */\n    revokePrivilege(username, privilege, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `revoke ${privilege} from ${grammar.escape.quoted(username)} on `\n                + grammar.escape.quoted(database),\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Grants admin privileges to a specified user.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.grantAdminPrivilege('connor', 'READ', 'my_db')\n     */\n    grantAdminPrivilege(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `grant all to ${grammar.escape.quoted(username)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Removes a admin privilege from a specified user.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.revokeAdminPrivilege('connor')\n     */\n    revokeAdminPrivilege(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `revoke all from ${grammar.escape.quoted(username)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Removes a user from the database.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.dropUser('connor')\n     */\n    dropUser(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop user ${grammar.escape.quoted(username)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param {String} name The query name, for later reference\n     * @param {String} query The body of the query to run\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.createContinuousQuery('downsample_cpu_1h', `\n     *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n     *   FROM \"1d\".\"perf\" GROUP BY time(1m)\n     * `)\n     */\n    createContinuousQuery(name, query, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create continuous query ${grammar.escape.quoted(name)}`\n                + ` on ${grammar.escape.quoted(database)} begin ${query} end`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param {String} name The query name\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.dropContinuousQuery('downsample_cpu_1h')\n     */\n    dropContinuousQuery(name, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop continuous query ${grammar.escape.quoted(name)}`\n                + ` on ${grammar.escape.quoted(database)}`,\n        }, \"POST\")).then(assertNoErrors);\n    }\n    /**\n     * writePoints sends a list of points together in a batch to InfluxDB. In\n     * each point you must specify the measurement name to write into as well\n     * as a list of tag and field values. Optionally, you can specify the\n     * time to tag that point at, defaulting to the current time.\n     *\n     * If you defined a schema for the measurement in the options you passed\n     * to `new Influx(options)`, we'll use that to make sure that types get\n     * cast correctly and that there are no extraneous fields or columns.\n     *\n     * For best performance, it's recommended that you batch your data into\n     * sets of a couple thousand records before writing it. In the future we'll\n     * have some utilities within node-influx to make this easier.\n     *\n     * ---\n     *\n     * A note when using manually-specified times and precisions: by default\n     * we write using the `ms` precision since that's what JavaScript gives us.\n     * You can adjust this. However, there is some special behaviour if you\n     * manually specify a timestamp in your points:\n     *  - if you specify the timestamp as a Date object, we'll convert it to\n     *    milliseconds and manipulate it as needed to get the right precision\n     *  - if provide a NanoDate as returned from {@link toNanoTime} or the\n     *    results from an Influx query, we'll be able to pull the precise\n     *    nanosecond timestamp and manipulate it to get the right precision\n     *  - if you provide a string or number as the timestamp, we'll pass it\n     *    straight into Influx.\n     *\n     * Please see the Point and WriteOptions type for a\n     * full list of possible options.\n     *\n     * @param {Point[]} points\n     * @param {WriteOptions} [options]\n     * @return {Promise<void>}\n     * @example\n     * // write a point into the default database with\n     * // the default retention policy.\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     fields: { host: 'box1.example.com' },\n     *     tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     *\n     * // you can manually specify the database,\n     * // retention policy, and time precision:\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     fields: { host: 'box1.example.com' },\n     *     tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *     timestamp: getLastRecordedTime(),\n     *   }\n     * ], {\n     *   database: 'my_db',\n     *   retentionPolicy: '1d',\n     *   precision: 's'\n     * })\n     */\n    writePoints(points, options = {}) {\n        const { database = this.defaultDB(), precision = \"ms\", retentionPolicy, } = options;\n        let payload = \"\";\n        points.forEach(point => {\n            const { fields = {}, tags = {}, measurement, timestamp, } = point;\n            const schema = this.schema[database] && this.schema[database][measurement];\n            const fieldsPairs = schema ? schema.coerceFields(fields) : coerceBadly(fields);\n            const tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\n            payload += (payload.length > 0 ? \"\\n\" : \"\") + measurement;\n            for (let i = 0; i < tagsNames.length; i++) {\n                payload += \",\"\n                    + grammar.escape.tag(tagsNames[i])\n                    + \"=\"\n                    + grammar.escape.tag(tags[tagsNames[i]]);\n            }\n            for (let i = 0; i < fieldsPairs.length; i++) {\n                payload += (i === 0 ? \" \" : \",\")\n                    + grammar.escape.tag(fieldsPairs[i][0])\n                    + \"=\"\n                    + fieldsPairs[i][1];\n            }\n            if (timestamp !== undefined) {\n                payload += \" \" + grammar.castTimestamp(timestamp, precision);\n            }\n        });\n        return this.pool.discard({\n            body: payload,\n            method: \"POST\",\n            path: \"/write\",\n            query: Object.assign({\n                db: database,\n                p: this.options.password,\n                precision,\n                rp: retentionPolicy,\n                u: this.options.username,\n            }),\n        });\n    }\n    /**\n     * writeMeasurement functions similarly to {@link InfluxDB#writePoints}, but\n     * it automatically fills in the `measurement` value for all points for you.\n     *\n     * @param {String} measurement\n     * @param {Point[]} points\n     * @param {WriteOptions} [options]\n     * @return {Promise<void>}\n     * @example\n     * influx.writeMeasurement('perf', [\n     *   {\n     *     fields: { host: 'box1.example.com' },\n     *     tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     */\n    writeMeasurement(measurement, points, options = {}) {\n        points = points.map(p => Object.assign({ measurement }, p));\n        return this.writePoints(points, options);\n    }\n    /**\n     * .query() run a query (or list of queries), runs them, and returns the\n     * results in a friendly format. If you run multiple queries, multiple\n     * sets of results will be returned, otherwise a single result will\n     * be returned.\n     *\n     * @param {String|String[]} query\n     * @param {QueryOptions} [options]\n     * @return {Promise<Results|Results[]>} query\n     * @example\n     * influx.query('select * from perf').then(results => {\n     *   console.log(results)\n     * })\n     */\n    query(query, options = {}) {\n        if (Array.isArray(query)) {\n            query = query.join(\";\");\n        }\n        return this.queryRaw(query, options).then(res => parse(res, options.epoch));\n    }\n    /**\n     * queryRaw functions similarly to .query() but it does no fancy\n     * transformations on the returned data; it calls `JSON.parse` and returns\n     * those results verbatim.\n     *\n     * @param {String|String[]} query\n     * @param {QueryOptions} [options]\n     * @return {Promise<*>}\n     * @example\n     * influx.queryRaw('select * from perf').then(rawData => {\n     *   console.log(rawData)\n     * })\n     */\n    queryRaw(query, options = {}) {\n        const { database = this.defaultDB(), epoch, retentionPolicy, } = options;\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            epoch,\n            q: query,\n            rp: retentionPolicy,\n        }));\n    }\n    /**\n     * Returns the default database that queries operates on. It throws if called\n     * when a default database isn't set.\n     * @private\n     */\n    defaultDB() {\n        if (!this.options.database) {\n            throw new Error(\"Attempted to run an influx query without a default\"\n                + \" database specified or an explicit interface provided.\");\n        }\n        return this.options.database;\n    }\n    /**\n     * Creates options to be passed into the pool to query databases.\n     * @private\n     */\n    getQueryOpts(params, method = \"GET\") {\n        return {\n            method,\n            path: \"/query\",\n            query: Object.assign({\n                p: this.options.password,\n                u: this.options.username,\n            }, params),\n        };\n    }\n}\n"
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultHost",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultHost",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultOptions",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultOptions",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseOptionsUrl",
    "memberof": "src/index.js",
    "longname": "src/index.js~parseOptionsUrl",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "Parses the URL out into into a ClusterConfig object",
    "lineNumber": 25,
    "params": [
      {
        "name": "addr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 110,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "defaults",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaults",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "Works similarly to Object.assign, but only overwrites\nproperties that resolve to undefined.",
    "lineNumber": 44,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "srcs",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 111,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InfluxDB",
    "memberof": "src/index.js",
    "longname": "src/index.js~InfluxDB",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{InfluxDB}",
    "description": "InfluxDB is the public interface to run queries against the your database.\nThis is a \"driver-level\" module, not a a full-fleged ORM or ODM; you run\nqueries directly by calling methods on this class.\n\nPlease check out some out [the tutorials](https://node-influx.github.io/manual/tutorial.html)\nif you want help getting started!",
    "examples": [
      "const influx = new Influx.InfluxDB({\n host: 'localhost',\n database: 'express_response_db',\n schema: [\n   {\n     measurement: 'response_times',\n     fields: {\n       path: Influx.FieldType.STRING,\n       duration: Influx.FieldType.INTEGER\n     },\n     tags: [\n       'host'\n     ]\n   }\n ]\n})\n\ninflux.writePoints([\n  {\n    measurement: 'response_times',\n    tags: { host: os.hostname() },\n    fields: { duration, path: req.path },\n  }\n]).then(() => {\n  return influx.query(`\n    select * from response_times\n    where host = ${Influx.escape.stringLit(os.hostname())}\n    order by time desc\n    limit 10\n  `)\n}).then(rows => {\n  rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n})"
    ],
    "lineNumber": 97,
    "interface": false
  },
  {
    "__docId__": 112,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#constructor",
    "access": null,
    "description": "Connect to a single InfluxDB instance by specifying\na set of connection options.",
    "examples": [
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a DSN:\nconst client = new InfluxDB('http://user:password@host:8086/database')",
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a full set of config details and\na custom schema\nconst client = new InfluxDB({\n  database: 'my_db',\n  host: 'localhost',\n  port: 8086,\n  username: 'connor',\n  password: 'pa$$w0rd',\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})",
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Use a pool of several host connections and balance queries across them:\nconst client = new InfluxDB({\n  database: 'my_db',\n  username: 'connor',\n  password: 'pa$$w0rd',\n  hosts: [\n    { host: 'db1.example.com' },\n    { host: 'db2.example.com' },\n  ]\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})"
    ],
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "ClusterConfig",
          "SingleHostConfig",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 113,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "schema",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#schema",
    "access": "private",
    "description": "Map of Schema instances defining measurements in Influx.",
    "lineNumber": 160,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "pool",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#pool",
    "access": null,
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#options",
    "access": null,
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createDatabase",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createDatabase",
    "access": null,
    "description": "Creates a new database with the provided name.",
    "examples": [
      "return influx.createDatabase('mydb')"
    ],
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 117,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropDatabase",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropDatabase",
    "access": null,
    "description": "Deletes a database with the provided name.",
    "examples": [
      "return influx.createDatabase('mydb')"
    ],
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 118,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDatabaseNames",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getDatabaseNames",
    "access": null,
    "description": "Returns array of database names. Requires cluster admin privileges.",
    "examples": [
      "return influx.getMeasurements().then(names =>\n  console.log('My database names are: ' + names.join(', ')));"
    ],
    "lineNumber": 234,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of database names"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of database names"
    },
    "generator": false
  },
  {
    "__docId__": 119,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getMeasurements",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getMeasurements",
    "access": null,
    "description": "Returns array of measurements.",
    "examples": [
      "return influx.getMeasurements().then(names =>\n  console.log('My measurement names are: ' + names.join(', ')));"
    ],
    "lineNumber": 245,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of measurement names"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of measurement names"
    },
    "generator": false
  },
  {
    "__docId__": 120,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSeries",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getSeries",
    "access": null,
    "description": "Returns a list of all series within the target measurement, or from the\nentire database if a measurement isn't provided.",
    "examples": [
      "influx.getSeries().then(names =>\n  console.log('My series names are: ' + names.join(', ')));\n\ninflux.getSeries(\"my_measurement\").then(names =>\n  console.log('My series names in my_measurement are: ' + names.join(', ')));"
    ],
    "lineNumber": 262,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of series names"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "measurement",
        "description": "if provided, we'll only get series from\n    within that measurement."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of series names"
    },
    "generator": false
  },
  {
    "__docId__": 121,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropMeasurement",
    "access": null,
    "description": "Removes a measurement from the database.",
    "examples": [
      "dropMeasurement('my_measurement', err => done(err))\n// => DROP MEASUREMENT \"my_measurement\""
    ],
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "measurementName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 122,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropSeries",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropSeries",
    "access": null,
    "description": "Removes a one or more series from InfluxDB.",
    "examples": [
      "// The following pairs of queries are equivalent: you can chose either to\n// use our builder or pass in string directly. The builder takes care\n// of escaping and most syntax handling for you.\n\ninflux.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\ninflux.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n// DROP SERIES WHERE \"cpu\" = 'cpu8'\n\ninflux.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\ninflux.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n// DROP SERIES FROM \"autogen\".\"cpu\"\n\ninflux.dropSeries({\n  measurement: m => m.name('cpu').policy('autogen'),\n  where: e => e.tag('cpu').equals.value('cpu8')\n})\n// DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'"
    ],
    "lineNumber": 306,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 123,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getUsers",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getUsers",
    "access": null,
    "description": "Returns a list of users on the Influx database.",
    "examples": [
      "influx.getUsers().then(users => {\n  users.forEach(user => {\n    if (user.admin) {\n      console.log(user.user, 'is an admin!')\n    } else {\n      console.log(user.user, 'is not an admin!')\n    }\n  })\n})"
    ],
    "lineNumber": 330,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<{ user: String, admin: Boolean }>>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 124,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createUser",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createUser",
    "access": null,
    "description": "Creates a new InfluxDB user.",
    "examples": [
      "influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n\n// make non-admins:\ninflux.createUser('not_admin', 'pa55w0rd')"
    ],
    "lineNumber": 346,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "admin",
        "description": "If true, the user will be given all\n    privileges on all databases."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 125,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setPassword",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#setPassword",
    "access": null,
    "description": "Sets a password for an Influx user.",
    "examples": [
      "influx.setPassword('connor', 'pa55w0rd')"
    ],
    "lineNumber": 361,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 126,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "grantPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#grantPrivilege",
    "access": null,
    "description": "Grants a privilege to a specified user.",
    "examples": [
      "influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor"
    ],
    "lineNumber": 376,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of \"READ\" or \"WRITE\""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 127,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "revokePrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#revokePrivilege",
    "access": null,
    "description": "Removes a privilege from a specified user.",
    "examples": [
      "influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor"
    ],
    "lineNumber": 391,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of \"READ\" or \"WRITE\""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 128,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "grantAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#grantAdminPrivilege",
    "access": null,
    "description": "Grants admin privileges to a specified user.",
    "examples": [
      "influx.grantAdminPrivilege('connor', 'READ', 'my_db')"
    ],
    "lineNumber": 404,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 129,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "revokeAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#revokeAdminPrivilege",
    "access": null,
    "description": "Removes a admin privilege from a specified user.",
    "examples": [
      "influx.revokeAdminPrivilege('connor')"
    ],
    "lineNumber": 416,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 130,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropUser",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropUser",
    "access": null,
    "description": "Removes a user from the database.",
    "examples": [
      "influx.dropUser('connor')"
    ],
    "lineNumber": 428,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 131,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createContinuousQuery",
    "access": null,
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.createContinuousQuery('downsample_cpu_1h', `\n  SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n  FROM \"1d\".\"perf\" GROUP BY time(1m)\n`)"
    ],
    "lineNumber": 445,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name, for later reference"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "The body of the query to run"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 132,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropContinuousQuery",
    "access": null,
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.dropContinuousQuery('downsample_cpu_1h')"
    ],
    "lineNumber": 459,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 133,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "writePoints",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#writePoints",
    "access": null,
    "description": "writePoints sends a list of points together in a batch to InfluxDB. In\neach point you must specify the measurement name to write into as well\nas a list of tag and field values. Optionally, you can specify the\ntime to tag that point at, defaulting to the current time.\n\nIf you defined a schema for the measurement in the options you passed\nto `new Influx(options)`, we'll use that to make sure that types get\ncast correctly and that there are no extraneous fields or columns.\n\nFor best performance, it's recommended that you batch your data into\nsets of a couple thousand records before writing it. In the future we'll\nhave some utilities within node-influx to make this easier.\n\n---\n\nA note when using manually-specified times and precisions: by default\nwe write using the `ms` precision since that's what JavaScript gives us.\nYou can adjust this. However, there is some special behaviour if you\nmanually specify a timestamp in your points:\n - if you specify the timestamp as a Date object, we'll convert it to\n   milliseconds and manipulate it as needed to get the right precision\n - if provide a NanoDate as returned from {@link toNanoTime} or the\n   results from an Influx query, we'll be able to pull the precise\n   nanosecond timestamp and manipulate it to get the right precision\n - if you provide a string or number as the timestamp, we'll pass it\n   straight into Influx.\n\nPlease see the Point and WriteOptions type for a\nfull list of possible options.",
    "examples": [
      "// write a point into the default database with\n// the default retention policy.\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    fields: { host: 'box1.example.com' },\n    tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])\n\n// you can manually specify the database,\n// retention policy, and time precision:\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    fields: { host: 'box1.example.com' },\n    tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n    timestamp: getLastRecordedTime(),\n  }\n], {\n  database: 'my_db',\n  retentionPolicy: '1d',\n  precision: 's'\n})"
    ],
    "lineNumber": 525,
    "params": [
      {
        "nullable": null,
        "types": [
          "Point[]"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "WriteOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 134,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "writeMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#writeMeasurement",
    "access": null,
    "description": "writeMeasurement functions similarly to {@link InfluxDB#writePoints}, but\nit automatically fills in the `measurement` value for all points for you.",
    "examples": [
      "influx.writeMeasurement('perf', [\n  {\n    fields: { host: 'box1.example.com' },\n    tags: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])"
    ],
    "lineNumber": 579,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Point[]"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "WriteOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 135,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "query",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#query",
    "access": null,
    "description": ".query() run a query (or list of queries), runs them, and returns the\nresults in a friendly format. If you run multiple queries, multiple\nsets of results will be returned, otherwise a single result will\nbe returned.",
    "examples": [
      "influx.query('select * from perf').then(results => {\n  console.log(results)\n})"
    ],
    "lineNumber": 597,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "QueryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Results",
        "Results[]>"
      ],
      "spread": false,
      "description": "query"
    },
    "generator": false
  },
  {
    "__docId__": 136,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "queryRaw",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#queryRaw",
    "access": null,
    "description": "queryRaw functions similarly to .query() but it does no fancy\ntransformations on the returned data; it calls `JSON.parse` and returns\nthose results verbatim.",
    "examples": [
      "influx.queryRaw('select * from perf').then(rawData => {\n  console.log(rawData)\n})"
    ],
    "lineNumber": 616,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "QueryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 137,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "defaultDB",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#defaultDB",
    "access": "private",
    "description": "Returns the default database that queries operates on. It throws if called\nwhen a default database isn't set.",
    "lineNumber": 630,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 138,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getQueryOpts",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getQueryOpts",
    "access": "private",
    "description": "Creates options to be passed into the pool to query databases.",
    "lineNumber": 641,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "method",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "GET",
        "defaultValue": "GET"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 139,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/pool.js",
    "memberof": null,
    "longname": "src/pool.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from \"./backoff/exponential\";\nimport Host from \"./host\";\nimport * as http from \"http\";\nimport * as querystring from \"querystring\";\n/**\n * Status codes that will cause a host to be marked as \"failed\" if we get\n * them from a request to Influx.\n * @type {Array}\n */\nconst resubmitErrorCodes = [\n    \"ETIMEDOUT\",\n    \"ESOCKETTIMEDOUT\",\n    \"ECONNRESET\",\n    \"ECONNREFUSED\",\n    \"EHOSTUNREACH\",\n];\n/**\n * An ServiceNotAvailableError is returned as an error from requests that\n * result in a > 500 error code.\n */\nexport class ServiceNotAvailableError extends Error {\n}\n/**\n * An RequestError is returned as an error from requests that\n * result in a 300 <= error code <= 500.\n */\nexport class RequestError extends Error {\n    constructor(req, res, body) {\n        super(`A ${res.statusCode} ${res.statusMessage} error occurred: ${body}`);\n        this.req = req;\n        this.res = res;\n    }\n    static from(req, res, callback) {\n        let body = \"\";\n        res.setEncoding(\"utf8\");\n        res.on(\"data\", str => body = body + str);\n        res.on(\"end\", () => callback(new RequestError(req, res, body)));\n    }\n}\n/**\n *\n * The Pool maintains a list available Influx hosts and dispatches requests\n * to them. If there are errors connecting to hosts, it will disable that\n * host for a period of time.\n */\nexport class Pool {\n    /**\n     * Creates a new Pool instance.\n     * @param {PoolOptions} options\n     */\n    constructor(options) {\n        this.options = Object.assign({\n            backoff: new ExponentialBackoff({\n                initial: 300,\n                max: 10 * 1000,\n                random: 1,\n            }),\n            maxRetries: 2,\n            requestTimeout: 30 * 1000,\n        }, options);\n        this.index = 0;\n        this.hostsAvailable = new Set();\n        this.hostsDisabled = new Set();\n        this.timeout = this.options.requestTimeout;\n    }\n    /**\n     * Returns a list of currently active hosts.\n     * @return {Host[]}\n     */\n    getHostsAvailable() {\n        return Array.from(this.hostsAvailable);\n    }\n    /**\n     * Returns a list of hosts that are currently disabled due to network\n     * errors.\n     * @return {Host[]}\n     */\n    getHostsDisabled() {\n        return Array.from(this.hostsDisabled);\n    }\n    /**\n     * Inserts a new host to the pool.\n     */\n    addHost(url) {\n        const host = new Host(url, this.options.backoff.reset());\n        this.hostsAvailable.add(host);\n        return host;\n    }\n    /**\n     * Returns true if there\"s any host available to by queried.\n     * @return {Boolean}\n     */\n    hostIsAvailable() {\n        return this.hostsAvailable.size > 0;\n    }\n    /**\n     * Makes a request and calls back with the response, parsed as JSON.\n     * An error is returned on a non-2xx status code or on a parsing exception.\n     */\n    json(options) {\n        return this.text(options).then(res => JSON.parse(res));\n    }\n    /**\n     * Makes a request and resolves with the plain text response,\n     * if possible. An error is raised on a non-2xx status code.\n     */\n    text(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                let output = \"\";\n                res.setEncoding(\"utf8\");\n                res.on(\"data\", str => { output = output + str; });\n                res.on(\"end\", () => resolve(output));\n            });\n        });\n    }\n    /**\n     * Makes a request and discards any response body it receives.\n     * An error is returned on a non-2xx status code.\n     */\n    discard(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                res.on(\"data\", () => { });\n                res.on(\"end\", () => resolve());\n            });\n        });\n    }\n    /**\n     * Makes a request and calls back with the IncomingMessage stream,\n     * if possible. An error is returned on a non-2xx status code.\n     */\n    stream(options, callback) {\n        if (!this.hostIsAvailable()) {\n            return callback(new ServiceNotAvailableError(\"No host available\"), null);\n        }\n        // In Node, responses can come in after `timeout` events are fired,\n        // but we don't want to fire callbacks twice. Create guarding functions\n        // to prevent this.\n        let isHandled = false;\n        const shouldHandle = () => {\n            const should = !isHandled;\n            isHandled = true;\n            return should;\n        };\n        let path = options.path;\n        if (options.query) {\n            path += \"?\" + querystring.stringify(options.query);\n        }\n        const host = this.getHost();\n        const req = http.request({\n            headers: { \"content-length\": options.body ? options.body.length : 0 },\n            hostname: host.url.hostname,\n            method: options.method,\n            path,\n            port: Number(host.url.port),\n            protocol: host.url.protocol,\n        }, res => {\n            if (!shouldHandle()) {\n                return;\n            }\n            // Resolve an error if we get a >500 status code. Note that we *exclude*\n            // 500 error codes. Sometimes malformed queries to influx cause panics,\n            // and trying to retry those queries on other hosts would just lead\n            // to a domino effect of crashing servers.\n            if (res.statusCode > 500) {\n                return this.handleRequestError(new ServiceNotAvailableError(res.statusMessage), host, options, callback);\n            }\n            if (res.statusCode >= 300) {\n                return RequestError.from(req, res, err => callback(err, res));\n            }\n            host.success();\n            return callback(undefined, res);\n        });\n        // Handle network or HTTP parsing errors:\n        req.on(\"error\", err => {\n            if (shouldHandle()) {\n                this.handleRequestError(err, host, options, callback);\n            }\n        });\n        // Handle timeouts:\n        req.setTimeout(this.timeout, () => {\n            if (shouldHandle()) {\n                this.handleRequestError(new ServiceNotAvailableError(\"Request timed out\"), host, options, callback);\n            }\n        });\n        // Write out the body:\n        if (options.body) {\n            req.write(options.body);\n        }\n        req.end();\n    }\n    /**\n     * Returns the next available host for querying.\n     * @return {Host}\n     */\n    getHost() {\n        const available = Array.from(this.hostsAvailable);\n        const host = available[this.index];\n        this.index = (this.index + 1) % available.length;\n        return host;\n    }\n    /**\n     * Re-enables the provided host, returning it to the pool to query.\n     * @param  {Host} host\n     */\n    enableHost(host) {\n        this.hostsDisabled.delete(host);\n        this.hostsAvailable.add(host);\n    }\n    /**\n     * Disables the provided host, removing it from the query pool. It will be\n     * re-enabled after a backoff interval\n     */\n    disableHost(host) {\n        this.hostsAvailable.delete(host);\n        this.hostsDisabled.add(host);\n        this.index %= Math.max(1, this.hostsAvailable.size);\n        setTimeout(() => this.enableHost(host), host.fail());\n    }\n    handleRequestError(err, host, options, callback) {\n        if (!(err instanceof ServiceNotAvailableError) &&\n            resubmitErrorCodes.indexOf(err.code) === -1) {\n            return callback(err, null);\n        }\n        this.disableHost(host);\n        const retries = options.retries || 0;\n        if (retries < this.options.maxRetries && this.hostIsAvailable()) {\n            options.retries = retries + 1;\n            return this.stream(options, callback);\n        }\n        callback(err, null);\n    }\n}\n"
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resubmitErrorCodes",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~resubmitErrorCodes",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "Status codes that will cause a host to be marked as \"failed\" if we get\nthem from a request to Influx.",
    "lineNumber": 10,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ServiceNotAvailableError",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~ServiceNotAvailableError",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{ServiceNotAvailableError}",
    "description": "An ServiceNotAvailableError is returned as an error from requests that\nresult in a > 500 error code.",
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 142,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "RequestError",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~RequestError",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{RequestError}",
    "description": "An RequestError is returned as an error from requests that\nresult in a 300 <= error code <= 500.",
    "lineNumber": 27,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 143,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#constructor",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "req",
        "types": [
          "*"
        ]
      },
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "body",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 144,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "req",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#req",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "res",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#res",
    "access": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "from",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError.from",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "req",
        "types": [
          "*"
        ]
      },
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 147,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Pool",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~Pool",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Pool}",
    "description": "\nThe Pool maintains a list available Influx hosts and dispatches requests\nto them. If there are errors connecting to hosts, it will disable that\nhost for a period of time.",
    "lineNumber": 46,
    "interface": false
  },
  {
    "__docId__": 148,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#constructor",
    "access": null,
    "description": "Creates a new Pool instance.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "PoolOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 149,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#options",
    "access": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "hostsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostsAvailable",
    "access": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "hostsDisabled",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostsDisabled",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "timeout",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#timeout",
    "access": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHostsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHostsAvailable",
    "access": null,
    "description": "Returns a list of currently active hosts.",
    "lineNumber": 70,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 155,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHostsDisabled",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHostsDisabled",
    "access": null,
    "description": "Returns a list of hosts that are currently disabled due to network\nerrors.",
    "lineNumber": 78,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 156,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#addHost",
    "access": null,
    "description": "Inserts a new host to the pool.",
    "lineNumber": 84,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 157,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "hostIsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostIsAvailable",
    "access": null,
    "description": "Returns true if there\"s any host available to by queried.",
    "lineNumber": 93,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 158,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "json",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#json",
    "access": null,
    "description": "Makes a request and calls back with the response, parsed as JSON.\nAn error is returned on a non-2xx status code or on a parsing exception.",
    "lineNumber": 100,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 159,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "text",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#text",
    "access": null,
    "description": "Makes a request and resolves with the plain text response,\nif possible. An error is raised on a non-2xx status code.",
    "lineNumber": 107,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 160,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "discard",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#discard",
    "access": null,
    "description": "Makes a request and discards any response body it receives.\nAn error is returned on a non-2xx status code.",
    "lineNumber": 124,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 161,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "stream",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#stream",
    "access": null,
    "description": "Makes a request and calls back with the IncomingMessage stream,\nif possible. An error is returned on a non-2xx status code.",
    "lineNumber": 139,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 162,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHost",
    "access": null,
    "description": "Returns the next available host for querying.",
    "lineNumber": 203,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 163,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "enableHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#enableHost",
    "access": null,
    "description": "Re-enables the provided host, returning it to the pool to query.",
    "lineNumber": 213,
    "params": [
      {
        "nullable": null,
        "types": [
          "Host"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 165,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "disableHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#disableHost",
    "access": null,
    "description": "Disables the provided host, removing it from the query pool. It will be\nre-enabled after a backoff interval",
    "lineNumber": 221,
    "params": [
      {
        "name": "host",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 166,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "handleRequestError",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#handleRequestError",
    "access": null,
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "host",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 168,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/results.js",
    "memberof": null,
    "longname": "src/results.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { isoOrTimeToDate } from \"./grammar\";\n/**\n * A ResultError is thrown when a query generates errorful results from Influx.\n */\nexport class ResultError extends Error {\n    constructor(message) {\n        super(`Error from InfluxDB: ${message}`);\n    }\n}\nfunction groupMethod(matcher) {\n    // We do a tiny bit of \"custom\" deep equality checking here, taking\n    // advantage of the fact that the tag keys are consistent across all\n    // series results. This lets us match groupings much more efficiently,\n    // ~6000x faster than the fastest vanilla equality checker (lodash)\n    // when operating on large (~100,000 grouping) sets.\n    const srcKeys = this.groupsTagsKeys;\n    const dstKeys = Object.keys(matcher);\n    if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\n        return [];\n    }\n    L: for (let i = 0; i < this.groupRows.length; i++) {\n        for (let k = 0; k < srcKeys.length; k++) {\n            if (this.groupRows[i].tags[srcKeys[k]] !== matcher[srcKeys[k]]) {\n                continue L;\n            }\n        }\n        return this.groupRows[i].rows;\n    }\n    return [];\n}\nfunction groupsMethod() {\n    return this.groupRows;\n}\n/**\n * Inner parsing function which unpacks the series into a table and attaches\n * methods to the array. This is quite optimized and a bit of a mess to read,\n * but it's all fairly easy procedural logic.\n *\n * We do this instead of subclassing Array since subclassing has some\n * undesirable side-effects. For example, calling .slice() on the array\n * makes it impossible to preserve groups as would be necessary if it's\n * subclassed.\n */\nfunction parseInner(series = [], precision) {\n    const results = new Array();\n    const tags = results.groupsTagsKeys\n        = series.length && series[0].tags ? Object.keys(series[0].tags) : [];\n    let nextGroup = new Array();\n    results.groupRows = new Array(series.length);\n    for (let i = 0, lastEnd = 0; i < series.length; i++, lastEnd = results.length) {\n        const { columns = [], values = [], } = series[i];\n        for (let k = 0; k < values.length; k++) {\n            const obj = {};\n            for (let j = 0; j < columns.length; j++) {\n                if (columns[j] === \"time\") {\n                    obj.time = isoOrTimeToDate(values[k][j], precision);\n                }\n                else {\n                    obj[columns[j]] = values[k][j];\n                }\n            }\n            for (let j = 0; j < tags.length; j++) {\n                obj[tags[j]] = series[i].tags[tags[j]];\n            }\n            results.push(obj);\n            nextGroup.push(obj);\n        }\n        results.groupRows[i] = {\n            rows: nextGroup,\n            tags: series[i].tags || {},\n        };\n        nextGroup = [];\n    }\n    results.group = groupMethod;\n    results.groups = groupsMethod;\n    return results;\n}\n/**\n * Checks if there are any errors in the Response and, if so, it throws them.\n * @private\n * @throws {ResultError}\n */\nexport function assertNoErrors(res) {\n    for (let i = 0; i < res.results.length; i++) {\n        const { error } = res.results[i];\n        if (error) {\n            throw new ResultError(error);\n        }\n    }\n    return res;\n}\n/**\n * From parses out a response to a result or list of responses.\n * There are three situations we cover here:\n *  1. A single query without groups, like `select * from myseries`\n *  2. A single query with groups, generated with a `group by` statement\n *     which groups by series *tags*, grouping by times is case (1)\n *  3. Multiple queries of types 1 and 2\n * @private\n */\nexport function parse(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length === 1) {\n        return parseInner(res.results[0].series, precision);\n    }\n    else {\n        return res.results.map(result => parseInner(result.series, precision));\n    }\n}\n/**\n * parseSingle asserts that the response contains a single result,\n * and returns that result.\n * @throws {Error} if the number of results is not exactly one\n * @private\n */\nexport function parseSingle(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length !== 1) {\n        throw new Error(\"node-influx expected the results length to equal 1, but \" +\n            `it was ${0}. Please report this here: https://git.io/influx-err`);\n    }\n    return parseInner(res.results[0].series, precision);\n}\n"
  },
  {
    "__docId__": 169,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ResultError",
    "memberof": "src/results.js",
    "longname": "src/results.js~ResultError",
    "access": null,
    "export": true,
    "importPath": "influx/",
    "importStyle": "{ResultError}",
    "description": "A ResultError is thrown when a query generates errorful results from Influx.",
    "lineNumber": 5,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 170,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/results.js~ResultError",
    "longname": "src/results.js~ResultError#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 171,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "groupMethod",
    "memberof": "src/results.js",
    "longname": "src/results.js~groupMethod",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "matcher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 172,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "groupsMethod",
    "memberof": "src/results.js",
    "longname": "src/results.js~groupsMethod",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 173,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseInner",
    "memberof": "src/results.js",
    "longname": "src/results.js~parseInner",
    "access": null,
    "export": false,
    "importPath": "influx/",
    "importStyle": null,
    "description": "Inner parsing function which unpacks the series into a table and attaches\nmethods to the array. This is quite optimized and a bit of a mess to read,\nbut it's all fairly easy procedural logic.\n\nWe do this instead of subclassing Array since subclassing has some\nundesirable side-effects. For example, calling .slice() on the array\nmakes it impossible to preserve groups as would be necessary if it's\nsubclassed.",
    "lineNumber": 44,
    "params": [
      {
        "name": "series",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 174,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "assertNoErrors",
    "memberof": "src/results.js",
    "longname": "src/results.js~assertNoErrors",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{assertNoErrors}",
    "description": "Checks if there are any errors in the Response and, if so, it throws them.",
    "lineNumber": 83,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "ResultError"
        ],
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 175,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parse",
    "memberof": "src/results.js",
    "longname": "src/results.js~parse",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{parse}",
    "description": "From parses out a response to a result or list of responses.\nThere are three situations we cover here:\n 1. A single query without groups, like `select * from myseries`\n 2. A single query with groups, generated with a `group by` statement\n    which groups by series *tags*, grouping by times is case (1)\n 3. Multiple queries of types 1 and 2",
    "lineNumber": 101,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 176,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseSingle",
    "memberof": "src/results.js",
    "longname": "src/results.js~parseSingle",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{parseSingle}",
    "description": "parseSingle asserts that the response contains a single result,\nand returns that result.",
    "lineNumber": 116,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the number of results is not exactly one"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 177,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/schema.js",
    "memberof": null,
    "longname": "src/schema.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { FieldType, escape, isNumeric } from \"./grammar\";\n/**\n * The Schema provides information and utilities for an InfluxDB measurement.\n * @private\n */\nexport class Schema {\n    constructor(options) {\n        this.options = options;\n        this.tagHash = {};\n        // fieldNames are sorted for performance: when coerceFields is run the\n        // fields will be added to the output in order.\n        this.fieldNames = Object.keys(options.fields).sort();\n        options.tags.forEach(tag => { this.tagHash[tag] = true; });\n    }\n    /**\n     * coerceFields converts a map of field values to a strings which\n     * can be injected into the line protocol without further escaping.\n     * The output is given in [key, value] pairs.\n     */\n    coerceFields(fields) {\n        let consumed = 0;\n        const output = [];\n        this.fieldNames.forEach(field => {\n            if (!fields.hasOwnProperty(field)) {\n                return;\n            }\n            const value = fields[field];\n            const typ = typeof value;\n            consumed++;\n            if (value == null) {\n                return;\n            }\n            let coerced;\n            switch (this.options.fields[field]) {\n                case FieldType.STRING:\n                    coerced = escape.quoted(String(value));\n                    break;\n                case FieldType.INTEGER:\n                    if (typ !== \"number\" && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this.ref(field)}, but got \"${value}\"!`);\n                    }\n                    coerced = String(Math.floor(value)) + \"i\";\n                    break;\n                case FieldType.FLOAT:\n                    if (typ !== \"number\" && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this.ref(field)}, but got \"${value}\"!`);\n                    }\n                    coerced = String(value);\n                    break;\n                case FieldType.BOOLEAN:\n                    if (typ !== \"boolean\") {\n                        throw new Error(`Expected boolean value for ${this.ref(field)}, but got a ${typ}!`);\n                    }\n                    coerced = value ? \"T\" : \"F\";\n                    break;\n                default:\n                    throw new Error(`Unknown field type ${this.options.fields[field]} for ${field} in ` +\n                        `${this.ref()}. Please ensure that your configuration is correct.`);\n            }\n            output.push([field, coerced]);\n        });\n        const keys = Object.keys(fields);\n        if (consumed !== keys.length) {\n            const extraneous = keys.filter(f => this.fieldNames.indexOf(f) === -1);\n            throw new Error(`Extraneous fields detected for writing InfluxDB point in` +\n                `${this.ref()}: \\`${extraneous.join(\"`, `\")}\\`.`);\n        }\n        return output;\n    }\n    /**\n     * Throws an error if the tags include values other than\n     * what was specified in the schema. It returns a list of tag names.\n     */\n    checkTags(tags) {\n        const names = Object.keys(tags);\n        const extraneous = names.filter(tag => !this.tagHash[tag]);\n        if (extraneous.length > 0) {\n            throw new Error(`Extraneous tags detected for writing InfluxDB point in` +\n                `${this.ref()}: \\`${extraneous.join(\"`, `\")}\\`.`);\n        }\n        return names;\n    }\n    /**\n     * Returns the \"db\".\"measurement\"[.\"field\"] referencing the current schema.\n     */\n    ref(field) {\n        let out = this.options.database + \".\" + this.options.measurement;\n        if (field) {\n            out += \".\" + field;\n        }\n        return out;\n    }\n}\n/**\n * Coerces the field map to a set of writable values, a la coerceFields,\n * using native guesses based on the field datatypes.\n * @private\n */\nexport function coerceBadly(fields) {\n    return Object.keys(fields).sort().map(field => {\n        const value = fields[field];\n        if (typeof value === \"string\") {\n            return [field, escape.quoted(value)];\n        }\n        else {\n            return [field, String(value)];\n        }\n    });\n}\n;\n"
  },
  {
    "__docId__": 178,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Schema",
    "memberof": "src/schema.js",
    "longname": "src/schema.js~Schema",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{Schema}",
    "description": "The Schema provides information and utilities for an InfluxDB measurement.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 180,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#options",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "tagHash",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#tagHash",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "fieldNames",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#fieldNames",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "coerceFields",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#coerceFields",
    "access": null,
    "description": "coerceFields converts a map of field values to a strings which\ncan be injected into the line protocol without further escaping.\nThe output is given in [key, value] pairs.",
    "lineNumber": 20,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 184,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "checkTags",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#checkTags",
    "access": null,
    "description": "Throws an error if the tags include values other than\nwhat was specified in the schema. It returns a list of tag names.",
    "lineNumber": 74,
    "params": [
      {
        "name": "tags",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 185,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "ref",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#ref",
    "access": null,
    "description": "Returns the \"db\".\"measurement\"[.\"field\"] referencing the current schema.",
    "lineNumber": 86,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 186,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "coerceBadly",
    "memberof": "src/schema.js",
    "longname": "src/schema.js~coerceBadly",
    "access": "private",
    "export": true,
    "importPath": "influx/",
    "importStyle": "{coerceBadly}",
    "description": "Coerces the field map to a set of writable values, a la coerceFields,\nusing native guesses based on the field datatypes.",
    "lineNumber": 99,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 188,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 189,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 190,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 191,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 192,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 193,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 194,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 195,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 196,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 197,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 198,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 199,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 200,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 201,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 202,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 203,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 204,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 205,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 206,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 207,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 208,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 209,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 210,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 211,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 212,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 213,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 214,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 215,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 216,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 217,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 218,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 219,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 220,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 221,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 222,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 223,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 224,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 225,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 226,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 227,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 228,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 229,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 230,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 231,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 232,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 233,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 234,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 236,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 237,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 238,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 239,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 240,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 241,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 242,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 243,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 244,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/backoff.test.js",
    "memberof": null,
    "longname": "unit/backoff.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from \"../../src/backoff/exponential\";\nimport { expect } from \"./helpers\";\ndescribe(\"backoff strategies\", () => {\n    describe(\"exponential strategy\", () => {\n        it(\"appears to work\", () => {\n            let exp = new ExponentialBackoff({\n                initial: 500,\n                max: 5000,\n                random: 1,\n            });\n            function next() {\n                const value = exp.getDelay();\n                exp = exp.next();\n                return value;\n            }\n            const checkSequence = () => {\n                expect(next()).to.equal(500);\n                expect(next()).to.be.oneOf([500, 1000]);\n                expect(next()).to.be.oneOf([1000, 2000]);\n                expect(next()).to.be.oneOf([2000, 4000]);\n                expect(next()).to.be.oneOf([4000, 5000]);\n                expect(next()).to.equal(5000);\n            };\n            checkSequence();\n            exp = exp.reset();\n            const dupe = exp.reset();\n            checkSequence();\n            exp = dupe;\n            checkSequence();\n        });\n    });\n});\n"
  },
  {
    "__docId__": 245,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe0",
    "testId": 0,
    "memberof": "unit/backoff.test.js",
    "testDepth": 0,
    "longname": "unit/backoff.test.js~describe0",
    "access": null,
    "description": "backoff strategies",
    "lineNumber": 3
  },
  {
    "__docId__": 246,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe1",
    "testId": 1,
    "memberof": "unit/backoff.test.js~describe0",
    "testDepth": 1,
    "longname": "unit/backoff.test.js~describe0.describe1",
    "access": null,
    "description": "exponential strategy",
    "lineNumber": 4
  },
  {
    "__docId__": 247,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it2",
    "testId": 2,
    "memberof": "unit/backoff.test.js~describe0.describe1",
    "testDepth": 2,
    "longname": "unit/backoff.test.js~describe0.describe1.it2",
    "access": null,
    "description": "appears to work",
    "lineNumber": 5
  },
  {
    "__docId__": 248,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/builder.test.js",
    "memberof": null,
    "longname": "unit/builder.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Expression, Measurement, toNanoDate } from '../../src/index';\nimport { expect } from './helpers';\ndescribe('query builder', () => {\n    describe('measurement builder', () => {\n        it('builds with only name', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .toString()).to.equal('\"my_\\\\\"meas\"');\n        });\n        it('builds with name and rp', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .policy('po\"licy')\n                .toString()).to.equal('\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it('builds with name, rp, and db', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .policy('po\"licy')\n                .db('my_\"db')\n                .toString()).to.equal('\"my_\\\\\"db\".\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it('builds with name and db', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .db('my_\"db')\n                .toString()).to.equal('\"my_\\\\\"db\".\"my_\\\\\"meas\"');\n        });\n        it('throws when a name is omitted', () => {\n            expect(() => new Measurement()\n                .db('my_\"db')\n                .toString()).to.throw(/must specify a measurement/);\n        });\n    });\n    describe('expression builder', () => {\n        it('creates basic queries', () => {\n            expect(new Expression()\n                .tag('my_\"tag')\n                .equals\n                .value('42')\n                .toString()).to.equal('\"my_\\\\\"tag\" = \\'42\\'');\n        });\n        it('inserts data types correctly', () => {\n            expect(new Expression()\n                .field('f')\n                .equals\n                .value('str\\'')\n                .or\n                .field('f')\n                .matches\n                .value(/[0-9]+/)\n                .or\n                .field('f')\n                .equals\n                .value(42)\n                .or\n                .field('f')\n                .equals\n                .tag('my_\"tag')\n                .or\n                .field('f')\n                .equals\n                .value(new Date(1475985480231))\n                .or\n                .field('f')\n                .equals\n                .value(toNanoDate('1475985480231035600'))\n                .or\n                .field('f')\n                .equals\n                .value(true)\n                .or\n                .exp(e => e.field('a').equals.value(1).or.field('b').equals.value(2))\n                .or\n                .field('f')\n                .doesntMatch\n                .value({ toString: () => '/my-custom-re/' })\n                .toString()).to.equal('\"f\" = \\'str\\\\\\'\\' OR \"f\" =~ /[0-9]+/ OR \"f\" = 42 ' +\n                'OR \"f\" = \"my_\\\\\"tag\" OR \"f\" = \"2016-10-09 03:58:00.231\" ' +\n                'OR \"f\" = \"2016-10-09 03:58:00.231035600\" OR \"f\" = TRUE ' +\n                'OR (\"a\" = 1 OR \"b\" = 2) OR \"f\" !~ /my-custom-re/');\n        });\n        it('throws when using a flagged regex', () => {\n            expect(() => new Expression().field('f').matches.value(/a/i))\n                .to.throw(/doesn't support flags/);\n        });\n        it('throws when using un-stringifyable object', () => {\n            expect(() => new Expression().field('f').equals.value(Object.create(null)))\n                .to.throw(/doesn't know how to encode/);\n        });\n        const operationsTable = [\n            { method: 'equals', yields: '=' },\n            { method: 'notEqual', yields: '!=' },\n            { method: 'gt', yields: '>' },\n            { method: 'gte', yields: '>=' },\n            { method: 'lt', yields: '<' },\n            { method: 'lte', yields: '<=' },\n            { method: 'plus', yields: '+' },\n            { method: 'minus', yields: '-' },\n            { method: 'times', yields: '*' },\n            { method: 'div', yields: '/' },\n            { method: 'and', yields: 'AND' },\n            { method: 'or', yields: 'OR' },\n            { method: 'matches', yields: '=~' },\n            { method: 'doesntMatch', yields: '!~' },\n        ];\n        operationsTable.forEach(({ method, yields }) => {\n            it(`yields ${yields} from .${method}`, () => {\n                expect(new Expression().field('f')[method].value(true).toString())\n                    .to.equal(`\"f\" ${yields} TRUE`);\n            });\n        });\n    });\n});\n"
  },
  {
    "__docId__": 249,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe3",
    "testId": 3,
    "memberof": "unit/builder.test.js",
    "testDepth": 0,
    "longname": "unit/builder.test.js~describe3",
    "access": null,
    "description": "query builder",
    "lineNumber": 3
  },
  {
    "__docId__": 250,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe4",
    "testId": 4,
    "memberof": "unit/builder.test.js~describe3",
    "testDepth": 1,
    "longname": "unit/builder.test.js~describe3.describe4",
    "access": null,
    "description": "measurement builder",
    "lineNumber": 4
  },
  {
    "__docId__": 251,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it5",
    "testId": 5,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it5",
    "access": null,
    "description": "builds with only name",
    "lineNumber": 5
  },
  {
    "__docId__": 252,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it6",
    "testId": 6,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it6",
    "access": null,
    "description": "builds with name and rp",
    "lineNumber": 10
  },
  {
    "__docId__": 253,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it7",
    "testId": 7,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it7",
    "access": null,
    "description": "builds with name, rp, and db",
    "lineNumber": 16
  },
  {
    "__docId__": 254,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it8",
    "testId": 8,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it8",
    "access": null,
    "description": "builds with name and db",
    "lineNumber": 23
  },
  {
    "__docId__": 255,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it9",
    "testId": 9,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it9",
    "access": null,
    "description": "throws when a name is omitted",
    "lineNumber": 29
  },
  {
    "__docId__": 256,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe10",
    "testId": 10,
    "memberof": "unit/builder.test.js~describe3",
    "testDepth": 1,
    "longname": "unit/builder.test.js~describe3.describe10",
    "access": null,
    "description": "expression builder",
    "lineNumber": 35
  },
  {
    "__docId__": 257,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it11",
    "testId": 11,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it11",
    "access": null,
    "description": "creates basic queries",
    "lineNumber": 36
  },
  {
    "__docId__": 258,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it12",
    "testId": 12,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it12",
    "access": null,
    "description": "inserts data types correctly",
    "lineNumber": 43
  },
  {
    "__docId__": 259,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it13",
    "testId": 13,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it13",
    "access": null,
    "description": "throws when using a flagged regex",
    "lineNumber": 83
  },
  {
    "__docId__": 260,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it14",
    "testId": 14,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it14",
    "access": null,
    "description": "throws when using un-stringifyable object",
    "lineNumber": 87
  },
  {
    "__docId__": 261,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it15",
    "testId": 15,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it15",
    "access": null,
    "lineNumber": 108
  },
  {
    "__docId__": 262,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/grammar.test.js",
    "memberof": null,
    "longname": "unit/grammar.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as grammar from \"../../src/grammar\";\nimport { expect } from \"./helpers\";\nconst escapeTables = require(\"../fixture/escapeTables.json\");\ndescribe(\"grammar\", () => {\n    Object.keys(escapeTables).forEach(escaper => {\n        describe(escaper, () => {\n            escapeTables[escaper].forEach(test => {\n                it(`escapes \\`${test[0]}\\` as \\`${test[1]}\\``, () => {\n                    expect(grammar.escape[escaper](test[0])).to.equal(test[1]);\n                });\n            });\n        });\n    });\n    it('does not escape raw values', () => {\n        expect(grammar.escape.quoted(new grammar.Raw('don\"t escape'))).to.equal('don\"t escape');\n    });\n    let nanoDate;\n    let milliDate;\n    beforeEach(() => {\n        nanoDate = grammar.isoOrTimeToDate('2016-10-09T03:58:00.231035677Z', 'n');\n        milliDate = new Date(1475985480231);\n    });\n    it('converts a nanoseconds timestamp to a nano date', () => {\n        const date = grammar.toNanoDate('1475985480231035600');\n        expect(date.getTime()).to.equal(1475985480231);\n        expect(date.getNanoTime()).to.equal('1475985480231035600'); // precision is lost\n        expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n    });\n    describe('formatting', () => {\n        it(\"formats nanosecond dates\", () => {\n            expect(grammar.formatDate(nanoDate)).to.equal(\"\\\"2016-10-09 03:58:00.231035677\\\"\");\n        });\n        it(\"formats millisecond dates\", () => {\n            expect(grammar.formatDate(milliDate)).to.equal(\"\\\"2016-10-09 03:58:00.231\\\"\");\n        });\n    });\n    describe('parsing', () => {\n        it('parses ISO dates correctly', () => {\n            const parsed = grammar.isoOrTimeToDate('2016-10-09T03:58:00.231035677Z', 'n');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035677');\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035677Z');\n        });\n        it('parses numeric `ns` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035677, 'n');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035600'); // precision is lost\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n        });\n        it('parses numeric `u` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035, 'u');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035000');\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035000Z');\n        });\n        it('parses numeric `ms` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231, 'ms');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed).to.not.have.property('getNanoTime');\n        });\n        it('parses numeric `s` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480, 's');\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed).to.not.have.property('getNanoTime');\n        });\n        it('parses numeric `m` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(24599758, 'm');\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed).to.not.have.property('getNanoTime');\n        });\n        it('parses numeric `h` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(409995, 'h');\n            expect(parsed.getTime()).to.equal(1475982000000);\n            expect(parsed).to.not.have.property('getNanoTime');\n        });\n    });\n    describe(\"timestamp casting\", () => {\n        it(\"casts dates into timestamps\", () => {\n            const d = new Date(1475121809084);\n            expect(grammar.castTimestamp(d, \"n\")).to.equal('1475121809084000000');\n            expect(grammar.castTimestamp(d, \"u\")).to.equal('1475121809084000');\n            expect(grammar.castTimestamp(d, \"ms\")).to.equal('1475121809084');\n            expect(grammar.castTimestamp(d, \"s\")).to.equal('1475121809');\n            expect(grammar.castTimestamp(d, \"m\")).to.equal('24585363');\n            expect(grammar.castTimestamp(d, \"h\")).to.equal('409756');\n        });\n        it(\"casts nanodates into timestamps\", () => {\n            const d = grammar.toNanoDate('1475985480231035600');\n            expect(grammar.castTimestamp(d, \"n\")).to.equal('1475985480231035600');\n            expect(grammar.castTimestamp(d, \"u\")).to.equal('1475985480231035');\n            expect(grammar.castTimestamp(d, \"ms\")).to.equal('1475985480231');\n            expect(grammar.castTimestamp(d, \"s\")).to.equal('1475985480');\n            expect(grammar.castTimestamp(d, \"m\")).to.equal('24599758');\n            expect(grammar.castTimestamp(d, \"h\")).to.equal('409995');\n        });\n    });\n});\n"
  },
  {
    "__docId__": 263,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe16",
    "testId": 16,
    "memberof": "unit/grammar.test.js",
    "testDepth": 0,
    "longname": "unit/grammar.test.js~describe16",
    "access": null,
    "description": "grammar",
    "lineNumber": 4
  },
  {
    "__docId__": 264,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe17",
    "testId": 17,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe17",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 265,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it18",
    "testId": 18,
    "memberof": "unit/grammar.test.js~describe16.describe17",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe17.it18",
    "access": null,
    "lineNumber": 8
  },
  {
    "__docId__": 266,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it19",
    "testId": 19,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.it19",
    "access": null,
    "description": "does not escape raw values",
    "lineNumber": 14
  },
  {
    "__docId__": 267,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it20",
    "testId": 20,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.it20",
    "access": null,
    "description": "converts a nanoseconds timestamp to a nano date",
    "lineNumber": 23
  },
  {
    "__docId__": 268,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe21",
    "testId": 21,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe21",
    "access": null,
    "description": "formatting",
    "lineNumber": 29
  },
  {
    "__docId__": 269,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it22",
    "testId": 22,
    "memberof": "unit/grammar.test.js~describe16.describe21",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe21.it22",
    "access": null,
    "description": "formats nanosecond dates",
    "lineNumber": 30
  },
  {
    "__docId__": 270,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it23",
    "testId": 23,
    "memberof": "unit/grammar.test.js~describe16.describe21",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe21.it23",
    "access": null,
    "description": "formats millisecond dates",
    "lineNumber": 33
  },
  {
    "__docId__": 271,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe24",
    "testId": 24,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe24",
    "access": null,
    "description": "parsing",
    "lineNumber": 37
  },
  {
    "__docId__": 272,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it25",
    "testId": 25,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it25",
    "access": null,
    "description": "parses ISO dates correctly",
    "lineNumber": 38
  },
  {
    "__docId__": 273,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it26",
    "testId": 26,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it26",
    "access": null,
    "description": "parses numeric `ns` timestamps",
    "lineNumber": 44
  },
  {
    "__docId__": 274,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it27",
    "testId": 27,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it27",
    "access": null,
    "description": "parses numeric `u` timestamps",
    "lineNumber": 50
  },
  {
    "__docId__": 275,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it28",
    "testId": 28,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it28",
    "access": null,
    "description": "parses numeric `ms` timestamps",
    "lineNumber": 56
  },
  {
    "__docId__": 276,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it29",
    "testId": 29,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it29",
    "access": null,
    "description": "parses numeric `s` timestamps",
    "lineNumber": 61
  },
  {
    "__docId__": 277,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it30",
    "testId": 30,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it30",
    "access": null,
    "description": "parses numeric `m` timestamps",
    "lineNumber": 66
  },
  {
    "__docId__": 278,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it31",
    "testId": 31,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it31",
    "access": null,
    "description": "parses numeric `h` timestamps",
    "lineNumber": 71
  },
  {
    "__docId__": 279,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe32",
    "testId": 32,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe32",
    "access": null,
    "description": "timestamp casting",
    "lineNumber": 77
  },
  {
    "__docId__": 280,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it33",
    "testId": 33,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it33",
    "access": null,
    "description": "casts dates into timestamps",
    "lineNumber": 78
  },
  {
    "__docId__": 281,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it34",
    "testId": 34,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it34",
    "access": null,
    "description": "casts nanodates into timestamps",
    "lineNumber": 87
  },
  {
    "__docId__": 282,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/influx.test.js",
    "memberof": null,
    "longname": "unit/influx.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "'use strict';\nimport { InfluxDB, FieldType, toNanoDate } from '../../src';\nimport { expect, dbFixture } from \"./helpers\";\nconst sinon = require('sinon');\ndescribe('influxdb', () => {\n    describe('constructor', () => {\n        it('uses default options', () => {\n            expect((new InfluxDB()).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: null,\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '127.0.0.1',\n                        port: 8086,\n                        protocol: 'http'\n                    }]\n            });\n        });\n        it('parses dsns', () => {\n            expect((new InfluxDB('https://connor:password@192.168.0.1:1337/foo')).options).to.deep.equal({\n                username: 'connor',\n                password: 'password',\n                database: 'foo',\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 1337,\n                        protocol: 'https'\n                    }]\n            });\n        });\n        it('parses single configs', () => {\n            expect((new InfluxDB({ database: 'foo', host: '192.168.0.1' })).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: 'foo',\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 8086,\n                        protocol: 'http'\n                    }]\n            });\n        });\n        it('parses cluster configs', () => {\n            expect((new InfluxDB({ database: 'foo', hosts: [{ host: '192.168.0.1' }] })).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: 'foo',\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 8086,\n                        protocol: 'http'\n                    }]\n            });\n        });\n        it('parses parses schema', () => {\n            let client = (new InfluxDB({\n                schema: [{\n                        database: \"my_db\",\n                        measurement: \"my_measurement\",\n                        fields: {},\n                        tags: [\"my_tag\"],\n                    }],\n                hosts: [{ host: '192.168.0.1' }],\n            }));\n            expect(client.schema.my_db.my_measurement).to.be.defined;\n            client = (new InfluxDB({\n                schema: [{\n                        measurement: \"my_measurement\",\n                        fields: {},\n                        tags: [\"my_tag\"],\n                    }],\n                database: \"my_db\",\n                hosts: [{ host: '192.168.0.1' }],\n            }));\n            expect(client.schema.my_db.my_measurement).to.be.defined;\n            expect(() => {\n                new InfluxDB({\n                    schema: [{\n                            measurement: \"my_measurement\",\n                            fields: {},\n                            tags: [\"my_tag\"],\n                        }],\n                    hosts: [{ host: '192.168.0.1' }],\n                });\n            }).to.throw(/no default database is provided/);\n        });\n    });\n    describe('methods', () => {\n        let influx;\n        let pool;\n        let expectations = [];\n        beforeEach(() => {\n            influx = new InfluxDB({\n                hosts: [],\n                schema: [\n                    {\n                        database: \"my_db\",\n                        measurement: \"my_schemed_measure\",\n                        tags: [\"my_tag\"],\n                        fields: {\n                            int: FieldType.INTEGER,\n                            float: FieldType.FLOAT,\n                            string: FieldType.STRING,\n                            bool: FieldType.BOOLEAN,\n                        },\n                    },\n                ],\n            });\n            pool = influx.pool;\n            sinon.stub(pool, 'discard');\n            sinon.stub(pool, 'json');\n            sinon.stub(pool, 'text');\n        });\n        afterEach(() => {\n            while (expectations.length) {\n                expectations.pop()();\n            }\n        });\n        const setDefaultDB = (db) => {\n            influx.options.database = db;\n        };\n        const expectQuery = (method, options, httpMethod = 'POST', yields = { results: [{}] }) => {\n            if (typeof options === 'string') {\n                options = { q: options };\n            }\n            pool[method].returns(Promise.resolve(yields));\n            expectations.push(() => {\n                expect(pool[method]).to.have.been.calledWith({\n                    method: httpMethod,\n                    path: '/query',\n                    query: Object.assign({\n                        u: 'root',\n                        p: 'root'\n                    }, options)\n                });\n            });\n        };\n        const expectWrite = (body, options) => {\n            if (typeof options === 'string') {\n                options = { q: options };\n            }\n            pool.discard.returns(Promise.resolve());\n            expectations.push(() => {\n                expect(pool.discard).to.have.been.calledWith({\n                    method: 'POST',\n                    path: '/write',\n                    body,\n                    query: Object.assign({\n                        u: 'root',\n                        p: 'root'\n                    }, options)\n                });\n            });\n        };\n        it('.createDatabase()', () => {\n            expectQuery('json', 'create database \"foo\"');\n            influx.createDatabase('foo');\n            expectQuery('json', 'create database \"f\\\\\"oo\"');\n            influx.createDatabase('f\"oo');\n        });\n        it('.dropDatabase()', () => {\n            expectQuery('json', 'drop database \"foo\"');\n            influx.dropDatabase('foo');\n            expectQuery('json', 'drop database \"f\\\\\"oo\"');\n            influx.dropDatabase('f\"oo');\n        });\n        it('.getDatabaseNames()', () => {\n            expectQuery('json', 'show databases', 'GET', dbFixture('showDatabases'));\n            return influx.getDatabaseNames().then(names => {\n                expect(names).to.deep.equal(['_internal', 'influx_test_gen']);\n            });\n        });\n        it('.getMeasurements()', () => {\n            expectQuery('json', 'show measurements', 'GET', dbFixture('showMeasurements'));\n            return influx.getMeasurements().then(names => {\n                expect(names).to.deep.equal(['series_0', 'series_1', 'series_2']);\n            });\n        });\n        it('.getSeries() from all', () => {\n            expectQuery('json', 'show series', 'GET', dbFixture('showSeries'));\n            return influx.getSeries().then(names => {\n                expect(names).to.deep.equal([\n                    'series_0,my_tag=0',\n                    'series_0,my_tag=1',\n                    'series_0,my_tag=5',\n                    'series_0,my_tag=6',\n                    'series_0,my_tag=7',\n                    'series_0,my_tag=8',\n                    'series_0,my_tag=9',\n                    'series_1,my_tag=0',\n                    'series_1,my_tag=2',\n                    'series_1,my_tag=4',\n                    'series_1,my_tag=5',\n                    'series_1,my_tag=6',\n                    'series_1,my_tag=7',\n                    'series_1,my_tag=8',\n                    'series_1,my_tag=9',\n                    'series_2,my_tag=1',\n                    'series_2,my_tag=2',\n                    'series_2,my_tag=3',\n                    'series_2,my_tag=4',\n                    'series_2,my_tag=5',\n                    'series_2,my_tag=6',\n                    'series_2,my_tag=7',\n                    'series_2,my_tag=8',\n                    'series_2,my_tag=9'\n                ]);\n            });\n        });\n        it('.getSeries() from single', () => {\n            expectQuery('json', 'show series from \"series_1\"', 'GET', dbFixture('showSeriesFromOne'));\n            return influx.getSeries('series_1').then(names => {\n                expect(names).to.deep.equal([\n                    'series_1,my_tag=0',\n                    'series_1,my_tag=2',\n                    'series_1,my_tag=4',\n                    'series_1,my_tag=5',\n                    'series_1,my_tag=6',\n                    'series_1,my_tag=7',\n                    'series_1,my_tag=8',\n                    'series_1,my_tag=9'\n                ]);\n            });\n        });\n        it('.dropMeasurement()', () => {\n            expectQuery('json', 'drop measurement \"series_1\"');\n            return influx.dropMeasurement('series_1');\n        });\n        describe('.dropSeries()', () => {\n            it('drops with only from clause by string', () => {\n                expectQuery('json', 'drop series from \"series_0\"');\n                influx.dropSeries({ measurement: '\"series_0\"' });\n            });\n            it('drops with only from clause by builder', () => {\n                expectQuery('json', 'drop series from \"series_0\"');\n                influx.dropSeries({ measurement: m => m.name('series_0') });\n            });\n            it('drops with only where clause by string', () => {\n                expectQuery('json', 'drop series where \"my_tag\" = 1');\n                influx.dropSeries({ where: '\"my_tag\" = 1' });\n            });\n            it('drops with only where clause by builder', () => {\n                expectQuery('json', 'drop series where \"my_tag\" = 1');\n                influx.dropSeries({ where: e => e.tag('my_tag').equals.value(1) });\n            });\n            it('drops with both', () => {\n                expectQuery('json', 'drop series from \"series_0\" where \"my_tag\" = 1');\n                influx.dropSeries({\n                    measurement: m => m.name('series_0'),\n                    where: e => e.tag('my_tag').equals.value(1)\n                });\n            });\n        });\n        it('.getUsers()', () => {\n            expectQuery('json', 'show users', 'GET', dbFixture('showUsers'));\n            return influx.getUsers().then(names => {\n                expect(names.slice()).to.deep.equal([\n                    { user: 'john', admin: true },\n                    { user: 'steve', admin: false },\n                ]);\n            });\n        });\n        describe('.createUser()', () => {\n            it('works with admin specified == true', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\' with all privileges');\n                return influx.createUser('con\"nor', 'pa55\\'word', true);\n            });\n            it('works with admin specified == false', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\'');\n                return influx.createUser('con\"nor', 'pa55\\'word', false);\n            });\n            it('works with admin unspecified', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\'');\n                return influx.createUser('con\"nor', 'pa55\\'word');\n            });\n        });\n        describe('.grantPrivilege()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'grant READ to \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.grantPrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.grantPrivilege('con\"nor', 'READ')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery('json', 'grant READ to \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.grantPrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n        });\n        describe('.revokePrivilege()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'revoke READ from \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.revokePrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.revokePrivilege('con\"nor', 'READ')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery('json', 'revoke READ from \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.revokePrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n        });\n        it('.grantAdminPrivilege()', () => {\n            expectQuery('json', 'grant all to \"con\\\\\"nor\"');\n            return influx.grantAdminPrivilege('con\"nor');\n        });\n        it('.revokeAdminPrivilege()', () => {\n            expectQuery('json', 'revoke all from \"con\\\\\"nor\"');\n            return influx.revokeAdminPrivilege('con\"nor');\n        });\n        it('.dropUser()', () => {\n            expectQuery('json', 'drop user \"con\\\\\"nor\"');\n            return influx.dropUser('con\"nor');\n        });\n        describe('.createContinuousQuery()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\" begin foo end');\n                return influx.createContinuousQuery('my_\"q', 'foo', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.createContinuousQuery('my_\"q', 'foo')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\"_db');\n                expectQuery('json', 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\" begin foo end');\n                return influx.createContinuousQuery('my_\"q', 'foo');\n            });\n        });\n        describe('.dropContinuousQuery()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.dropContinuousQuery('my_\"q')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\"_db');\n                expectQuery('json', 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q');\n            });\n        });\n        describe('.writePoints()', () => {\n            it('writes with all options specified without a schema', () => {\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075', {\n                    precision: 's',\n                    rp: '1day',\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ], {\n                    database: 'my_db',\n                    precision: 's',\n                    retentionPolicy: '1day',\n                });\n            });\n            it('writes using default options without a schema', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it('uses a schema to coerce', () => {\n                setDefaultDB('my_db');\n                expectWrite('my_schemed_measure,my_tag=1 bool=T,float=43,int=42i', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'my_schemed_measure',\n                        tags: { my_tag: '1' },\n                        fields: {\n                            int: 42,\n                            float: 43,\n                            bool: true,\n                        }\n                    },\n                ]);\n            });\n            it('throws on schema violations', () => {\n                setDefaultDB('my_db');\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            tags: { not_a_tag: '1' },\n                        },\n                    ]);\n                }).to.throw(/extraneous tags/i);\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            fields: { not_a_field: '1' },\n                        },\n                    ]);\n                }).to.throw(/extraneous fields/i);\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            fields: { bool: 'lol, not a bool' },\n                        },\n                    ]);\n                }).to.throw(/expected bool/i);\n            });\n            it('handles lack of tags', () => {\n                expectWrite('mymeas myfield=90', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        fields: { myfield: 90 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('handles lack of fields', () => {\n                expectWrite('mymeas,my_tag=90', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: 90 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('handles multiple tags', () => {\n                expectWrite('mymeas,my_tag1=90,my_tag2=45', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag1: 90, my_tag2: 45 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('writes with the .writeMeasurement method', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it('accepts nanoseconds (as ms)', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate('1463683075000000000'),\n                    },\n                ]);\n            });\n            it('accepts nanoseconds (as ns)', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000000000', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate('1463683075000000000'),\n                    },\n                ], { precision: 'n' });\n            });\n        });\n        describe('.write methods', () => {\n            beforeEach(() => setDefaultDB('my_db'));\n            it('runs raw queries', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.queryRaw('select * from series_0').then(res => {\n                    expect(res).to.deep.equal(dbFixture('selectFromOne'));\n                });\n            });\n            it('parses query output', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query('select * from series_0').then(res => {\n                    expect(res.slice()).to.deep.equal([\n                        { time: new Date('2016-09-29T02:19:09.38Z'), my_tag: '1', my_value: 67 },\n                        { time: new Date('2016-09-29T02:19:09.379Z'), my_tag: '1', my_value: 32 },\n                    ]);\n                });\n            });\n            it('selects from multiple', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0;select * from series_1',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query(['select * from series_0', 'select * from series_1']);\n            });\n        });\n    });\n});\n"
  },
  {
    "__docId__": 283,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe35",
    "testId": 35,
    "memberof": "unit/influx.test.js",
    "testDepth": 0,
    "longname": "unit/influx.test.js~describe35",
    "access": null,
    "description": "influxdb",
    "lineNumber": 5
  },
  {
    "__docId__": 284,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe36",
    "testId": 36,
    "memberof": "unit/influx.test.js~describe35",
    "testDepth": 1,
    "longname": "unit/influx.test.js~describe35.describe36",
    "access": null,
    "description": "constructor",
    "lineNumber": 6
  },
  {
    "__docId__": 285,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it37",
    "testId": 37,
    "memberof": "unit/influx.test.js~describe35.describe36",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe36.it37",
    "access": null,
    "description": "uses default options",
    "lineNumber": 7
  },
  {
    "__docId__": 286,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it38",
    "testId": 38,
    "memberof": "unit/influx.test.js~describe35.describe36",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe36.it38",
    "access": null,
    "description": "parses dsns",
    "lineNumber": 21
  },
  {
    "__docId__": 287,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it39",
    "testId": 39,
    "memberof": "unit/influx.test.js~describe35.describe36",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe36.it39",
    "access": null,
    "description": "parses single configs",
    "lineNumber": 35
  },
  {
    "__docId__": 288,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it40",
    "testId": 40,
    "memberof": "unit/influx.test.js~describe35.describe36",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe36.it40",
    "access": null,
    "description": "parses cluster configs",
    "lineNumber": 49
  },
  {
    "__docId__": 289,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it41",
    "testId": 41,
    "memberof": "unit/influx.test.js~describe35.describe36",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe36.it41",
    "access": null,
    "description": "parses parses schema",
    "lineNumber": 62
  },
  {
    "__docId__": 290,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe42",
    "testId": 42,
    "memberof": "unit/influx.test.js~describe35",
    "testDepth": 1,
    "longname": "unit/influx.test.js~describe35.describe42",
    "access": null,
    "description": "methods",
    "lineNumber": 95
  },
  {
    "__docId__": 291,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it43",
    "testId": 43,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it43",
    "access": null,
    "description": ".createDatabase()",
    "lineNumber": 162
  },
  {
    "__docId__": 292,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it44",
    "testId": 44,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it44",
    "access": null,
    "description": ".dropDatabase()",
    "lineNumber": 168
  },
  {
    "__docId__": 293,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it45",
    "testId": 45,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it45",
    "access": null,
    "description": ".getDatabaseNames()",
    "lineNumber": 174
  },
  {
    "__docId__": 294,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it46",
    "testId": 46,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it46",
    "access": null,
    "description": ".getMeasurements()",
    "lineNumber": 180
  },
  {
    "__docId__": 295,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it47",
    "testId": 47,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it47",
    "access": null,
    "description": ".getSeries() from all",
    "lineNumber": 186
  },
  {
    "__docId__": 296,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it48",
    "testId": 48,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it48",
    "access": null,
    "description": ".getSeries() from single",
    "lineNumber": 217
  },
  {
    "__docId__": 297,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it49",
    "testId": 49,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it49",
    "access": null,
    "description": ".dropMeasurement()",
    "lineNumber": 232
  },
  {
    "__docId__": 298,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe50",
    "testId": 50,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe50",
    "access": null,
    "description": ".dropSeries()",
    "lineNumber": 236
  },
  {
    "__docId__": 299,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it51",
    "testId": 51,
    "memberof": "unit/influx.test.js~describe35.describe42.describe50",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe50.it51",
    "access": null,
    "description": "drops with only from clause by string",
    "lineNumber": 237
  },
  {
    "__docId__": 300,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it52",
    "testId": 52,
    "memberof": "unit/influx.test.js~describe35.describe42.describe50",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe50.it52",
    "access": null,
    "description": "drops with only from clause by builder",
    "lineNumber": 241
  },
  {
    "__docId__": 301,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it53",
    "testId": 53,
    "memberof": "unit/influx.test.js~describe35.describe42.describe50",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe50.it53",
    "access": null,
    "description": "drops with only where clause by string",
    "lineNumber": 245
  },
  {
    "__docId__": 302,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it54",
    "testId": 54,
    "memberof": "unit/influx.test.js~describe35.describe42.describe50",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe50.it54",
    "access": null,
    "description": "drops with only where clause by builder",
    "lineNumber": 249
  },
  {
    "__docId__": 303,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it55",
    "testId": 55,
    "memberof": "unit/influx.test.js~describe35.describe42.describe50",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe50.it55",
    "access": null,
    "description": "drops with both",
    "lineNumber": 253
  },
  {
    "__docId__": 304,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it56",
    "testId": 56,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it56",
    "access": null,
    "description": ".getUsers()",
    "lineNumber": 261
  },
  {
    "__docId__": 305,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe57",
    "testId": 57,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe57",
    "access": null,
    "description": ".createUser()",
    "lineNumber": 270
  },
  {
    "__docId__": 306,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it58",
    "testId": 58,
    "memberof": "unit/influx.test.js~describe35.describe42.describe57",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe57.it58",
    "access": null,
    "description": "works with admin specified == true",
    "lineNumber": 271
  },
  {
    "__docId__": 307,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it59",
    "testId": 59,
    "memberof": "unit/influx.test.js~describe35.describe42.describe57",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe57.it59",
    "access": null,
    "description": "works with admin specified == false",
    "lineNumber": 275
  },
  {
    "__docId__": 308,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it60",
    "testId": 60,
    "memberof": "unit/influx.test.js~describe35.describe42.describe57",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe57.it60",
    "access": null,
    "description": "works with admin unspecified",
    "lineNumber": 279
  },
  {
    "__docId__": 309,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe61",
    "testId": 61,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe61",
    "access": null,
    "description": ".grantPrivilege()",
    "lineNumber": 284
  },
  {
    "__docId__": 310,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it62",
    "testId": 62,
    "memberof": "unit/influx.test.js~describe35.describe42.describe61",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe61.it62",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 285
  },
  {
    "__docId__": 311,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it63",
    "testId": 63,
    "memberof": "unit/influx.test.js~describe35.describe42.describe61",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe61.it63",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 289
  },
  {
    "__docId__": 312,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it64",
    "testId": 64,
    "memberof": "unit/influx.test.js~describe35.describe42.describe61",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe61.it64",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 292
  },
  {
    "__docId__": 313,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe65",
    "testId": 65,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe65",
    "access": null,
    "description": ".revokePrivilege()",
    "lineNumber": 298
  },
  {
    "__docId__": 314,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it66",
    "testId": 66,
    "memberof": "unit/influx.test.js~describe35.describe42.describe65",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe65.it66",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 299
  },
  {
    "__docId__": 315,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it67",
    "testId": 67,
    "memberof": "unit/influx.test.js~describe35.describe42.describe65",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe65.it67",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 303
  },
  {
    "__docId__": 316,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it68",
    "testId": 68,
    "memberof": "unit/influx.test.js~describe35.describe42.describe65",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe65.it68",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 306
  },
  {
    "__docId__": 317,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it69",
    "testId": 69,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it69",
    "access": null,
    "description": ".grantAdminPrivilege()",
    "lineNumber": 312
  },
  {
    "__docId__": 318,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it70",
    "testId": 70,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it70",
    "access": null,
    "description": ".revokeAdminPrivilege()",
    "lineNumber": 316
  },
  {
    "__docId__": 319,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it71",
    "testId": 71,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.it71",
    "access": null,
    "description": ".dropUser()",
    "lineNumber": 320
  },
  {
    "__docId__": 320,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe72",
    "testId": 72,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe72",
    "access": null,
    "description": ".createContinuousQuery()",
    "lineNumber": 324
  },
  {
    "__docId__": 321,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it73",
    "testId": 73,
    "memberof": "unit/influx.test.js~describe35.describe42.describe72",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe72.it73",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 325
  },
  {
    "__docId__": 322,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it74",
    "testId": 74,
    "memberof": "unit/influx.test.js~describe35.describe42.describe72",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe72.it74",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 329
  },
  {
    "__docId__": 323,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it75",
    "testId": 75,
    "memberof": "unit/influx.test.js~describe35.describe42.describe72",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe72.it75",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 332
  },
  {
    "__docId__": 324,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe76",
    "testId": 76,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe76",
    "access": null,
    "description": ".dropContinuousQuery()",
    "lineNumber": 338
  },
  {
    "__docId__": 325,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it77",
    "testId": 77,
    "memberof": "unit/influx.test.js~describe35.describe42.describe76",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe76.it77",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 339
  },
  {
    "__docId__": 326,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it78",
    "testId": 78,
    "memberof": "unit/influx.test.js~describe35.describe42.describe76",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe76.it78",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 343
  },
  {
    "__docId__": 327,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it79",
    "testId": 79,
    "memberof": "unit/influx.test.js~describe35.describe42.describe76",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe76.it79",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 346
  },
  {
    "__docId__": 328,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe80",
    "testId": 80,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe80",
    "access": null,
    "description": ".writePoints()",
    "lineNumber": 352
  },
  {
    "__docId__": 329,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it81",
    "testId": 81,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it81",
    "access": null,
    "description": "writes with all options specified without a schema",
    "lineNumber": 353
  },
  {
    "__docId__": 330,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it82",
    "testId": 82,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it82",
    "access": null,
    "description": "writes using default options without a schema",
    "lineNumber": 372
  },
  {
    "__docId__": 331,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it83",
    "testId": 83,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it83",
    "access": null,
    "description": "uses a schema to coerce",
    "lineNumber": 388
  },
  {
    "__docId__": 332,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it84",
    "testId": 84,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it84",
    "access": null,
    "description": "throws on schema violations",
    "lineNumber": 407
  },
  {
    "__docId__": 333,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it85",
    "testId": 85,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it85",
    "access": null,
    "description": "handles lack of tags",
    "lineNumber": 434
  },
  {
    "__docId__": 334,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it86",
    "testId": 86,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it86",
    "access": null,
    "description": "handles lack of fields",
    "lineNumber": 447
  },
  {
    "__docId__": 335,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it87",
    "testId": 87,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it87",
    "access": null,
    "description": "handles multiple tags",
    "lineNumber": 460
  },
  {
    "__docId__": 336,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it88",
    "testId": 88,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it88",
    "access": null,
    "description": "writes with the .writeMeasurement method",
    "lineNumber": 473
  },
  {
    "__docId__": 337,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it89",
    "testId": 89,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it89",
    "access": null,
    "description": "accepts nanoseconds (as ms)",
    "lineNumber": 488
  },
  {
    "__docId__": 338,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it90",
    "testId": 90,
    "memberof": "unit/influx.test.js~describe35.describe42.describe80",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe80.it90",
    "access": null,
    "description": "accepts nanoseconds (as ns)",
    "lineNumber": 503
  },
  {
    "__docId__": 339,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe91",
    "testId": 91,
    "memberof": "unit/influx.test.js~describe35.describe42",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe35.describe42.describe91",
    "access": null,
    "description": ".write methods",
    "lineNumber": 519
  },
  {
    "__docId__": 340,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it92",
    "testId": 92,
    "memberof": "unit/influx.test.js~describe35.describe42.describe91",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe91.it92",
    "access": null,
    "description": "runs raw queries",
    "lineNumber": 521
  },
  {
    "__docId__": 341,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it93",
    "testId": 93,
    "memberof": "unit/influx.test.js~describe35.describe42.describe91",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe91.it93",
    "access": null,
    "description": "parses query output",
    "lineNumber": 532
  },
  {
    "__docId__": 342,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it94",
    "testId": 94,
    "memberof": "unit/influx.test.js~describe35.describe42.describe91",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe35.describe42.describe91.it94",
    "access": null,
    "description": "selects from multiple",
    "lineNumber": 546
  },
  {
    "__docId__": 343,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/pool.test.js",
    "memberof": null,
    "longname": "unit/pool.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from \"../../src/backoff/exponential\";\nimport { Pool, ServiceNotAvailableError, RequestError } from \"../../src/pool\";\nimport { expect } from \"./helpers\";\nimport * as http from \"http\";\nimport * as async from \"async\";\nimport * as sinon from \"sinon\";\ndescribe('pool', () => {\n    let pool;\n    let clock;\n    let servers;\n    beforeEach(done => {\n        clock = sinon.useFakeTimers();\n        pool = new Pool({\n            backoff: new ExponentialBackoff({\n                initial: 300,\n                random: 0,\n                max: 10 * 1000\n            })\n        });\n        servers = [];\n        async.times(2, (i, done) => {\n            const server = http.createServer((req, res) => server.onRequest(req, res));\n            server.listen(0, () => {\n                servers.push(server);\n                pool.addHost(`http://127.0.0.1:${server.address().port}`);\n                done(null, null);\n            });\n        }, done);\n    });\n    afterEach(done => {\n        clock.restore();\n        async.each(servers, (server, done) => server.close(() => done()), done);\n    });\n    describe('request generators', () => {\n        it('makes a text request', () => {\n            servers[0].onRequest = (req, res) => {\n                expect(req.method).to.equal('GET');\n                expect(req.url).to.equal('/foo');\n                res.writeHead(200);\n                res.end('ok');\n            };\n            return pool.text({ method: 'GET', path: '/foo' })\n                .then(data => expect(data).to.equal('ok'));\n        });\n        it('includes request query strings and bodies', () => {\n            servers[0].onRequest = (req, res) => {\n                let data = '';\n                req.on('data', chunk => {\n                    data += chunk.toString();\n                });\n                req.on('end', () => {\n                    expect(data).to.equal('asdf');\n                    expect(req.method).to.equal('POST');\n                    expect(req.url).to.equal('/bar?a=42');\n                    res.writeHead(200);\n                    res.end('ok');\n                });\n            };\n            return pool.text({\n                method: 'POST',\n                path: '/bar',\n                query: { a: 42 },\n                body: 'asdf'\n            }).then(data => expect(data).to.equal('ok'));\n        });\n        it('discards responses', () => {\n            servers[0].onRequest = (req, res) => {\n                res.writeHead(204);\n                res.end();\n            };\n            return pool.discard({ method: 'GET', path: '/' });\n        });\n        it('parses JSON responses', () => {\n            servers[0].onRequest = (req, res) => {\n                res.writeHead(200);\n                res.end('{\"foo\":42}');\n            };\n            return pool.json({ method: 'GET', path: '/' })\n                .then(data => expect(data).to.deep.equal({ foo: 42 }));\n        });\n        it('errors if JSON parsing fails', () => {\n            servers[0].onRequest = (req, res) => {\n                res.writeHead(200);\n                res.end('{');\n            };\n            return pool.json({ method: 'GET', path: '/' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => expect(err).to.be.an.instanceof(SyntaxError));\n        });\n    });\n    it('round robins requests', done => {\n        servers[0].onRequest = (req, res) => {\n            res.writeHead(204);\n            res.end();\n            let served;\n            servers[1].onRequest = (req, res) => {\n                served = true;\n                res.writeHead(204);\n                res.end();\n            };\n            pool.discard({ method: 'GET', path: '/' })\n                .then(() => expect(served).to.be.true)\n                .then(() => done())\n                .catch(done);\n        };\n        pool.discard({ method: 'GET', path: '/' });\n    });\n    it('times out requests', () => {\n        clock.restore();\n        servers.forEach(server => {\n            server.onRequest = (req, res) => {\n                setTimeout(() => {\n                    res.writeHead(204);\n                    res.end();\n                }, 100);\n            };\n        });\n        pool.timeout = 1;\n        return pool.text({ method: 'GET', path: '/' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => expect(err).be.an.instanceof(ServiceNotAvailableError));\n    });\n    it('retries on a request error', () => {\n        servers[0].onRequest = (req, res) => {\n            res.writeHead(502);\n            res.end();\n        };\n        servers[1].onRequest = (req, res) => {\n            res.writeHead(200);\n            res.end('ok now');\n        };\n        return pool.text({ method: 'GET', path: '/' })\n            .then(body => expect(body).to.equal('ok now'));\n    });\n    it('fails if too many errors happen', () => {\n        servers.forEach(server => {\n            server.onRequest = (req, res) => {\n                res.writeHead(502);\n                res.end();\n            };\n        });\n        expect(pool.hostIsAvailable()).to.be.true;\n        return pool.discard({ method: 'GET', path: '/' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => {\n            expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n            expect(pool.hostIsAvailable()).to.be.false;\n        });\n    });\n    it('calls back immediately on un-retryable error', () => {\n        servers[0].onRequest = (req, res) => {\n            res.writeHead(400);\n            res.end();\n        };\n        return pool.discard({ method: 'GET', path: '/' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => {\n            expect(err).to.be.an.instanceof(RequestError);\n            expect(err.res.statusCode).to.equal(400);\n            expect(pool.hostIsAvailable()).to.be.true;\n        });\n    });\n    it('gets enabled/disabled hosts', () => {\n        const serverPorts = servers.map(s => s.address().port);\n        expect(pool.getHostsAvailable()\n            .map((h) => Number(h.url.port)))\n            .to.deep.equal(serverPorts);\n        expect(pool.getHostsDisabled().length).to.equal(0);\n        servers[0].onRequest = (req, res) => {\n            res.writeHead(502);\n            res.end();\n        };\n        servers[1].onRequest = (req, res) => {\n            res.writeHead(200);\n            res.end('ok now');\n        };\n        return pool.discard({ method: 'GET', path: '/' }).then(() => {\n            expect(pool.getHostsAvailable().map((h) => Number(h.url.port))).to.deep.equal([serverPorts[1]]);\n            expect(pool.getHostsDisabled().map((h) => Number(h.url.port))).to.deep.equal([serverPorts[0]]);\n        });\n    });\n    describe('backoff', () => {\n        beforeEach(() => {\n            servers.forEach(server => {\n                server.onRequest = (req, res) => {\n                    res.writeHead(502);\n                    res.end();\n                };\n            });\n            return pool.discard({ method: 'GET', path: '/' }).catch(() => { });\n        });\n        it('should error if there are no available hosts', () => {\n            return pool.discard({ method: 'GET', path: '/' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                expect(err.message).to.equal('No host available');\n            });\n        });\n        it('should reenable hosts after the backoff expires', () => {\n            expect(pool.hostIsAvailable()).to.be.false;\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n        });\n        it('should back off if failures continue', () => {\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n            return pool.discard({ method: 'GET', path: '/' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n            });\n        });\n        it('should reset backoff after success', () => {\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n            servers.forEach(server => {\n                server.onRequest = (req, res) => {\n                    res.writeHead(200);\n                    res.end();\n                };\n            });\n            return pool.discard({ method: 'GET', path: '/' }).then(() => {\n                servers.forEach(server => {\n                    server.onRequest = (req, res) => {\n                        res.writeHead(502);\n                        res.end();\n                    };\n                });\n                return pool.discard({ method: 'GET', path: '/' });\n            })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).not.to.be.undefined;\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n            });\n        });\n    });\n});\n"
  },
  {
    "__docId__": 344,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe95",
    "testId": 95,
    "memberof": "unit/pool.test.js",
    "testDepth": 0,
    "longname": "unit/pool.test.js~describe95",
    "access": null,
    "description": "pool",
    "lineNumber": 7
  },
  {
    "__docId__": 345,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe96",
    "testId": 96,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.describe96",
    "access": null,
    "description": "request generators",
    "lineNumber": 34
  },
  {
    "__docId__": 346,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it97",
    "testId": 97,
    "memberof": "unit/pool.test.js~describe95.describe96",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe96.it97",
    "access": null,
    "description": "makes a text request",
    "lineNumber": 35
  },
  {
    "__docId__": 347,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it98",
    "testId": 98,
    "memberof": "unit/pool.test.js~describe95.describe96",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe96.it98",
    "access": null,
    "description": "includes request query strings and bodies",
    "lineNumber": 45
  },
  {
    "__docId__": 348,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it99",
    "testId": 99,
    "memberof": "unit/pool.test.js~describe95.describe96",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe96.it99",
    "access": null,
    "description": "discards responses",
    "lineNumber": 66
  },
  {
    "__docId__": 349,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it100",
    "testId": 100,
    "memberof": "unit/pool.test.js~describe95.describe96",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe96.it100",
    "access": null,
    "description": "parses JSON responses",
    "lineNumber": 73
  },
  {
    "__docId__": 350,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it101",
    "testId": 101,
    "memberof": "unit/pool.test.js~describe95.describe96",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe96.it101",
    "access": null,
    "description": "errors if JSON parsing fails",
    "lineNumber": 81
  },
  {
    "__docId__": 351,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it102",
    "testId": 102,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it102",
    "access": null,
    "description": "round robins requests",
    "lineNumber": 91
  },
  {
    "__docId__": 352,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it103",
    "testId": 103,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it103",
    "access": null,
    "description": "times out requests",
    "lineNumber": 108
  },
  {
    "__docId__": 353,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it104",
    "testId": 104,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it104",
    "access": null,
    "description": "retries on a request error",
    "lineNumber": 123
  },
  {
    "__docId__": 354,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it105",
    "testId": 105,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it105",
    "access": null,
    "description": "fails if too many errors happen",
    "lineNumber": 135
  },
  {
    "__docId__": 355,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it106",
    "testId": 106,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it106",
    "access": null,
    "description": "calls back immediately on un-retryable error",
    "lineNumber": 150
  },
  {
    "__docId__": 356,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it107",
    "testId": 107,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.it107",
    "access": null,
    "description": "gets enabled/disabled hosts",
    "lineNumber": 163
  },
  {
    "__docId__": 357,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe108",
    "testId": 108,
    "memberof": "unit/pool.test.js~describe95",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe95.describe108",
    "access": null,
    "description": "backoff",
    "lineNumber": 182
  },
  {
    "__docId__": 358,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it109",
    "testId": 109,
    "memberof": "unit/pool.test.js~describe95.describe108",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe108.it109",
    "access": null,
    "description": "should error if there are no available hosts",
    "lineNumber": 192
  },
  {
    "__docId__": 359,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it110",
    "testId": 110,
    "memberof": "unit/pool.test.js~describe95.describe108",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe108.it110",
    "access": null,
    "description": "should reenable hosts after the backoff expires",
    "lineNumber": 200
  },
  {
    "__docId__": 360,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it111",
    "testId": 111,
    "memberof": "unit/pool.test.js~describe95.describe108",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe108.it111",
    "access": null,
    "description": "should back off if failures continue",
    "lineNumber": 205
  },
  {
    "__docId__": 361,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it112",
    "testId": 112,
    "memberof": "unit/pool.test.js~describe95.describe108",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe95.describe108.it112",
    "access": null,
    "description": "should reset backoff after success",
    "lineNumber": 219
  },
  {
    "__docId__": 362,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/result.test.js",
    "memberof": null,
    "longname": "unit/result.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as results from \"../../src/results\";\nimport { expect } from \"./helpers\";\ndescribe('results', () => {\n    it('parses a empty result', () => {\n        expect(results.parse({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean'\n                            ],\n                            values: []\n                        }]\n                }]\n        }).slice()).to.deep.equal([]);\n    });\n    it('parses a simple table of results', () => {\n        const r = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean'\n                            ],\n                            values: [\n                                ['2016-09-25T16:12:51.787Z', 42],\n                                ['2016-09-25T16:34:31.999Z', 44]\n                            ]\n                        }]\n                }]\n        });\n        expect(r.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 }\n        ]);\n        expect(r.groups()).to.deep.equal([\n            { tags: {}, rows: r.slice() }\n        ]);\n        expect(r.group({ tag: 'a' })).to.deep.equal([]);\n    });\n    it('parses alternate epochs', () => {\n        const r1 = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean'\n                            ],\n                            values: [\n                                [1474819971787, 42],\n                                [1474821271999, 44]\n                            ]\n                        }]\n                }]\n        }, 'ms');\n        expect(r1.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 }\n        ]);\n        const r2 = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean'\n                            ],\n                            values: [\n                                [1474819971787000, 42],\n                                [1474821271999000, 44]\n                            ]\n                        }]\n                }]\n        }, 'u');\n        expect(r2.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 }\n        ]);\n    });\n    it('parses grouped results', () => {\n        const r = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            tags: { tag: 'a' },\n                            columns: [\n                                'mean'\n                            ],\n                            values: [\n                                [1],\n                                [2]\n                            ]\n                        }, {\n                            name: 'test_series',\n                            tags: { tag: 'b' },\n                            columns: [\n                                'mean'\n                            ],\n                            values: [\n                                [3],\n                                [4]\n                            ]\n                        }]\n                }]\n        });\n        expect(r.slice()).to.deep.equal([\n            { tag: 'a', mean: 1 },\n            { tag: 'a', mean: 2 },\n            { tag: 'b', mean: 3 },\n            { tag: 'b', mean: 4 }\n        ]);\n        expect(r.groups()).to.deep.equal([\n            { tags: { tag: 'a' }, rows: [{ tag: 'a', mean: 1 }, { tag: 'a', mean: 2 }] },\n            { tags: { tag: 'b' }, rows: [{ tag: 'b', mean: 3 }, { tag: 'b', mean: 4 }] }\n        ]);\n        expect(r.group({ tag: 'a' })).to.deep.equal([\n            { tag: 'a', mean: 1 },\n            { tag: 'a', mean: 2 }\n        ]);\n        expect(r.group({ tag: 'b' })).to.deep.equal([\n            { tag: 'b', mean: 3 },\n            { tag: 'b', mean: 4 }\n        ]);\n        expect(r.group({ tag: 'c' })).to.deep.equal([]);\n    });\n    it('parses empty series', () => {\n        const r1 = results.parseSingle({\n            results: [{}]\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it('parses empty values', () => {\n        const r1 = results.parseSingle({\n            results: [{\n                    series: [\n                        { columns: ['user', 'admin'] },\n                    ],\n                }],\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it('throws error on an errorful series', () => {\n        expect(() => results.parseSingle({\n            \"results\": [\n                { error: \"user already exists\" }\n            ]\n        })).to.throw(/already exists/);\n    });\n});\n"
  },
  {
    "__docId__": 363,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe113",
    "testId": 113,
    "memberof": "unit/result.test.js",
    "testDepth": 0,
    "longname": "unit/result.test.js~describe113",
    "access": null,
    "description": "results",
    "lineNumber": 3
  },
  {
    "__docId__": 364,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it114",
    "testId": 114,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it114",
    "access": null,
    "description": "parses a empty result",
    "lineNumber": 4
  },
  {
    "__docId__": 365,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it115",
    "testId": 115,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it115",
    "access": null,
    "description": "parses a simple table of results",
    "lineNumber": 18
  },
  {
    "__docId__": 366,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it116",
    "testId": 116,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it116",
    "access": null,
    "description": "parses alternate epochs",
    "lineNumber": 43
  },
  {
    "__docId__": 367,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it117",
    "testId": 117,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it117",
    "access": null,
    "description": "parses grouped results",
    "lineNumber": 83
  },
  {
    "__docId__": 368,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it118",
    "testId": 118,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it118",
    "access": null,
    "description": "parses empty series",
    "lineNumber": 129
  },
  {
    "__docId__": 369,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it119",
    "testId": 119,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it119",
    "access": null,
    "description": "parses empty values",
    "lineNumber": 135
  },
  {
    "__docId__": 370,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it120",
    "testId": 120,
    "memberof": "unit/result.test.js~describe113",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe113.it120",
    "access": null,
    "description": "throws error on an errorful series",
    "lineNumber": 145
  },
  {
    "__docId__": 371,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/schema.test.js",
    "memberof": null,
    "longname": "unit/schema.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Schema, coerceBadly } from \"../../src/schema\";\nimport { FieldType } from \"../../src/grammar\";\nimport { expect } from \"./helpers\";\ndescribe(\"schema\", () => {\n    let schema;\n    beforeEach(() => {\n        schema = new Schema({\n            database: \"my_db\",\n            measurement: \"my_measure\",\n            tags: [\"my_tag\"],\n            fields: {\n                int: FieldType.INTEGER,\n                float: FieldType.FLOAT,\n                string: FieldType.STRING,\n                bool: FieldType.BOOLEAN,\n            },\n        });\n    });\n    describe(\"coerceBadly\", () => {\n        it(\"apparently works\", () => {\n            expect(coerceBadly({\n                b: 42,\n                a: true,\n                c: \"hello\\\"world\",\n            })).to.deep.equal([\n                [\"a\", \"true\"],\n                [\"b\", \"42\"],\n                [\"c\", \"\\\"hello\\\\\\\"world\\\"\"],\n            ]);\n        });\n    });\n    describe(\"basic schema\", () => {\n        it(\"coerces data correctly\", () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: 43,\n                string: \"hello\\\"world\",\n                bool: true,\n            })).to.deep.equal([\n                [\"bool\", \"T\"],\n                [\"float\", \"43\"],\n                [\"int\", \"42i\"],\n                [\"string\", \"\\\"hello\\\\\\\"world\\\"\"],\n            ]);\n        });\n        it(\"accepts partial data\", () => {\n            expect(schema.coerceFields({\n                int: 42\n            })).to.deep.equal([\n                [\"int\", \"42i\"],\n            ]);\n        });\n        it(\"coerces numeric string data\", () => {\n            expect(schema.coerceFields({\n                int: \"42\"\n            })).to.deep.equal([\n                [\"int\", \"42i\"],\n            ]);\n        });\n        it(\"strips null and undefined values\", () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: undefined,\n                bool: null,\n            })).to.deep.equal([\n                [\"int\", \"42i\"],\n            ]);\n        });\n        it(\"throws if wrong data type provided (bool)\", () => {\n            expect(() => schema.coerceFields({ bool: 42 })).to.throw(/expected bool/i);\n            expect(() => schema.coerceFields({ bool: \"asdf\" })).to.throw(/expected bool/i);\n        });\n        it(\"throws if wrong data type provided (float)\", () => {\n            expect(() => schema.coerceFields({ float: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ float: \"asdf\" })).to.throw(/expected numeric/i);\n        });\n        it(\"throws if wrong data type provided (int)\", () => {\n            expect(() => schema.coerceFields({ int: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ int: \"asdf\" })).to.throw(/expected numeric/i);\n        });\n        it(\"allows valid tags\", () => {\n            expect(schema.checkTags({ \"my_tag\": \"value\" })).to.deep.equal([\"my_tag\"]);\n            expect(schema.checkTags({})).to.deep.equal([]);\n        });\n        it(\"throws if invalid tags are provided\", () => {\n            expect(() => schema.checkTags({ \"whatever\": \"value\" })).to.throw(/extraneous tags/i);\n        });\n        it(\"throws if invalid fields are provided\", () => {\n            expect(() => expect(schema.coerceFields({ x: 42 }))).to.throw(/extraneous fields/i);\n        });\n    });\n});\n"
  },
  {
    "__docId__": 372,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe121",
    "testId": 121,
    "memberof": "unit/schema.test.js",
    "testDepth": 0,
    "longname": "unit/schema.test.js~describe121",
    "access": null,
    "description": "schema",
    "lineNumber": 4
  },
  {
    "__docId__": 373,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe122",
    "testId": 122,
    "memberof": "unit/schema.test.js~describe121",
    "testDepth": 1,
    "longname": "unit/schema.test.js~describe121.describe122",
    "access": null,
    "description": "coerceBadly",
    "lineNumber": 19
  },
  {
    "__docId__": 374,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it123",
    "testId": 123,
    "memberof": "unit/schema.test.js~describe121.describe122",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe122.it123",
    "access": null,
    "description": "apparently works",
    "lineNumber": 20
  },
  {
    "__docId__": 375,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe124",
    "testId": 124,
    "memberof": "unit/schema.test.js~describe121",
    "testDepth": 1,
    "longname": "unit/schema.test.js~describe121.describe124",
    "access": null,
    "description": "basic schema",
    "lineNumber": 32
  },
  {
    "__docId__": 376,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it125",
    "testId": 125,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it125",
    "access": null,
    "description": "coerces data correctly",
    "lineNumber": 33
  },
  {
    "__docId__": 377,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it126",
    "testId": 126,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it126",
    "access": null,
    "description": "accepts partial data",
    "lineNumber": 46
  },
  {
    "__docId__": 378,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it127",
    "testId": 127,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it127",
    "access": null,
    "description": "coerces numeric string data",
    "lineNumber": 53
  },
  {
    "__docId__": 379,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it128",
    "testId": 128,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it128",
    "access": null,
    "description": "strips null and undefined values",
    "lineNumber": 60
  },
  {
    "__docId__": 380,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it129",
    "testId": 129,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it129",
    "access": null,
    "description": "throws if wrong data type provided (bool)",
    "lineNumber": 69
  },
  {
    "__docId__": 381,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it130",
    "testId": 130,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it130",
    "access": null,
    "description": "throws if wrong data type provided (float)",
    "lineNumber": 73
  },
  {
    "__docId__": 382,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it131",
    "testId": 131,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it131",
    "access": null,
    "description": "throws if wrong data type provided (int)",
    "lineNumber": 77
  },
  {
    "__docId__": 383,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it132",
    "testId": 132,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it132",
    "access": null,
    "description": "allows valid tags",
    "lineNumber": 81
  },
  {
    "__docId__": 384,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it133",
    "testId": 133,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it133",
    "access": null,
    "description": "throws if invalid tags are provided",
    "lineNumber": 85
  },
  {
    "__docId__": 385,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it134",
    "testId": 134,
    "memberof": "unit/schema.test.js~describe121.describe124",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe121.describe124.it134",
    "access": null,
    "description": "throws if invalid fields are provided",
    "lineNumber": 88
  }
]