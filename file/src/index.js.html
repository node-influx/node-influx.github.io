<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | node-influx</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="InfluxDB Client"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="node-influx"><meta property="twitter:description" content="InfluxDB Client"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/node-influx/node-influx.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Measurement.html">Measurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~InfluxDB.html">InfluxDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~Pool.html">Pool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~RequestError.html">RequestError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~ServiceNotAvailableError.html">ServiceNotAvailableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~ResultError.html">ResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/schema.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assertNoErrors">assertNoErrors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parse">parse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSingle">parseSingle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-coerceBadly">coerceBadly</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backoff">backoff</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/constant.js~ConstantBackoff.html">ConstantBackoff</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/exponential.js~ExponentialBackoff.html">ExponentialBackoff</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#grammar">grammar</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/grammar/ds.js~Raw.html">Raw</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-castTimestamp">castTimestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dateToTime">dateToTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatDate">formatDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isoOrTimeToDate">isoOrTimeToDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toNanoDate">toNanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-escape">escape</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Precision">Precision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint-disable @typescript-eslint/unified-signatures */
/* eslint-disable no-prototype-builtins */
import * as url from &quot;url&quot;;
import * as b from &quot;./builder&quot;;
import * as grammar from &quot;./grammar&quot;;
import { Pool } from &quot;./pool&quot;;
import { assertNoErrors, parse, parseSingle } from &quot;./results&quot;;
import { coerceBadly, Schema } from &quot;./schema&quot;;
const defaultHost = Object.freeze({
    host: &quot;127.0.0.1&quot;,
    port: 8086,
    path: &quot;&quot;,
    protocol: &quot;http&quot;,
});
const defaultOptions = Object.freeze({
    database: null,
    hosts: [],
    password: &quot;root&quot;,
    schema: [],
    username: &quot;root&quot;,
});
export * from &quot;./builder&quot;;
export { FieldType, Precision, Raw, escape, toNanoDate, } from &quot;./grammar&quot;;
export { ResultError } from &quot;./results&quot;;
/**
 * Parses the URL out into into a IClusterConfig object
 */
function parseOptionsUrl(addr) {
    const parsed = url.parse(addr);
    const options = {
        host: parsed.hostname,
        port: Number(parsed.port),
        protocol: parsed.protocol.slice(0, -1),
    };
    if (parsed.auth) {
        [options.username, options.password] = parsed.auth.split(&quot;:&quot;);
    }
    if (parsed.pathname.length &gt; 1) {
        options.database = parsed.pathname.slice(1);
    }
    return options;
}
/**
 * Works similarly to Object.assign, but only overwrites
 * properties that resolve to undefined.
 */
function defaults(target, ...srcs) {
    srcs.forEach((src) =&gt; {
        Object.keys(src).forEach((key) =&gt; {
            if (target[key] === undefined) {
                target[key] = src[key];
            }
        });
    });
    return target;
}
/**
 * InfluxDB is the public interface to run queries against your database.
 * This is a &apos;driver-level&apos; module, not a a full-fleged ORM or ODM; you run
 * queries directly by calling methods on this class.
 *
 * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)
 * if you want help getting started!
 *
 * @example
 * const Influx = require(&apos;influx&apos;);
 * const influx = new Influx.InfluxDB({
 *  host: &apos;localhost&apos;,
 *  database: &apos;express_response_db&apos;,
 *  schema: [
 *    {
 *      measurement: &apos;response_times&apos;,
 *      fields: {
 *        path: Influx.FieldType.STRING,
 *        duration: Influx.FieldType.INTEGER
 *      },
 *      tags: [
 *        &apos;host&apos;
 *      ]
 *    }
 *  ]
 * })
 *
 * @example
 * // Connect over HTTPS
 * const Influx = require(&apos;influx&apos;);
 * const influx = new Influx.InfluxDB({
 *  host: &apos;myinfluxdbhost&apos;,
 *  port: 443,
 *  protocol: &apos;https&apos;
 *  database: &apos;express_response_db&apos;,
 *  schema: [
 *    {
 *      measurement: &apos;response_times&apos;,
 *      fields: {
 *        path: Influx.FieldType.STRING,
 *        duration: Influx.FieldType.INTEGER
 *      },
 *      tags: [
 *        &apos;host&apos;
 *      ]
 *    }
 *  ]
 * })
 *
 * influx.writePoints([
 *   {
 *     measurement: &apos;response_times&apos;,
 *     tags: { host: os.hostname() },
 *     fields: { duration, path: req.path },
 *   }
 * ]).then(() =&gt; {
 *   return influx.query(`
 *     select * from response_times
 *     where host = $&lt;host&gt;
 *     order by time desc
 *     limit 10
 *   `, {
 *      placeholders: {
 *        host: os.hostname()
 *      }
 *   })
 * }).then(rows =&gt; {
 *   rows.forEach(row =&gt; console.log(`A request to ${row.path} took ${row.duration}ms`))
 * })
 */
export class InfluxDB {
    /**
     * Connect to a single InfluxDB instance by specifying
     * a set of connection options.
     * @param [options=&apos;http://root:root@127.0.0.1:8086&apos;]
     *
     * @example
     * const Influx = require(&apos;influx&apos;)
     *
     * // Connect to a single host with a DSN:
     * const influx = new Influx.InfluxDB(&apos;http://user:password@host:8086/database&apos;)
     *
     * @example
     * const Influx = require(&apos;influx&apos;)
     *
     * // Connect to a single host with a full set of config details and
     * // a custom schema
     * const client = new Influx.InfluxDB({
     *   database: &apos;my_db&apos;,
     *   host: &apos;localhost&apos;,
     *   port: 8086,
     *   username: &apos;connor&apos;,
     *   password: &apos;pa$$w0rd&apos;,
     *   schema: [
     *     {
     *       measurement: &apos;perf&apos;,
     *       fields: {
     *         memory_usage: Influx.FieldType.INTEGER,
     *         cpu_usage: Influx.FieldType.FLOAT,
     *         is_online: Influx.FieldType.BOOLEAN
     *       }
     *       tags: [
     *         &apos;hostname&apos;
     *       ]
     *     }
     *   ]
     * })
     *
     * @example
     * const Influx = require(&apos;influx&apos;)
     *
     * // Use a pool of several host connections and balance queries across them:
     * const client = new Influx.InfluxDB({
     *   database: &apos;my_db&apos;,
     *   username: &apos;connor&apos;,
     *   password: &apos;pa$$w0rd&apos;,
     *   hosts: [
     *     { host: &apos;db1.example.com&apos; },
     *     { host: &apos;db2.example.com&apos; },
     *   ],
     *   schema: [
     *     {
     *       measurement: &apos;perf&apos;,
     *       fields: {
     *         memory_usage: Influx.FieldType.INTEGER,
     *         cpu_usage: Influx.FieldType.FLOAT,
     *         is_online: Influx.FieldType.BOOLEAN
     *       }
     *       tags: [
     *         &apos;hostname&apos;
     *       ]
     *     }
     *   ]
     * })
     *
     */
    constructor(options) {
        /**
         * Map of Schema instances defining measurements in Influx.
         * @private
         */
        this._schema = Object.create(null);
        // Figure out how to parse whatever we were passed in into a IClusterConfig.
        if (typeof options === &quot;string&quot;) {
            // Plain URI =&gt; ISingleHostConfig
            options = parseOptionsUrl(options);
        }
        else if (!options) {
            options = defaultHost;
        }
        if (!options.hasOwnProperty(&quot;hosts&quot;)) {
            // ISingleHostConfig =&gt; IClusterConfig
            options = {
                database: options.database,
                hosts: [options],
                password: options.password,
                pool: options.pool,
                schema: options.schema,
                username: options.username,
            };
        }
        const resolved = options;
        resolved.hosts = resolved.hosts.map((host) =&gt; {
            return defaults({
                host: host.host,
                port: host.port,
                path: host.path,
                protocol: host.protocol,
                options: host.options,
            }, defaultHost);
        });
        this._pool = new Pool(resolved.pool);
        this._options = defaults(resolved, defaultOptions);
        resolved.hosts.forEach((host) =&gt; {
            this._pool.addHost(`${host.protocol}://${host.host}:${host.port}${host.path}`, host.options);
        });
        this._options.schema.forEach((schema) =&gt; this._createSchema(schema));
    }
    /**
     * Adds specified schema for better fields coercing.
     *
     * @param {ISchemaOptions} schema
     * @memberof InfluxDB
     */
    addSchema(schema) {
        this._createSchema(schema);
    }
    /**
     * Creates a new database with the provided name.
     * @param databaseName
     * @return
     * @example
     * influx.createDatabase(&apos;mydb&apos;)
     */
    createDatabase(databaseName) {
        return this._pool
            .json(this._getQueryOpts({
            q: `create database ${grammar.escape.quoted(databaseName)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Deletes a database with the provided name.
     * @param databaseName
     * @return
     * @example
     * influx.dropDatabase(&apos;mydb&apos;)
     */
    dropDatabase(databaseName) {
        return this._pool
            .json(this._getQueryOpts({
            q: `drop database ${grammar.escape.quoted(databaseName)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Returns array of database names. Requires cluster admin privileges.
     * @returns a list of database names
     * @example
     * influx.getDatabaseNames().then(names =&gt;
     *   console.log(&apos;My database names are: &apos; + names.join(&apos;, &apos;)));
     */
    getDatabaseNames() {
        return this._pool
            .json(this._getQueryOpts({ q: &quot;show databases&quot; }))
            .then((res) =&gt; parseSingle(res).map((r) =&gt; r.name));
    }
    /**
     * Returns array of measurements.
     * @returns a list of measurement names
     * @param [database] the database the measurement lives in, optional
     *     if a default database is provided.
     * @example
     * influx.getMeasurements().then(names =&gt;
     *   console.log(&apos;My measurement names are: &apos; + names.join(&apos;, &apos;)));
     */
    getMeasurements(database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            db: database,
            q: &quot;show measurements&quot;,
        }))
            .then((res) =&gt; parseSingle(res).map((r) =&gt; r.name));
    }
    /**
     * Returns a list of all series within the target measurement, or from the
     * entire database if a measurement isn&apos;t provided.
     * @param [options]
     * @param [options.measurement] if provided, we&apos;ll only get series
     *     from within that measurement.
     * @param [options.database] the database the series lives in,
     *     optional if a default database is provided.
     * @returns a list of series names
     * @example
     * influx.getSeries().then(names =&gt; {
     *   console.log(&apos;My series names in my_measurement are: &apos; + names.join(&apos;, &apos;))
     * })
     *
     * influx.getSeries({
     *   measurement: &apos;my_measurement&apos;,
     *   database: &apos;my_db&apos;
     * }).then(names =&gt; {
     *   console.log(&apos;My series names in my_measurement are: &apos; + names.join(&apos;, &apos;))
     * })
     */
    getSeries(options = {}) {
        const { database = this._defaultDB(), measurement } = options;
        let query = &quot;show series&quot;;
        if (measurement) {
            query += ` from ${grammar.escape.quoted(measurement)}`;
        }
        return this._pool
            .json(this._getQueryOpts({
            db: database,
            q: query,
        }))
            .then((res) =&gt; parseSingle(res).map((r) =&gt; r.key));
    }
    /**
     * Removes a measurement from the database.
     * @param measurement
     * @param [database] the database the measurement lives in, optional
     *     if a default database is provided.
     * @return
     * @example
     * influx.dropMeasurement(&apos;my_measurement&apos;)
     */
    dropMeasurement(measurement, database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            db: database,
            q: `drop measurement ${grammar.escape.quoted(measurement)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Removes a one or more series from InfluxDB.
     *
     * @returns
     * @example
     * // The following pairs of queries are equivalent: you can chose either to
     * // use our builder or pass in string directly. The builder takes care
     * // of escaping and most syntax handling for you.
     *
     * influx.dropSeries({ where: e =&gt; e.tag(&apos;cpu&apos;).equals.value(&apos;cpu8&apos;) })
     * influx.dropSeries({ where: &apos;&quot;cpu&quot; = \&apos;cpu8\&apos;&apos; })
     * // DROP SERIES WHERE &quot;cpu&quot; = &apos;cpu8&apos;
     *
     * influx.dropSeries({ measurement: m =&gt; m.name(&apos;cpu&apos;).policy(&apos;autogen&apos;) })
     * influx.dropSeries({ measurement: &apos;&quot;cpu&quot;.&quot;autogen&quot;&apos; })
     * // DROP SERIES FROM &quot;autogen&quot;.&quot;cpu&quot;
     *
     * influx.dropSeries({
     *   measurement: m =&gt; m.name(&apos;cpu&apos;).policy(&apos;autogen&apos;),
     *   where: e =&gt; e.tag(&apos;cpu&apos;).equals.value(&apos;cpu8&apos;),
     *   database: &apos;my_db&apos;
     * })
     * // DROP SERIES FROM &quot;autogen&quot;.&quot;cpu&quot; WHERE &quot;cpu&quot; = &apos;cpu8&apos;
     */
    dropSeries(options) {
        const db = &quot;database&quot; in options ? options.database : this._defaultDB();
        let q = &quot;drop series&quot;;
        if (&quot;measurement&quot; in options) {
            q += &quot; from &quot; + b.parseMeasurement(options);
        }
        if (&quot;where&quot; in options) {
            q += &quot; where &quot; + b.parseWhere(options);
        }
        return this._pool
            .json(this._getQueryOpts({ db, q }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Returns a list of users on the Influx database.
     * @return
     * @example
     * influx.getUsers().then(users =&gt; {
     *   users.forEach(user =&gt; {
     *     if (user.admin) {
     *       console.log(user.user, &apos;is an admin!&apos;)
     *     } else {
     *       console.log(user.user, &apos;is not an admin!&apos;)
     *     }
     *   })
     * })
     */
    getUsers() {
        return this._pool
            .json(this._getQueryOpts({ q: &quot;show users&quot; }))
            .then((result) =&gt; parseSingle(result));
    }
    /**
     * Creates a new InfluxDB user.
     * @param username
     * @param password
     * @param [admin=false] If true, the user will be given all
     *     privileges on all databases.
     * @return
     * @example
     * influx.createUser(&apos;connor&apos;, &apos;pa55w0rd&apos;, true) // make &apos;connor&apos; an admin
     *
     * // make non-admins:
     * influx.createUser(&apos;not_admin&apos;, &apos;pa55w0rd&apos;)
     */
    createUser(username, password, admin = false) {
        return this._pool
            .json(this._getQueryOpts({
            q: `create user ${grammar.escape.quoted(username)} with password ` +
                grammar.escape.stringLit(password) +
                (admin ? &quot; with all privileges&quot; : &quot;&quot;),
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Sets a password for an Influx user.
     * @param username
     * @param password
     * @return
     * @example
     * influx.setPassword(&apos;connor&apos;, &apos;pa55w0rd&apos;)
     */
    setPassword(username, password) {
        return this._pool
            .json(this._getQueryOpts({
            q: `set password for ${grammar.escape.quoted(username)} = ` +
                grammar.escape.stringLit(password),
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Grants a privilege to a specified user.
     * @param username
     * @param privilege Should be one of &apos;READ&apos; or &apos;WRITE&apos;
     * @param [database] If not provided, uses the default database.
     * @return
     * @example
     * influx.grantPrivilege(&apos;connor&apos;, &apos;READ&apos;, &apos;my_db&apos;) // grants read access on my_db to connor
     */
    grantPrivilege(username, privilege, database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: `grant ${privilege} on ${grammar.escape.quoted(database)} ` +
                `to ${grammar.escape.quoted(username)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Removes a privilege from a specified user.
     * @param username
     * @param privilege Should be one of &apos;READ&apos; or &apos;WRITE&apos;
     * @param [database] If not provided, uses the default database.
     * @return
     * @example
     * influx.revokePrivilege(&apos;connor&apos;, &apos;READ&apos;, &apos;my_db&apos;) // removes read access on my_db from connor
     */
    revokePrivilege(username, privilege, database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: `revoke ${privilege} on ${grammar.escape.quoted(database)} from ` + grammar.escape.quoted(username),
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Grants admin privileges to a specified user.
     * @param username
     * @return
     * @example
     * influx.grantAdminPrivilege(&apos;connor&apos;)
     */
    grantAdminPrivilege(username) {
        return this._pool
            .json(this._getQueryOpts({
            q: `grant all to ${grammar.escape.quoted(username)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Removes a admin privilege from a specified user.
     * @param username
     * @return
     * @example
     * influx.revokeAdminPrivilege(&apos;connor&apos;)
     */
    revokeAdminPrivilege(username) {
        return this._pool
            .json(this._getQueryOpts({
            q: `revoke all from ${grammar.escape.quoted(username)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Removes a user from the database.
     * @param username
     * @return
     * @example
     * influx.dropUser(&apos;connor&apos;)
     */
    dropUser(username) {
        return this._pool
            .json(this._getQueryOpts({
            q: `drop user ${grammar.escape.quoted(username)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Creates a continuous query in a database
     * @param name The query name, for later reference
     * @param query The body of the query to run
     * @param [database] If not provided, uses the default database.
     * @param [resample] If provided, adds resample policy
     * @return
     * @example
     * influx.createContinuousQuery(&apos;downsample_cpu_1h&apos;, `
     *   SELECT MEAN(cpu) INTO &quot;7d&quot;.&quot;perf&quot;
     *   FROM &quot;1d&quot;.&quot;perf&quot; GROUP BY time(1m)
     * `, undefined, &apos;RESAMPLE FOR 7m&apos;)
     */
    createContinuousQuery(name, query, database = this._defaultDB(), resample = &quot;&quot;) {
        return this._pool
            .json(this._getQueryOpts({
            q: `create continuous query ${grammar.escape.quoted(name)}` +
                ` on ${grammar.escape.quoted(database)} ${resample} begin ${query} end`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Returns a list of continous queries in the database.
     * @param [database] If not provided, uses the default database.
     * @return
     * @example
     * influx.showContinousQueries()
     */
    showContinousQueries(database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            db: database,
            q: &quot;show continuous queries&quot;,
        }))
            .then((result) =&gt; parseSingle(result));
    }
    /**
     * Creates a continuous query in a database
     * @param name The query name
     * @param [database] If not provided, uses the default database.
     * @return
     * @example
     * influx.dropContinuousQuery(&apos;downsample_cpu_1h&apos;)
     */
    dropContinuousQuery(name, database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: `drop continuous query ${grammar.escape.quoted(name)}` +
                ` on ${grammar.escape.quoted(database)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Creates a new retention policy on a database. You can read more about
     * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/
     * guides/downsampling_and_retention/) on the InfluxDB website.
     *
     * @param name The retention policy name
     * @param options
     * @param [options.database] Database to create the policy on,
     *     uses the default database if not provided.
     * @param options.duration How long data in the retention policy
     *     should be stored for, should be in a format like `7d`. See details
     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)
     * @param options.replication How many servers data in the series
     *     should be replicated to.
     * @param [options.isDefault] Whether the retention policy should
     *     be the default policy on the database.
     * @return
     * @example
     * influx.createRetentionPolicy(&apos;7d&apos;, {
     *  duration: &apos;7d&apos;,
     *  replication: 1
     * })
     */
    createRetentionPolicy(name, options) {
        const q = `create retention policy ${grammar.escape.quoted(name)} on ` +
            grammar.escape.quoted(options.database || this._defaultDB()) +
            ` duration ${options.duration} replication ${options.replication}` +
            (options.isDefault ? &quot; default&quot; : &quot;&quot;);
        return this._pool
            .json(this._getQueryOpts({ q }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Alters an existing retention policy on a database.
     *
     * @param name The retention policy name
     * @param options
     * @param [options.database] Database to create the policy on,
     *     uses the default database if not provided.
     * @param options.duration How long data in the retention policy
     *     should be stored for, should be in a format like `7d`. See details
     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)
     * @param options.replication How many servers data in the series
     *     should be replicated to.
     * @param [options.default] Whether the retention policy should
     *     be the default policy on the database.
     * @return
     * @example
     * influx.alterRetentionPolicy(&apos;7d&apos;, {
     *  duration: &apos;7d&apos;,
     *  replication: 1,
     *  default: true
     * })
     */
    alterRetentionPolicy(name, options) {
        const q = `alter retention policy ${grammar.escape.quoted(name)} on ` +
            grammar.escape.quoted(options.database || this._defaultDB()) +
            ` duration ${options.duration} replication ${options.replication}` +
            (options.isDefault ? &quot; default&quot; : &quot;&quot;);
        return this._pool
            .json(this._getQueryOpts({ q }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Deletes a retention policy and associated data. Note that the data will
     * not be immediately destroyed, and will hang around until Influx&apos;s
     * bi-hourly cron.
     *
     * @param name The retention policy name
     * @param [database] Database name that the policy lives in,
     *     uses the default database if not provided.
     * @return
     * @example
     * influx.dropRetentionPolicy(&apos;7d&apos;)
     */
    dropRetentionPolicy(name, database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: `drop retention policy ${grammar.escape.quoted(name)} ` +
                `on ${grammar.escape.quoted(database)}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * Shows retention policies on the database
     *
     * @param [database] The database to list policies on, uses the
     *     default database if not provided.
     * @return
     * @example
     * influx.showRetentionPolicies().then(policies =&gt; {
     *   expect(policies.slice()).to.deep.equal([
     *     {
     *       name: &apos;autogen&apos;,
     *       duration: &apos;0s&apos;,
     *       shardGroupDuration: &apos;168h0m0s&apos;,
     *       replicaN: 1,
     *       default: true,
     *     },
     *     {
     *       name: &apos;7d&apos;,
     *       duration: &apos;168h0m0s&apos;,
     *       shardGroupDuration: &apos;24h0m0s&apos;,
     *       replicaN: 1,
     *       default: false,
     *     },
     *   ])
     * })
     */
    showRetentionPolicies(database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: `show retention policies on ${grammar.escape.quoted(database)}`,
        }, &quot;GET&quot;))
            .then((result) =&gt; parseSingle(result));
    }
    /**
     * Shows shards on the database
     *
     * @param [database] The database to list policies on, uses the
     *     default database if not provided.
     * @return
     * @example
     * influx.showShards().then(shards =&gt; {
     *   expect(shards.slice()).to.deep.equal([
     *     {
     *		id: 1
     *		database: &apos;database&apos;,
     *		retention_policy: &apos;autogen&apos;,
     *		shard_group: 1,
     *		start_time: &apos;2019-05-06T00:00:00Z&apos;,
     *		end_time: &apos;2019-05-13T00:00:00Z&apos;,
     *		expiry_time: &apos;2019-05-13T00:00:00Z&apos;,
     *		owners: null,
     *     },
     *   ])
     * })
     */
    showShards(database = this._defaultDB()) {
        return this._pool
            .json(this._getQueryOpts({
            q: &quot;show shards &quot;,
        }, &quot;GET&quot;))
            .then((result) =&gt; parseSingle(result).filter(function (i) {
            return i.database === database;
        }));
    }
    /**
     * Drops a shard with the provided number.
     * @param shard_id
     * @return
     * @example
     * influx.dropShard(3)
     */
    dropShard(shard_id) {
        return this._pool
            .json(this._getQueryOpts({
            q: `drop shard ${shard_id}`,
        }, &quot;POST&quot;))
            .then(assertNoErrors)
            .then(() =&gt; undefined);
    }
    /**
     * WritePoints sends a list of points together in a batch to InfluxDB. In
     * each point you must specify the measurement name to write into as well
     * as a list of tag and field values. Optionally, you can specify the
     * time to tag that point at, defaulting to the current time.
     *
     * If you defined a schema for the measurement in the options you passed
     * to `new Influx(options)`, we&apos;ll use that to make sure that types get
     * cast correctly and that there are no extraneous fields or columns.
     *
     * For best performance, it&apos;s recommended that you batch your data into
     * sets of a couple thousand records before writing it. In the future we&apos;ll
     * have some utilities within node-influx to make this easier.
     *
     * ---
     *
     * A note when using manually-specified times and precisions: by default
     * we write using the `ms` precision since that&apos;s what JavaScript gives us.
     * You can adjust this. However, there is some special behaviour if you
     * manually specify a timestamp in your points:
     *  - if you specify the timestamp as a Date object, we&apos;ll convert it to
     *    milliseconds and manipulate it as needed to get the right precision
     *  - if provide a INanoDate as returned from {@link toNanoTime} or the
     *    results from an Influx query, we&apos;ll be able to pull the precise
     *    nanosecond timestamp and manipulate it to get the right precision
     *  - if you provide a string or number as the timestamp, we&apos;ll pass it
     *    straight into Influx.
     *
     * Please see the IPoint and IWriteOptions types for a
     * full list of possible options.
     *
     * @param points
     * @param [options]
     * @return
     * @example
     * // write a point into the default database with
     * // the default retention policy.
     * influx.writePoints([
     *   {
     *     measurement: &apos;perf&apos;,
     *     tags: { host: &apos;box1.example.com&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },
     *   }
     * ])
     *
     * // you can manually specify the database,
     * // retention policy, and time precision:
     * influx.writePoints([
     *   {
     *     measurement: &apos;perf&apos;,
     *     tags: { host: &apos;box1.example.com&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },
     *     timestamp: getLastRecordedTime(),
     *   }
     * ], {
     *   database: &apos;my_db&apos;,
     *   retentionPolicy: &apos;1d&apos;,
     *   precision: &apos;s&apos;
     * })
     */
    writePoints(points, options = {}) {
        const { database = this._defaultDB(), precision = &quot;n&quot;, retentionPolicy, } = options;
        let payload = &quot;&quot;;
        points.forEach((point) =&gt; {
            const { measurement, tags, fieldsPairs, tagsNames, castedTimestamp } = this.parsePoint(point, { database, precision });
            payload += (payload.length &gt; 0 ? &quot;\n&quot; : &quot;&quot;) + measurement;
            for (let tagsName of tagsNames) {
                payload +=
                    &quot;,&quot; +
                        grammar.escape.tag(tagsName) +
                        &quot;=&quot; +
                        grammar.escape.tag(tags[tagsName]);
            }
            for (let i = 0; i &lt; fieldsPairs.length; i += 1) {
                payload +=
                    (i === 0 ? &quot; &quot; : &quot;,&quot;) +
                        grammar.escape.tag(fieldsPairs[i][0]) +
                        &quot;=&quot; +
                        fieldsPairs[i][1];
            }
            if (castedTimestamp !== undefined) {
                payload += &quot; &quot; + castedTimestamp;
            }
        });
        return this._pool.discard({
            body: payload,
            method: &quot;POST&quot;,
            path: &quot;/write&quot;,
            query: {
                db: database,
                p: this._options.password,
                precision,
                rp: retentionPolicy,
                u: this._options.username,
            },
        });
    }
    /**
     * ParsePoint will perform the coercions/schema checks and return the data
     * required for writing a point. This will throw an error if a schema check
     * or coercion fails. This can be useful for flagging or &quot;throwing out&quot; bad
     * points in a batch write to prevent the entire batch from getting aborted
     *
     * ---
     *
     * A note when using this function, {@link InfluxDB#writePoints} will still perform
     * the same checks, so any pre-processed data will be checked for validity twice which
     * has potential performance implications on large data sets
     *
     * @param point
     * @param [options]
     * @return
     * @example
     * // parse a point as if it is getting written to the default
     * // databse with the default time precision
     * influx.parsePoint({
     *     measurement: &apos;perf&apos;,
     *     tags: { host: &apos;box1.example.com&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },
     * })
     *
     * // you can manually specify the database and time precision
     * influx.parsePoint({
     *     measurement: &apos;perf&apos;,
     *     tags: { host: &apos;box1.example.com&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },
     * }, {
     *   precision: &apos;s&apos;,
     *   database: &apos;my_db&apos;
     * })
     *
     * // if an error occurs, you can catch the error with try...catch
     * try {
     *   influx.parsePoint({
     *     measurement: &apos;perf&apos;,
     *     tags: { host: &apos;box1.example.com&apos;, myExtraneousTag: &apos;value&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage(), myExtraneousField: &apos;value&apos; },
     *   })
     * } catch(err) {
     *   handleError(err);
     * }
     */
    parsePoint(point, options = {}) {
        const { database = this._defaultDB(), precision = &quot;n&quot; } = options;
        const { fields = {}, tags = {}, measurement, timestamp } = point;
        const schema = this._schema[database] &amp;&amp; this._schema[database][measurement];
        const fieldsPairs = schema
            ? schema.coerceFields(fields)
            : coerceBadly(fields);
        const tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);
        const castedTimestamp = timestamp &amp;&amp; grammar.castTimestamp(timestamp, precision);
        return {
            fields,
            tags,
            measurement,
            timestamp,
            fieldsPairs,
            tagsNames,
            castedTimestamp,
        };
    }
    /**
     * WriteMeasurement functions similarly to {@link InfluxDB#writePoints}, but
     * it automatically fills in the `measurement` value for all points for you.
     *
     * @param measurement
     * @param points
     * @param [options]
     * @return
     * @example
     * influx.writeMeasurement(&apos;perf&apos;, [
     *   {
     *     tags: { host: &apos;box1.example.com&apos; },
     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },
     *   }
     * ])
     */
    writeMeasurement(measurement, points, options = {}) {
        points = points.map((p) =&gt; (Object.assign({ measurement }, p)));
        return this.writePoints(points, options);
    }
    /**
     * .query() runs a query (or list of queries), and returns the results in a
     * friendly format, {@link IResults}. If you run multiple queries, an array of results
     * will be returned, otherwise a single result (array of objects) will be returned.
     *
     * @param query
     * @param [options]
     * @return result(s)
     * @example
     * influx.query(&apos;select * from perf&apos;).then(results =&gt; {
     *   console.log(results)
     * })
     */
    query(query, options = {}) {
        if (Array.isArray(query)) {
            query = query.join(&quot;;&quot;);
        }
        // If the consumer asked explicitly for nanosecond precision parsing,
        // remove that to cause Influx to give us ISO dates that
        // we can parse correctly.
        if (options.precision === &quot;n&quot;) {
            options = Object.assign({}, options); // Avoid mutating
            delete options.precision;
        }
        return this.queryRaw(query, options).then((res) =&gt; parse(res, options.precision));
    }
    /**
     * QueryRaw functions similarly to .query() but it does no fancy
     * transformations on the returned data; it calls `JSON.parse` and returns
     * those results verbatim.
     *
     * @param query
     * @param [options]
     * @return
     * @example
     * influx.queryRaw(&apos;select * from perf&apos;).then(rawData =&gt; {
     *   console.log(rawData)
     * })
     */
    queryRaw(query, options = {}) {
        const { database = this._defaultDB(), retentionPolicy, placeholders = {}, } = options;
        if (query instanceof Array) {
            query = query.join(&quot;;&quot;);
        }
        return this._pool.json(this._getQueryOpts({
            db: database,
            epoch: options.precision,
            q: query,
            rp: retentionPolicy,
            params: JSON.stringify(placeholders),
        }));
    }
    /**
     * Pings all available hosts, collecting online status and version info.
     * @param timeout Given in milliseconds
     * @return
     * @example
     * influx.ping(5000).then(hosts =&gt; {
     *   hosts.forEach(host =&gt; {
     *     if (host.online) {
     *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)
     *     } else {
     *       console.log(`${host.url.host} is offline :(`)
     *     }
     *   })
     * })
     */
    ping(timeout) {
        let auth = undefined;
        if (typeof this._options.username === &quot;string&quot;) {
            auth = `${this._options.username}:${this._options.password || &quot;&quot;}`;
        }
        return this._pool.ping(timeout, &quot;/ping&quot;, auth);
    }
    /**
     * Returns the default database that queries operates on. It throws if called
     * when a default database isn&apos;t set.
     * @private
     */
    _defaultDB() {
        if (!this._options.database) {
            throw new Error(&quot;Attempted to run an influx query without a default&quot; +
                &quot; database specified or an explicit database provided.&quot;);
        }
        return this._options.database;
    }
    /**
     * Creates options to be passed into the pool to query databases.
     * @private
     */
    _getQueryOpts(params, method = &quot;GET&quot;) {
        return {
            method,
            path: &quot;/query&quot;,
            query: Object.assign({ p: this._options.password, u: this._options.username }, params),
        };
    }
    /**
     * Creates specified measurement schema
     *
     * @private
     * @param {ISchemaOptions} schema
     * @memberof InfluxDB
     */
    _createSchema(schema) {
        schema.database = schema.database || this._options.database;
        if (!schema.database) {
            throw new Error(`Schema ${schema.measurement} doesn&apos;t have a database specified,` +
                &quot;and no default database is provided!&quot;);
        }
        if (!this._schema[schema.database]) {
            this._schema[schema.database] = Object.create(null);
        }
        this._schema[schema.database][schema.measurement] = new Schema(schema);
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
