[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/backoff/backoff.js",
    "content": "export {};\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/backoff/backoff.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "file",
    "name": "src/backoff/constant.js",
    "content": "/**\n * Constant Backoff\n */\nexport class ConstantBackoff {\n    /**\n     * Creates a new constant backoff strategy.\n     * @param options\n     */\n    constructor(options) {\n        this.options = {\n            delay: Math.max(options.delay, 0),\n            jitter: Math.min(Math.max(options.jitter || 0, 0), 1),\n        };\n    }\n    /**\n     * @inheritDoc\n     */\n    getDelay() {\n        let delay = this.options.delay;\n        if (this.options.jitter > 0) {\n            const min = delay * (1 - this.options.jitter);\n            const max = delay * (1 + this.options.jitter);\n            delay = Math.random() * (max - min) + min;\n        }\n        return delay;\n    }\n    /**\n     * @inheritDoc\n     */\n    next() {\n        return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    reset() {\n        return this;\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/backoff/constant.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 50,
    "kind": "class",
    "name": "ConstantBackoff",
    "memberof": "src/backoff/constant.js",
    "static": true,
    "longname": "src/backoff/constant.js~ConstantBackoff",
    "access": "public",
    "export": true,
    "importPath": "influx/src/backoff/constant.js",
    "importStyle": "{ConstantBackoff}",
    "description": "Constant Backoff",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 51,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backoff/constant.js~ConstantBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/constant.js~ConstantBackoff#constructor",
    "access": "public",
    "description": "Creates a new constant backoff strategy.",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "options",
    "memberof": "src/backoff/constant.js~ConstantBackoff",
    "static": false,
    "longname": "src/backoff/constant.js~ConstantBackoff#options",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "{\"delay\": *, \"jitter\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "getDelay",
    "memberof": "src/backoff/constant.js~ConstantBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/constant.js~ConstantBackoff#getDelay",
    "access": "public",
    "description": "",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "next",
    "memberof": "src/backoff/constant.js~ConstantBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/constant.js~ConstantBackoff#next",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "reset",
    "memberof": "src/backoff/constant.js~ConstantBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/constant.js~ConstantBackoff#reset",
    "access": "public",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/backoff/exponential.js",
    "content": "/**\n * Exponential Backoff\n * @see https://en.wikipedia.org/wiki/Exponential_backoff\n */\nexport class ExponentialBackoff {\n    /**\n     * Creates a new exponential backoff strategy.\n     * @see https://en.wikipedia.org/wiki/Exponential_backoff\n     * @param options\n     */\n    constructor(options) {\n        this.options = options;\n        this._counter = 0;\n    }\n    /**\n     * @inheritDoc\n     */\n    getDelay() {\n        const count = this._counter - Math.round(Math.random() * this.options.random); // Tslint:disable-line\n        return Math.min(this.options.max, this.options.initial * Math.pow(2, Math.max(count, 0)));\n    }\n    /**\n     * @inheritDoc\n     */\n    next() {\n        const next = new ExponentialBackoff(this.options);\n        next._counter = this._counter + 1;\n        return next;\n    }\n    /**\n     * @inheritDoc\n     */\n    reset() {\n        return new ExponentialBackoff(this.options);\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/backoff/exponential.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "ExponentialBackoff",
    "memberof": "src/backoff/exponential.js",
    "static": true,
    "longname": "src/backoff/exponential.js~ExponentialBackoff",
    "access": "public",
    "export": true,
    "importPath": "influx/src/backoff/exponential.js",
    "importStyle": "{ExponentialBackoff}",
    "description": "Exponential Backoff",
    "see": [
      "https://en.wikipedia.org/wiki/Exponential_backoff"
    ],
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 58,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#constructor",
    "access": "public",
    "description": "Creates a new exponential backoff strategy.",
    "see": [
      "https://en.wikipedia.org/wiki/Exponential_backoff"
    ],
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "options",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#options",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "_counter",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#_counter",
    "access": "private",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "getDelay",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#getDelay",
    "access": "public",
    "description": "",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "next",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#next",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "reset",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backoff/exponential.js~ExponentialBackoff#reset",
    "access": "public",
    "description": "",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/builder.js",
    "content": "import { escape, formatDate } from \"./grammar\";\nfunction regexHasFlags(re) {\n    if (typeof re.flags !== \"undefined\") {\n        return re.flags.length > 0;\n    }\n    return !re.toString().endsWith(\"/\");\n}\n/**\n * Expression is used to build filtering expressions, like those used in WHERE\n * clauses. It can be used for fluent and safe building of queries using\n * untrusted input.\n *\n * @example\n * e => e\n *   .field('host').equals.value('ares.peet.io')\n *   .or\n *   .field('host').matches(/example\\.com$/)\n *   .or\n *   .expr(e => e\n *     .field('country').equals.value('US')\n *     .and\n *     .field('state').equals.value('WA'));\n *\n * // Generates:\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\n */\nexport class Expression {\n    constructor() {\n        this._query = [];\n    }\n    /**\n     * Inserts a tag reference into the expression; the name will be\n     * automatically escaped.\n     * @param name\n     * @return\n     */\n    tag(name) {\n        this.field(name);\n        return this;\n    }\n    /**\n     * Inserts a field reference into the expression; the name will be\n     * automatically escaped.\n     * @param name\n     * @return\n     */\n    field(name) {\n        this._query.push(escape.quoted(name));\n        return this;\n    }\n    /**\n     * Inserts a subexpression; invokes the function with a new expression\n     * that can be chained on.\n     * @param fn\n     * @return\n     * @example\n     * e.field('a').equals.value('b')\n     *   .or.expr(e =>\n     *     e.field('b').equals.value('b')\n     *     .and.field('a').equals.value('c'))\n     *   .toString()\n     * // \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')\n     */\n    exp(fn) {\n        this._query.push(\"(\" + fn(new Expression()).toString() + \")\");\n        return this;\n    }\n    /**\n     * Value chains on a value to the expression.\n     *\n     *  - Numbers will be inserted verbatim\n     *  - Strings will be escaped and inserted\n     *  - Booleans will be inserted correctly\n     *  - Dates will be formatted and inserted correctly, including INanoDates.\n     *  - Regular expressions will be inserted correctly, however an error will\n     *    be thrown if they contain flags, as regex flags do not work in Influx\n     *  - Otherwise we'll try to call `.toString()` on the value, throwing\n     *    if we cannot do so.\n     *\n     * @param value\n     * @return\n     */\n    value(value) {\n        switch (typeof value) {\n            case \"number\":\n                this._query.push(value.toString());\n                return this;\n            case \"string\":\n                this._query.push(escape.stringLit(value));\n                return this;\n            case \"boolean\":\n                this._query.push(value ? \"TRUE\" : \"FALSE\");\n                return this;\n            default:\n                if (value instanceof Date) {\n                    this._query.push(formatDate(value));\n                    return this;\n                }\n                if (value instanceof RegExp) {\n                    if (regexHasFlags(value)) {\n                        throw new Error(\"Attempted to query using a regex with flags, \" +\n                            \"but Influx doesn't support flags in queries.\");\n                    }\n                    this._query.push(\"/\" + value.source + \"/\");\n                    return this;\n                }\n                if (value && typeof value.toString === \"function\") {\n                    this._query.push(value.toString());\n                    return this;\n                }\n                throw new Error(\"node-influx doesn't know how to encode the provided value into a \" +\n                    \"query. If you think this is a bug, open an issue here: https://git.io/influx-err\");\n        }\n    }\n    /**\n     * Chains on an AND clause to the expression.\n     */\n    get and() {\n        this._query.push(\"AND\");\n        return this;\n    }\n    /**\n     * Chains on an OR clause to the expression.\n     */\n    get or() {\n        this._query.push(\"OR\");\n        return this;\n    }\n    /**\n     * Chains on a `+` operator to the expression.\n     */\n    get plus() {\n        this._query.push(\"+\");\n        return this;\n    }\n    /**\n     * Chains on a `*` operator to the expression.\n     */\n    get times() {\n        this._query.push(\"*\");\n        return this;\n    }\n    /**\n     * Chains on a `-` operator to the expression.\n     */\n    get minus() {\n        this._query.push(\"-\");\n        return this;\n    }\n    /**\n     * Chains on a `/` operator to the expression.\n     */\n    get div() {\n        this._query.push(\"/\");\n        return this;\n    }\n    /**\n     * Chains on a `=` conditional to the expression.\n     */\n    get equals() {\n        this._query.push(\"=\");\n        return this;\n    }\n    /**\n     * Chains on a `=~` conditional to the expression to match regexes.\n     */\n    get matches() {\n        this._query.push(\"=~\");\n        return this;\n    }\n    /**\n     * Chains on a `!`` conditional to the expression to match regexes.\n     */\n    get doesntMatch() {\n        this._query.push(\"!~\");\n        return this;\n    }\n    /**\n     * Chains on a `!=` conditional to the expression.\n     */\n    get notEqual() {\n        this._query.push(\"!=\");\n        return this;\n    }\n    /**\n     * Chains on a `>` conditional to the expression.\n     */\n    get gt() {\n        this._query.push(\">\");\n        return this;\n    }\n    /**\n     * Chains on a `>=` conditional to the expression.\n     */\n    get gte() {\n        this._query.push(\">=\");\n        return this;\n    }\n    /**\n     * Chains on a `<` conditional to the expression.\n     */\n    get lt() {\n        this._query.push(\"<\");\n        return this;\n    }\n    /**\n     * Chains on a `<=` conditional to the expression.\n     */\n    get lte() {\n        this._query.push(\"<=\");\n        return this;\n    }\n    /**\n     * Converts the expression into its InfluxQL representation.\n     * @return\n     */\n    toString() {\n        return this._query.join(\" \");\n    }\n}\n/**\n * Measurement creates a reference to a particular measurement. You can\n * reference it solely by its name, but you can also specify the retention\n * policy and database it lives under.\n *\n * @example\n * m.name('my_measurement') // \"my_measurement\"\n * m.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\n * m.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".\"one_day\".\"my_measurement\"\n */\nexport class Measurement {\n    constructor() {\n        this._parts = [null, null, null];\n    }\n    /**\n     * Sets the measurement name.\n     * @param name\n     * @return\n     */\n    name(name) {\n        this._parts[2] = name;\n        return this;\n    }\n    /**\n     * Sets the retention policy name.\n     * @param retentionPolicy\n     * @return\n     */\n    policy(retentionPolicy) {\n        this._parts[1] = retentionPolicy;\n        return this;\n    }\n    /**\n     * Sets the database name.\n     * @param db\n     * @return\n     */\n    db(db) {\n        this._parts[0] = db;\n        return this;\n    }\n    /**\n     * Converts the measurement into its InfluxQL representation.\n     * @return\n     * @throws {Error} if a measurement name is not provided\n     */\n    toString() {\n        if (!this._parts[2]) {\n            throw new Error(`You must specify a measurement name to query! Got \\`${this._parts[2]}\\``);\n        }\n        return this._parts\n            .filter((p) => Boolean(p))\n            .map((p) => escape.quoted(p))\n            .join(\".\");\n    }\n}\nexport function parseMeasurement(q) {\n    if (typeof q.measurement === \"function\") {\n        return q.measurement(new Measurement()).toString();\n    }\n    return q.measurement;\n}\nexport function parseWhere(q) {\n    if (typeof q.where === \"function\") {\n        return q.where(new Expression()).toString();\n    }\n    return q.where;\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "regexHasFlags",
    "memberof": "src/builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/builder.js~regexHasFlags",
    "access": "public",
    "export": false,
    "importPath": "influx/src/builder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "params": [
      {
        "name": "re",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "class",
    "name": "Expression",
    "memberof": "src/builder.js",
    "static": true,
    "longname": "src/builder.js~Expression",
    "access": "public",
    "export": true,
    "importPath": "influx/src/builder.js",
    "importStyle": "{Expression}",
    "description": "Expression is used to build filtering expressions, like those used in WHERE\nclauses. It can be used for fluent and safe building of queries using\nuntrusted input.",
    "examples": [
      "e => e\n  .field('host').equals.value('ares.peet.io')\n  .or\n  .field('host').matches(/example\\.com$/)\n  .or\n  .expr(e => e\n    .field('country').equals.value('US')\n    .and\n    .field('state').equals.value('WA'));\n\n// Generates:\n// \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n//   (\"county\" = 'US' AND \"state\" = 'WA')"
    ],
    "lineNumber": 28,
    "interface": false
  },
  {
    "__docId__": 67,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "_query",
    "memberof": "src/builder.js~Expression",
    "static": false,
    "longname": "src/builder.js~Expression#_query",
    "access": "private",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "tag",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#tag",
    "access": "public",
    "description": "Inserts a tag reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "field",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#field",
    "access": "public",
    "description": "Inserts a field reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "exp",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#exp",
    "access": "public",
    "description": "Inserts a subexpression; invokes the function with a new expression\nthat can be chained on.",
    "examples": [
      "e.field('a').equals.value('b')\n  .or.expr(e =>\n    e.field('b').equals.value('b')\n    .and.field('a').equals.value('c'))\n  .toString()\n// \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')"
    ],
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "value",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#value",
    "access": "public",
    "description": "Value chains on a value to the expression.\n\n - Numbers will be inserted verbatim\n - Strings will be escaped and inserted\n - Booleans will be inserted correctly\n - Dates will be formatted and inserted correctly, including INanoDates.\n - Regular expressions will be inserted correctly, however an error will\n   be thrown if they contain flags, as regex flags do not work in Influx\n - Otherwise we'll try to call `.toString()` on the value, throwing\n   if we cannot do so.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "get",
    "name": "and",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#and",
    "access": "public",
    "description": "Chains on an AND clause to the expression.",
    "lineNumber": 119,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "get",
    "name": "or",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#or",
    "access": "public",
    "description": "Chains on an OR clause to the expression.",
    "lineNumber": 126,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "get",
    "name": "plus",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#plus",
    "access": "public",
    "description": "Chains on a `+` operator to the expression.",
    "lineNumber": 133,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "get",
    "name": "times",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#times",
    "access": "public",
    "description": "Chains on a `*` operator to the expression.",
    "lineNumber": 140,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "get",
    "name": "minus",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#minus",
    "access": "public",
    "description": "Chains on a `-` operator to the expression.",
    "lineNumber": 147,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "get",
    "name": "div",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#div",
    "access": "public",
    "description": "Chains on a `/` operator to the expression.",
    "lineNumber": 154,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "get",
    "name": "equals",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#equals",
    "access": "public",
    "description": "Chains on a `=` conditional to the expression.",
    "lineNumber": 161,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "get",
    "name": "matches",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#matches",
    "access": "public",
    "description": "Chains on a `=~` conditional to the expression to match regexes.",
    "lineNumber": 168,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "get",
    "name": "doesntMatch",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#doesntMatch",
    "access": "public",
    "description": "Chains on a `!`` conditional to the expression to match regexes.",
    "lineNumber": 175,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "get",
    "name": "notEqual",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#notEqual",
    "access": "public",
    "description": "Chains on a `!=` conditional to the expression.",
    "lineNumber": 182,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "get",
    "name": "gt",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#gt",
    "access": "public",
    "description": "Chains on a `>` conditional to the expression.",
    "lineNumber": 189,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "get",
    "name": "gte",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#gte",
    "access": "public",
    "description": "Chains on a `>=` conditional to the expression.",
    "lineNumber": 196,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "get",
    "name": "lt",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#lt",
    "access": "public",
    "description": "Chains on a `<` conditional to the expression.",
    "lineNumber": 203,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "get",
    "name": "lte",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#lte",
    "access": "public",
    "description": "Chains on a `<=` conditional to the expression.",
    "lineNumber": 210,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "toString",
    "memberof": "src/builder.js~Expression",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Expression#toString",
    "access": "public",
    "description": "Converts the expression into its InfluxQL representation.",
    "lineNumber": 218,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "class",
    "name": "Measurement",
    "memberof": "src/builder.js",
    "static": true,
    "longname": "src/builder.js~Measurement",
    "access": "public",
    "export": true,
    "importPath": "influx/src/builder.js",
    "importStyle": "{Measurement}",
    "description": "Measurement creates a reference to a particular measurement. You can\nreference it solely by its name, but you can also specify the retention\npolicy and database it lives under.",
    "examples": [
      "m.name('my_measurement') // \"my_measurement\"\nm.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\nm.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".\"one_day\".\"my_measurement\""
    ],
    "lineNumber": 232,
    "interface": false
  },
  {
    "__docId__": 89,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/builder.js~Measurement",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Measurement#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "_parts",
    "memberof": "src/builder.js~Measurement",
    "static": false,
    "longname": "src/builder.js~Measurement#_parts",
    "access": "private",
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "name",
    "memberof": "src/builder.js~Measurement",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Measurement#name",
    "access": "public",
    "description": "Sets the measurement name.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "policy",
    "memberof": "src/builder.js~Measurement",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Measurement#policy",
    "access": "public",
    "description": "Sets the retention policy name.",
    "lineNumber": 250,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "retentionPolicy",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "db",
    "memberof": "src/builder.js~Measurement",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Measurement#db",
    "access": "public",
    "description": "Sets the database name.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "db",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "toString",
    "memberof": "src/builder.js~Measurement",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/builder.js~Measurement#toString",
    "access": "public",
    "description": "Converts the measurement into its InfluxQL representation.",
    "lineNumber": 268,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if a measurement name is not provided"
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "function",
    "name": "parseMeasurement",
    "memberof": "src/builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/builder.js~parseMeasurement",
    "access": "public",
    "export": true,
    "importPath": "influx/src/builder.js",
    "importStyle": "{parseMeasurement}",
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "function",
    "name": "parseWhere",
    "memberof": "src/builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/builder.js~parseWhere",
    "access": "public",
    "export": true,
    "importPath": "influx/src/builder.js",
    "importStyle": "{parseWhere}",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "src/grammar/ds.js",
    "content": "/**\n * FieldType is an enumeration of InfluxDB field data types.\n * @typedef {Number} FieldType\n * @example\n * import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n *\n * const schema = {\n *   measurement: 'my_measurement',\n *   fields: {\n *     my_int: FieldType.INTEGER,\n *     my_float: FieldType.FLOAT,\n *     my_string: FieldType.STRING,\n *     my_boolean: FieldType.BOOLEAN,\n *   }\n * }\n */\nexport var FieldType;\n(function (FieldType) {\n    FieldType[FieldType[\"FLOAT\"] = 0] = \"FLOAT\";\n    FieldType[FieldType[\"INTEGER\"] = 1] = \"INTEGER\";\n    FieldType[FieldType[\"STRING\"] = 2] = \"STRING\";\n    FieldType[FieldType[\"BOOLEAN\"] = 3] = \"BOOLEAN\";\n})(FieldType || (FieldType = {}));\nexport function isNumeric(value) {\n    return !Number.isNaN(Number(value));\n}\n/**\n * You can provide Raw values to Influx methods to prevent it from escaping\n * your provided string.\n * @class\n * @example\n * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n */\nexport class Raw {\n    /**\n     * Wraps a string so that it is not escaped in Influx queries.\n     * @param value\n     * @example\n     * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Returns the wrapped string.\n     * @return\n     */\n    getValue() {\n        return this.value;\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/grammar/ds.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 98,
    "kind": "typedef",
    "name": "FieldType",
    "memberof": "src/grammar/ds.js",
    "static": true,
    "longname": "src/grammar/ds.js~FieldType",
    "access": "public",
    "description": "FieldType is an enumeration of InfluxDB field data types.",
    "examples": [
      "import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n\nconst schema = {\n  measurement: 'my_measurement',\n  fields: {\n    my_int: FieldType.INTEGER,\n    my_float: FieldType.FLOAT,\n    my_string: FieldType.STRING,\n    my_boolean: FieldType.BOOLEAN,\n  }\n}"
    ],
    "lineNumber": 17,
    "type": {
      "types": [
        "Number"
      ],
      "optional": false,
      "name": "FieldType"
    }
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "isNumeric",
    "memberof": "src/grammar/ds.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/ds.js~isNumeric",
    "access": "public",
    "export": true,
    "importPath": "influx/src/grammar/ds.js",
    "importStyle": "{isNumeric}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 100,
    "kind": "class",
    "name": "Raw",
    "memberof": "src/grammar/ds.js",
    "static": true,
    "longname": "src/grammar/ds.js~Raw",
    "access": "public",
    "export": true,
    "importPath": "influx/src/grammar/ds.js",
    "importStyle": "{Raw}",
    "description": "You can provide Raw values to Influx methods to prevent it from escaping\nyour provided string.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 101,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grammar/ds.js~Raw",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/ds.js~Raw#constructor",
    "access": "public",
    "description": "Wraps a string so that it is not escaped in Influx queries.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "value",
    "memberof": "src/grammar/ds.js~Raw",
    "static": false,
    "longname": "src/grammar/ds.js~Raw#value",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "getValue",
    "memberof": "src/grammar/ds.js~Raw",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/ds.js~Raw#getValue",
    "access": "public",
    "description": "Returns the wrapped string.",
    "lineNumber": 48,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "file",
    "name": "src/grammar/escape.js",
    "content": "import { Raw } from \"./ds\";\nconst reEscape = /[-|\\\\{()[\\]^$+*?.]/g;\n/**\n * The Escaper escapes the special characters in the provided list\n * with backslashes. Much of the code here is inspired by that in the\n * sqlstring packet found here: https://github.com/mysqljs/sqlstring\n *\n * Instances of the Escaper are derived from the documentation of escape\n * sequences found here: https://aka.ms/co1m4k\n *\n * sqlstring is made available under the following license:\n *\n *   Copyright (c) 2012 Felix Geisendrfer (felix@debuggable.com) and contributors\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *   THE SOFTWARE.\n *\n */\nclass Escaper {\n    constructor(chars, wrap = \"\", escaper = \"\\\\\") {\n        this.wrap = wrap;\n        this.escaper = escaper;\n        const patterns = chars.join(\"\").replace(reEscape, \"\\\\$&\");\n        this._re = new RegExp(\"[\" + patterns + \"]\", \"g\");\n    }\n    /**\n     * Escape replaces occurrences of special characters within the target\n     * string with the necessary escape codes.\n     */\n    escape(val) {\n        if (val instanceof Raw) {\n            return val.getValue();\n        }\n        this._re.lastIndex = 0;\n        let chunkIndex = this._re.lastIndex;\n        let escapedVal = \"\";\n        let match;\n        if (typeof val === \"string\") {\n            val = val.replace(/\\\\'/, \"\\\\\\\\'\");\n        }\n        /* eslint-disable no-cond-assign */\n        while ((match = this._re.exec(val))) {\n            escapedVal +=\n                val.slice(chunkIndex, match.index) + this.escaper + match[0];\n            chunkIndex = this._re.lastIndex;\n        }\n        if (chunkIndex === 0) {\n            return this.wrap + val + this.wrap;\n        }\n        if (chunkIndex < val.length) {\n            return this.wrap + escapedVal + val.slice(chunkIndex) + this.wrap;\n        }\n        return this.wrap + escapedVal + this.wrap;\n    }\n}\nconst bindEsc = (e) => e.escape.bind(e);\n/**\n * TagEscaper escapes tag keys, tag values, and field keys.\n * @type {Object}\n * @property {function(s: string): string } quoted Escapes and wraps quoted\n *     values, such as database names.\n * @property {function(s: string): string } stringLit Escapes and\n *     wraps string literals.\n * @property {function(s: string): string } measurement Escapes measurement\n *     names on the line protocol.\n * @property {function(s: string): string } tag Escapes tag keys, take values,\n *     and field keys on the line protocol.\n *\n * @example\n * console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\n * console.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n *\n * console.log(escape.measurement('my measurement')); // => my\\ measurement\n * console.log(escape.tag('my tag=')); // => my\\ tag\\=\n */\nexport const escape = {\n    /**\n     * Measurement escapes measurement names.\n     */\n    measurement: bindEsc(new Escaper([\",\", \" \"])),\n    /**\n     * Quoted escapes quoted values, such as database names.\n     */\n    quoted: bindEsc(new Escaper(['\"', \"\\\\\\\\\"], '\"')),\n    /**\n     * StringLitEscaper escapes single quotes in string literals.\n     */\n    stringLit: bindEsc(new Escaper([\"'\"], \"'\")),\n    /**\n     * TagEscaper escapes tag keys, tag values, and field keys.\n     */\n    tag: bindEsc(new Escaper([\",\", \"=\", \" \"])),\n};\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/grammar/escape.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 105,
    "kind": "variable",
    "name": "reEscape",
    "memberof": "src/grammar/escape.js",
    "static": true,
    "longname": "src/grammar/escape.js~reEscape",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/escape.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "Escaper",
    "memberof": "src/grammar/escape.js",
    "static": true,
    "longname": "src/grammar/escape.js~Escaper",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/escape.js",
    "importStyle": null,
    "description": "The Escaper escapes the special characters in the provided list\nwith backslashes. Much of the code here is inspired by that in the\nsqlstring packet found here: https://github.com/mysqljs/sqlstring\n\nInstances of the Escaper are derived from the documentation of escape\nsequences found here: https://aka.ms/co1m4k\n\nsqlstring is made available under the following license:\n\n  Copyright (c) 2012 Felix Geisendrfer (felix@debuggable.com) and contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.",
    "lineNumber": 34,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grammar/escape.js~Escaper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/escape.js~Escaper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "wrap",
    "memberof": "src/grammar/escape.js~Escaper",
    "static": false,
    "longname": "src/grammar/escape.js~Escaper#wrap",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "escaper",
    "memberof": "src/grammar/escape.js~Escaper",
    "static": false,
    "longname": "src/grammar/escape.js~Escaper#escaper",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_re",
    "memberof": "src/grammar/escape.js~Escaper",
    "static": false,
    "longname": "src/grammar/escape.js~Escaper#_re",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "escape",
    "memberof": "src/grammar/escape.js~Escaper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/escape.js~Escaper#escape",
    "access": "public",
    "description": "Escape replaces occurrences of special characters within the target\nstring with the necessary escape codes.",
    "lineNumber": 45,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "function",
    "name": "bindEsc",
    "memberof": "src/grammar/escape.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/escape.js~bindEsc",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/escape.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 113,
    "kind": "variable",
    "name": "escape",
    "memberof": "src/grammar/escape.js",
    "static": true,
    "longname": "src/grammar/escape.js~escape",
    "access": "public",
    "export": true,
    "importPath": "influx/src/grammar/escape.js",
    "importStyle": "{escape}",
    "description": "TagEscaper escapes tag keys, tag values, and field keys.",
    "examples": [
      "console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\nconsole.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n\nconsole.log(escape.measurement('my measurement')); // => my\\ measurement\nconsole.log(escape.tag('my tag=')); // => my\\ tag\\="
    ],
    "lineNumber": 91,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "quoted",
        "description": "Escapes and wraps quoted\n    values, such as database names."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "stringLit",
        "description": "Escapes and\n    wraps string literals."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "Escapes measurement\n    names on the line protocol."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "tag",
        "description": "Escapes tag keys, take values,\n    and field keys on the line protocol."
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "file",
    "name": "src/grammar/index.js",
    "content": "export * from \"./escape\";\nexport * from \"./ds\";\nexport * from \"./times\";\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/grammar/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "src/grammar/times.js",
    "content": "/* eslint-disable no-fallthrough */\nimport { isNumeric } from \"./ds\";\n/**\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\n * Influx uses three time formats:\n *  - ISO times with nanoseconds when querying where an epoch is not provided\n *  - Unix timestamps when querying with an epoch (specifying the precision\n *    in the given time unit)\n *  - Its own time format for time literals.\n *\n * To complicate matters, Influx operates on nanosecond precisions\n * by default, but we can't represent nanosecond timestamps in\n * JavaScript numbers as they're 64 bit uints.\n *\n * As a result we have several utilities to convert between these different\n * formats. When precision is required, we represent nanosecond timestamps\n * as strings and wrap default dates in the INanoDate interface which\n * lets the consumer read and write these more precise timestamps.\n *\n * Representing the timestamps as strings is definitely not a pure way to go\n * about it, but importing an arbitrary-precision integer library adds\n * bloat and is a massive hit to throughput. The operations we do do\n * are pretty trivial, so we stick with manipulating strings\n * and make sure to wash our hands when we're done.\n *\n * Vocabulary:\n *  Unix timestamp   = 'timestamp', abbreviated as 'time'\n *  ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n *  Influx timestamp = 'Influx time', abbreviated as 'Influx'\n */\nfunction leftPad(str, length, pad = \"0\") {\n    if (typeof str === \"number\") {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str = pad + str;\n    }\n    return str;\n}\nfunction rightPad(str, length, pad = \"0\") {\n    if (typeof str === \"number\") {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str += pad;\n    }\n    return str;\n}\n/**\n * Precision is a map of available Influx time precisions.\n * @type {Object.<String, String>}\n * @example\n * console.log(Precision.Hours); // => 'h'\n * console.log(Precision.Minutes); // => 'm'\n * console.log(Precision.Seconds); // => 's'\n * console.log(Precision.Milliseconds); // => 'ms'\n * console.log(Precision.Microseconds); // => 'u'\n * console.log(Precision.Nanoseconds); // => 'n'\n */\nexport const Precision = Object.freeze({\n    // Tslint:disable-line\n    Hours: \"h\",\n    Microseconds: \"u\",\n    Milliseconds: \"ms\",\n    Minutes: \"m\",\n    Nanoseconds: \"n\",\n    Seconds: \"s\",\n});\nclass MillisecondDateManipulator {\n    format(date) {\n        return ('\"' +\n            leftPad(date.getUTCFullYear(), 2) +\n            \"-\" +\n            leftPad(date.getUTCMonth() + 1, 2) +\n            \"-\" +\n            leftPad(date.getUTCDate(), 2) +\n            \" \" +\n            leftPad(date.getUTCHours(), 2) +\n            \":\" +\n            leftPad(date.getUTCMinutes(), 2) +\n            \":\" +\n            leftPad(date.getUTCSeconds(), 2) +\n            \".\" +\n            leftPad(date.getUTCMilliseconds(), 3) +\n            '\"');\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case \"n\":\n                ms *= 1000;\n            case \"u\":\n                ms *= 1000;\n            case \"ms\":\n                return String(ms);\n            case \"h\":\n                ms /= 60;\n            case \"m\":\n                ms /= 60;\n            case \"s\":\n                ms /= 1000;\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        return new Date(timestamp);\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case \"n\":\n                timestamp /= 1000;\n            case \"u\":\n                timestamp /= 1000;\n            case \"ms\":\n                return new Date(timestamp);\n            case \"h\":\n                timestamp *= 60;\n            case \"m\":\n                timestamp *= 60;\n            case \"s\":\n                timestamp *= 1000;\n                return new Date(timestamp);\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst nsPer = {\n    ms: Math.pow(10, 6),\n    s: Math.pow(10, 9),\n};\nfunction nanoIsoToTime(iso) {\n    let [secondsStr, decimalStr] = iso.split(\".\");\n    if (decimalStr === undefined) {\n        decimalStr = \"000000000\";\n    }\n    else {\n        decimalStr = rightPad(decimalStr.slice(0, -1), 9);\n        secondsStr += \"Z\";\n    }\n    const seconds = Math.floor(new Date(secondsStr).getTime() / 1000);\n    return `${seconds}${decimalStr}`;\n}\nconst nanoDateMethods = {\n    getNanoTimeFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        return this._cachedNanoTime;\n    },\n    toNanoISOStringFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        const base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n        return `${base}${this._cachedNanoTime.slice(-9)}Z`;\n    },\n    getNanoTimeFromStamp() {\n        return this._nanoTime;\n    },\n    toNanoISOStringFromStamp() {\n        const base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n        return `${base}${this._nanoTime.slice(-9)}Z`;\n    },\n};\n/**\n * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\n * timestamp is provided as a string to prevent precision loss.\n *\n * Please see [A Moment for Times](https://node-influx.github.io/manual/\n * usage.html#a-moment-for-times) for a more complete and eloquent explanation\n * of time handling in this module.\n *\n * @param timestamp\n * @example\n * const date = toNanoDate('1475985480231035600')\n *\n * // You can use the returned Date as a normal date:\n * expect(date.getTime()).to.equal(1475985480231);\n *\n * // We decorate it with two additional methods to read\n * // nanosecond-precision results:\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n */\nexport function toNanoDate(timestamp) {\n    const secs = Math.floor(Number(timestamp) / nsPer.s);\n    const remainingNs = timestamp.slice(String(secs).length);\n    const remainingMs = Number(remainingNs) / nsPer.ms;\n    const date = new Date(0);\n    date.setUTCSeconds(secs, remainingMs);\n    date._nanoTime = timestamp;\n    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n    return date;\n}\nfunction asNanoDate(date) {\n    const d = date;\n    if (d.getNanoTime) {\n        return d;\n    }\n    return undefined;\n}\nclass NanosecondsDateManipulator {\n    format(date) {\n        return ('\"' +\n            leftPad(date.getUTCFullYear(), 2) +\n            \"-\" +\n            leftPad(date.getUTCMonth() + 1, 2) +\n            \"-\" +\n            leftPad(date.getUTCDate(), 2) +\n            \" \" +\n            leftPad(date.getUTCHours(), 2) +\n            \":\" +\n            leftPad(date.getUTCMinutes(), 2) +\n            \":\" +\n            leftPad(date.getUTCSeconds(), 2) +\n            \".\" +\n            date.getNanoTime().slice(-9) +\n            '\"');\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case \"u\":\n                return date.getNanoTime().slice(0, -3);\n            case \"n\":\n                return date.getNanoTime();\n            case \"h\":\n                ms /= 60;\n            case \"m\":\n                ms /= 60;\n            case \"s\":\n                ms /= 1000;\n            case \"ms\":\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        const date = new Date(timestamp);\n        date._nanoISO = timestamp;\n        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\n        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\n        return date;\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case \"h\":\n                timestamp *= 60;\n            case \"m\":\n                timestamp *= 60;\n            case \"s\":\n                timestamp *= 1000;\n            case \"ms\":\n                timestamp *= 1000;\n            case \"u\":\n                timestamp *= 1000;\n            case \"n\": {\n                const date = new Date(timestamp / nsPer.ms);\n                date._nanoTime = String(timestamp);\n                date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n                date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n                return date;\n            }\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst milliManipulator = new MillisecondDateManipulator();\nconst nanoManipulator = new NanosecondsDateManipulator();\n/**\n * FormatDate converts the Date instance to Influx's date query format.\n * @private\n */\nexport function formatDate(date) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.format(nano);\n    }\n    return milliManipulator.format(date);\n}\n/**\n * Converts a Date instance to a timestamp with the specified time precision.\n * @private\n */\nexport function dateToTime(date, precision) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.toTime(nano, precision);\n    }\n    return milliManipulator.toTime(date, precision);\n}\n/**\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\n * the precision is finer than 'ms' the returned value will be a INanoDate.\n * @private\n */\nexport function isoOrTimeToDate(stamp, precision = \"n\") {\n    if (typeof stamp === \"string\") {\n        return nanoManipulator.isoToDate(stamp);\n    }\n    return nanoManipulator.timetoDate(stamp, precision);\n}\n/**\n * Converts a timestamp to a string with the correct precision. Assumes\n * that raw number and string instances are already in the correct precision.\n * @private\n */\nexport function castTimestamp(timestamp, precision) {\n    if (typeof timestamp === \"string\") {\n        if (!isNumeric(timestamp)) {\n            throw new Error(`Expected numeric value for, timestamp, but got '${timestamp}'!`);\n        }\n        return timestamp;\n    }\n    if (typeof timestamp === \"number\") {\n        return String(timestamp);\n    }\n    return dateToTime(timestamp, precision);\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/grammar/times.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "function",
    "name": "leftPad",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~leftPad",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": "Just a quick overview of what's going on in this file. It's a bit of a mess.\nInflux uses three time formats:\n - ISO times with nanoseconds when querying where an epoch is not provided\n - Unix timestamps when querying with an epoch (specifying the precision\n   in the given time unit)\n - Its own time format for time literals.\n\nTo complicate matters, Influx operates on nanosecond precisions\nby default, but we can't represent nanosecond timestamps in\nJavaScript numbers as they're 64 bit uints.\n\nAs a result we have several utilities to convert between these different\nformats. When precision is required, we represent nanosecond timestamps\nas strings and wrap default dates in the INanoDate interface which\nlets the consumer read and write these more precise timestamps.\n\nRepresenting the timestamps as strings is definitely not a pure way to go\nabout it, but importing an arbitrary-precision integer library adds\nbloat and is a massive hit to throughput. The operations we do do\nare pretty trivial, so we stick with manipulating strings\nand make sure to wash our hands when we're done.\n\nVocabulary:\n Unix timestamp   = 'timestamp', abbreviated as 'time'\n ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n Influx timestamp = 'Influx time', abbreviated as 'Influx'",
    "lineNumber": 31,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "function",
    "name": "rightPad",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~rightPad",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "variable",
    "name": "Precision",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~Precision",
    "access": "public",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{Precision}",
    "description": "Precision is a map of available Influx time precisions.",
    "examples": [
      "console.log(Precision.Hours); // => 'h'\nconsole.log(Precision.Minutes); // => 'm'\nconsole.log(Precision.Seconds); // => 's'\nconsole.log(Precision.Milliseconds); // => 'ms'\nconsole.log(Precision.Microseconds); // => 'u'\nconsole.log(Precision.Nanoseconds); // => 'n'"
    ],
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "Object.<String, String>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 119,
    "kind": "class",
    "name": "MillisecondDateManipulator",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~MillisecondDateManipulator",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "format",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~MillisecondDateManipulator#format",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "toTime",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~MillisecondDateManipulator#toTime",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~MillisecondDateManipulator#isoToDate",
    "access": "public",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~MillisecondDateManipulator#timetoDate",
    "access": "public",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 124,
    "kind": "variable",
    "name": "nsPer",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~nsPer",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "type": {
      "types": [
        "{\"ms\": *, \"s\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 125,
    "kind": "function",
    "name": "nanoIsoToTime",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~nanoIsoToTime",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "params": [
      {
        "name": "iso",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 126,
    "kind": "variable",
    "name": "nanoDateMethods",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~nanoDateMethods",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "type": {
      "types": [
        "{\"getNanoTimeFromISO\": function, \"toNanoISOStringFromISO\": function, \"getNanoTimeFromStamp\": function, \"toNanoISOStringFromStamp\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 127,
    "kind": "function",
    "name": "toNanoDate",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~toNanoDate",
    "access": "public",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{toNanoDate}",
    "description": "Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\ntimestamp is provided as a string to prevent precision loss.\n\nPlease see [A Moment for Times](https://node-influx.github.io/manual/\nusage.html#a-moment-for-times) for a more complete and eloquent explanation\nof time handling in this module.",
    "examples": [
      "const date = toNanoDate('1475985480231035600')\n\n// You can use the returned Date as a normal date:\nexpect(date.getTime()).to.equal(1475985480231);\n\n// We decorate it with two additional methods to read\n// nanosecond-precision results:\nexpect(date.getNanoTime()).to.equal('1475985480231035600');\nexpect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');"
    ],
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "function",
    "name": "asNanoDate",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~asNanoDate",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "class",
    "name": "NanosecondsDateManipulator",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~NanosecondsDateManipulator",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "format",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#format",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "toTime",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#toTime",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#isoToDate",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#timetoDate",
    "access": "public",
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "milliManipulator",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~milliManipulator",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "type": {
      "types": [
        "src/grammar/times.js~MillisecondDateManipulator"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "nanoManipulator",
    "memberof": "src/grammar/times.js",
    "static": true,
    "longname": "src/grammar/times.js~nanoManipulator",
    "access": "public",
    "export": false,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 275,
    "undocument": true,
    "type": {
      "types": [
        "src/grammar/times.js~NanosecondsDateManipulator"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "function",
    "name": "formatDate",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~formatDate",
    "access": "private",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{formatDate}",
    "description": "FormatDate converts the Date instance to Influx's date query format.",
    "lineNumber": 280,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "function",
    "name": "dateToTime",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~dateToTime",
    "access": "private",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{dateToTime}",
    "description": "Converts a Date instance to a timestamp with the specified time precision.",
    "lineNumber": 291,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "function",
    "name": "isoOrTimeToDate",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~isoOrTimeToDate",
    "access": "private",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{isoOrTimeToDate}",
    "description": "Converts an ISO-formatted data or unix timestamp to a Date instance. If\nthe precision is finer than 'ms' the returned value will be a INanoDate.",
    "lineNumber": 303,
    "params": [
      {
        "name": "stamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "n",
        "defaultValue": "n"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "function",
    "name": "castTimestamp",
    "memberof": "src/grammar/times.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grammar/times.js~castTimestamp",
    "access": "private",
    "export": true,
    "importPath": "influx/src/grammar/times.js",
    "importStyle": "{castTimestamp}",
    "description": "Converts a timestamp to a string with the correct precision. Assumes\nthat raw number and string instances are already in the correct precision.",
    "lineNumber": 314,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "file",
    "name": "src/host.js",
    "content": "import * as urlModule from \"url\";\nexport class Host {\n    /**\n     * Creates a new Host instance.\n     * @param url\n     * @param backoff\n     */\n    constructor(url, backoff, options) {\n        this.backoff = backoff;\n        this.options = options;\n        this.url = urlModule.parse(url);\n    }\n    /**\n     * Marks a failure on the host and returns the length of time it\n     * should be removed from the pool\n     * @return removal time in milliseconds\n     */\n    fail() {\n        const value = this.backoff.getDelay();\n        this.backoff = this.backoff.next();\n        return value;\n    }\n    /**\n     * Should be called when a successful operation is run against the host.\n     * It resets the host's backoff strategy.\n     */\n    success() {\n        this.backoff = this.backoff.reset();\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/host.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 141,
    "kind": "class",
    "name": "Host",
    "memberof": "src/host.js",
    "static": true,
    "longname": "src/host.js~Host",
    "access": "public",
    "export": true,
    "importPath": "influx/src/host.js",
    "importStyle": "{Host}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 142,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/host.js~Host#constructor",
    "access": "public",
    "description": "Creates a new Host instance.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "backoff",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "static": false,
    "longname": "src/host.js~Host#backoff",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "options",
    "memberof": "src/host.js~Host",
    "static": false,
    "longname": "src/host.js~Host#options",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "url",
    "memberof": "src/host.js~Host",
    "static": false,
    "longname": "src/host.js~Host#url",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "fail",
    "memberof": "src/host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/host.js~Host#fail",
    "access": "public",
    "description": "Marks a failure on the host and returns the length of time it\nshould be removed from the pool",
    "lineNumber": 18,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "removal time in milliseconds"
    },
    "params": []
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "success",
    "memberof": "src/host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/host.js~Host#success",
    "access": "public",
    "description": "Should be called when a successful operation is run against the host.\nIt resets the host's backoff strategy.",
    "lineNumber": 27,
    "params": [],
    "return": null
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "src/index.js",
    "content": "/* eslint-disable @typescript-eslint/unified-signatures */\n/* eslint-disable no-prototype-builtins */\nimport * as url from \"url\";\nimport * as b from \"./builder\";\nimport * as grammar from \"./grammar\";\nimport { Pool } from \"./pool\";\nimport { assertNoErrors, parse, parseSingle } from \"./results\";\nimport { coerceBadly, Schema } from \"./schema\";\nconst defaultHost = Object.freeze({\n    host: \"127.0.0.1\",\n    port: 8086,\n    path: \"\",\n    protocol: \"http\",\n});\nconst defaultOptions = Object.freeze({\n    database: null,\n    hosts: [],\n    password: \"root\",\n    schema: [],\n    username: \"root\",\n});\nexport * from \"./builder\";\nexport { FieldType, Precision, Raw, escape, toNanoDate, } from \"./grammar\";\nexport { ResultError } from \"./results\";\n/**\n * Parses the URL out into into a IClusterConfig object\n */\nfunction parseOptionsUrl(addr) {\n    const parsed = url.parse(addr);\n    const options = {\n        host: parsed.hostname,\n        port: Number(parsed.port),\n        protocol: parsed.protocol.slice(0, -1),\n    };\n    if (parsed.auth) {\n        [options.username, options.password] = parsed.auth.split(\":\");\n    }\n    if (parsed.pathname.length > 1) {\n        options.database = parsed.pathname.slice(1);\n    }\n    return options;\n}\n/**\n * Works similarly to Object.assign, but only overwrites\n * properties that resolve to undefined.\n */\nfunction defaults(target, ...srcs) {\n    srcs.forEach((src) => {\n        Object.keys(src).forEach((key) => {\n            if (target[key] === undefined) {\n                target[key] = src[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * InfluxDB is the public interface to run queries against your database.\n * This is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\n * queries directly by calling methods on this class.\n *\n * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\n * if you want help getting started!\n *\n * @example\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'localhost',\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * @example\n * // Connect over HTTPS\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'myinfluxdbhost',\n *  port: 443,\n *  protocol: 'https'\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * influx.writePoints([\n *   {\n *     measurement: 'response_times',\n *     tags: { host: os.hostname() },\n *     fields: { duration, path: req.path },\n *   }\n * ]).then(() => {\n *   return influx.query(`\n *     select * from response_times\n *     where host = $<host>\n *     order by time desc\n *     limit 10\n *   `, {\n *      placeholders: {\n *        host: os.hostname()\n *      }\n *   })\n * }).then(rows => {\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n * })\n */\nexport class InfluxDB {\n    /**\n     * Connect to a single InfluxDB instance by specifying\n     * a set of connection options.\n     * @param [options='http://root:root@127.0.0.1:8086']\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Connect to a single host with a DSN:\n     * const influx = new Influx.InfluxDB('http://user:password@host:8086/database')\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Connect to a single host with a full set of config details and\n     * // a custom schema\n     * const client = new Influx.InfluxDB({\n     *   database: 'my_db',\n     *   host: 'localhost',\n     *   port: 8086,\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   schema: [\n     *     {\n     *       measurement: 'perf',\n     *       fields: {\n     *         memory_usage: Influx.FieldType.INTEGER,\n     *         cpu_usage: Influx.FieldType.FLOAT,\n     *         is_online: Influx.FieldType.BOOLEAN\n     *       }\n     *       tags: [\n     *         'hostname'\n     *       ]\n     *     }\n     *   ]\n     * })\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Use a pool of several host connections and balance queries across them:\n     * const client = new Influx.InfluxDB({\n     *   database: 'my_db',\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   hosts: [\n     *     { host: 'db1.example.com' },\n     *     { host: 'db2.example.com' },\n     *   ],\n     *   schema: [\n     *     {\n     *       measurement: 'perf',\n     *       fields: {\n     *         memory_usage: Influx.FieldType.INTEGER,\n     *         cpu_usage: Influx.FieldType.FLOAT,\n     *         is_online: Influx.FieldType.BOOLEAN\n     *       }\n     *       tags: [\n     *         'hostname'\n     *       ]\n     *     }\n     *   ]\n     * })\n     *\n     */\n    constructor(options) {\n        /**\n         * Map of Schema instances defining measurements in Influx.\n         * @private\n         */\n        this._schema = Object.create(null);\n        // Figure out how to parse whatever we were passed in into a IClusterConfig.\n        if (typeof options === \"string\") {\n            // Plain URI => ISingleHostConfig\n            options = parseOptionsUrl(options);\n        }\n        else if (!options) {\n            options = defaultHost;\n        }\n        if (!options.hasOwnProperty(\"hosts\")) {\n            // ISingleHostConfig => IClusterConfig\n            options = {\n                database: options.database,\n                hosts: [options],\n                password: options.password,\n                pool: options.pool,\n                schema: options.schema,\n                username: options.username,\n            };\n        }\n        const resolved = options;\n        resolved.hosts = resolved.hosts.map((host) => {\n            return defaults({\n                host: host.host,\n                port: host.port,\n                path: host.path,\n                protocol: host.protocol,\n                options: host.options,\n            }, defaultHost);\n        });\n        this._pool = new Pool(resolved.pool);\n        this._options = defaults(resolved, defaultOptions);\n        resolved.hosts.forEach((host) => {\n            this._pool.addHost(`${host.protocol}://${host.host}:${host.port}${host.path}`, host.options);\n        });\n        this._options.schema.forEach((schema) => this._createSchema(schema));\n    }\n    /**\n     * Adds specified schema for better fields coercing.\n     *\n     * @param {ISchemaOptions} schema\n     * @memberof InfluxDB\n     */\n    addSchema(schema) {\n        this._createSchema(schema);\n    }\n    /**\n     * Creates a new database with the provided name.\n     * @param databaseName\n     * @return\n     * @example\n     * influx.createDatabase('mydb')\n     */\n    createDatabase(databaseName) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create database ${grammar.escape.quoted(databaseName)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Deletes a database with the provided name.\n     * @param databaseName\n     * @return\n     * @example\n     * influx.dropDatabase('mydb')\n     */\n    dropDatabase(databaseName) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop database ${grammar.escape.quoted(databaseName)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Returns array of database names. Requires cluster admin privileges.\n     * @returns a list of database names\n     * @example\n     * influx.getDatabaseNames().then(names =>\n     *   console.log('My database names are: ' + names.join(', ')));\n     */\n    getDatabaseNames() {\n        return this._pool\n            .json(this._getQueryOpts({ q: \"show databases\" }))\n            .then((res) => parseSingle(res).map((r) => r.name));\n    }\n    /**\n     * Returns array of measurements.\n     * @returns a list of measurement names\n     * @param [database] the database the measurement lives in, optional\n     *     if a default database is provided.\n     * @example\n     * influx.getMeasurements().then(names =>\n     *   console.log('My measurement names are: ' + names.join(', ')));\n     */\n    getMeasurements(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: \"show measurements\",\n        }))\n            .then((res) => parseSingle(res).map((r) => r.name));\n    }\n    /**\n     * Returns a list of all series within the target measurement, or from the\n     * entire database if a measurement isn't provided.\n     * @param [options]\n     * @param [options.measurement] if provided, we'll only get series\n     *     from within that measurement.\n     * @param [options.database] the database the series lives in,\n     *     optional if a default database is provided.\n     * @returns a list of series names\n     * @example\n     * influx.getSeries().then(names => {\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\n     * })\n     *\n     * influx.getSeries({\n     *   measurement: 'my_measurement',\n     *   database: 'my_db'\n     * }).then(names => {\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\n     * })\n     */\n    getSeries(options = {}) {\n        const { database = this._defaultDB(), measurement } = options;\n        let query = \"show series\";\n        if (measurement) {\n            query += ` from ${grammar.escape.quoted(measurement)}`;\n        }\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: query,\n        }))\n            .then((res) => parseSingle(res).map((r) => r.key));\n    }\n    /**\n     * Removes a measurement from the database.\n     * @param measurement\n     * @param [database] the database the measurement lives in, optional\n     *     if a default database is provided.\n     * @return\n     * @example\n     * influx.dropMeasurement('my_measurement')\n     */\n    dropMeasurement(measurement, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: `drop measurement ${grammar.escape.quoted(measurement)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Removes a one or more series from InfluxDB.\n     *\n     * @returns\n     * @example\n     * // The following pairs of queries are equivalent: you can chose either to\n     * // use our builder or pass in string directly. The builder takes care\n     * // of escaping and most syntax handling for you.\n     *\n     * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\n     * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n     * // DROP SERIES WHERE \"cpu\" = 'cpu8'\n     *\n     * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\n     * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n     * // DROP SERIES FROM \"autogen\".\"cpu\"\n     *\n     * influx.dropSeries({\n     *   measurement: m => m.name('cpu').policy('autogen'),\n     *   where: e => e.tag('cpu').equals.value('cpu8'),\n     *   database: 'my_db'\n     * })\n     * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\n     */\n    dropSeries(options) {\n        const db = \"database\" in options ? options.database : this._defaultDB();\n        let q = \"drop series\";\n        if (\"measurement\" in options) {\n            q += \" from \" + b.parseMeasurement(options);\n        }\n        if (\"where\" in options) {\n            q += \" where \" + b.parseWhere(options);\n        }\n        return this._pool\n            .json(this._getQueryOpts({ db, q }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Returns a list of users on the Influx database.\n     * @return\n     * @example\n     * influx.getUsers().then(users => {\n     *   users.forEach(user => {\n     *     if (user.admin) {\n     *       console.log(user.user, 'is an admin!')\n     *     } else {\n     *       console.log(user.user, 'is not an admin!')\n     *     }\n     *   })\n     * })\n     */\n    getUsers() {\n        return this._pool\n            .json(this._getQueryOpts({ q: \"show users\" }))\n            .then((result) => parseSingle(result));\n    }\n    /**\n     * Creates a new InfluxDB user.\n     * @param username\n     * @param password\n     * @param [admin=false] If true, the user will be given all\n     *     privileges on all databases.\n     * @return\n     * @example\n     * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n     *\n     * // make non-admins:\n     * influx.createUser('not_admin', 'pa55w0rd')\n     */\n    createUser(username, password, admin = false) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create user ${grammar.escape.quoted(username)} with password ` +\n                grammar.escape.stringLit(password) +\n                (admin ? \" with all privileges\" : \"\"),\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Sets a password for an Influx user.\n     * @param username\n     * @param password\n     * @return\n     * @example\n     * influx.setPassword('connor', 'pa55w0rd')\n     */\n    setPassword(username, password) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `set password for ${grammar.escape.quoted(username)} = ` +\n                grammar.escape.stringLit(password),\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Grants a privilege to a specified user.\n     * @param username\n     * @param privilege Should be one of 'READ' or 'WRITE'\n     * @param [database] If not provided, uses the default database.\n     * @return\n     * @example\n     * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\n     */\n    grantPrivilege(username, privilege, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `grant ${privilege} on ${grammar.escape.quoted(database)} ` +\n                `to ${grammar.escape.quoted(username)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Removes a privilege from a specified user.\n     * @param username\n     * @param privilege Should be one of 'READ' or 'WRITE'\n     * @param [database] If not provided, uses the default database.\n     * @return\n     * @example\n     * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\n     */\n    revokePrivilege(username, privilege, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `revoke ${privilege} on ${grammar.escape.quoted(database)} from ` + grammar.escape.quoted(username),\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Grants admin privileges to a specified user.\n     * @param username\n     * @return\n     * @example\n     * influx.grantAdminPrivilege('connor')\n     */\n    grantAdminPrivilege(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `grant all to ${grammar.escape.quoted(username)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Removes a admin privilege from a specified user.\n     * @param username\n     * @return\n     * @example\n     * influx.revokeAdminPrivilege('connor')\n     */\n    revokeAdminPrivilege(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `revoke all from ${grammar.escape.quoted(username)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Removes a user from the database.\n     * @param username\n     * @return\n     * @example\n     * influx.dropUser('connor')\n     */\n    dropUser(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop user ${grammar.escape.quoted(username)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param name The query name, for later reference\n     * @param query The body of the query to run\n     * @param [database] If not provided, uses the default database.\n     * @param [resample] If provided, adds resample policy\n     * @return\n     * @example\n     * influx.createContinuousQuery('downsample_cpu_1h', `\n     *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n     *   FROM \"1d\".\"perf\" GROUP BY time(1m)\n     * `, undefined, 'RESAMPLE FOR 7m')\n     */\n    createContinuousQuery(name, query, database = this._defaultDB(), resample = \"\") {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create continuous query ${grammar.escape.quoted(name)}` +\n                ` on ${grammar.escape.quoted(database)} ${resample} begin ${query} end`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Returns a list of continous queries in the database.\n     * @param [database] If not provided, uses the default database.\n     * @return\n     * @example\n     * influx.showContinousQueries()\n     */\n    showContinousQueries(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: \"show continuous queries\",\n        }))\n            .then((result) => parseSingle(result));\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param name The query name\n     * @param [database] If not provided, uses the default database.\n     * @return\n     * @example\n     * influx.dropContinuousQuery('downsample_cpu_1h')\n     */\n    dropContinuousQuery(name, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop continuous query ${grammar.escape.quoted(name)}` +\n                ` on ${grammar.escape.quoted(database)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Creates a new retention policy on a database. You can read more about\n     * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\n     * guides/downsampling_and_retention/) on the InfluxDB website.\n     *\n     * @param name The retention policy name\n     * @param options\n     * @param [options.database] Database to create the policy on,\n     *     uses the default database if not provided.\n     * @param options.duration How long data in the retention policy\n     *     should be stored for, should be in a format like `7d`. See details\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n     * @param options.replication How many servers data in the series\n     *     should be replicated to.\n     * @param [options.isDefault] Whether the retention policy should\n     *     be the default policy on the database.\n     * @return\n     * @example\n     * influx.createRetentionPolicy('7d', {\n     *  duration: '7d',\n     *  replication: 1\n     * })\n     */\n    createRetentionPolicy(name, options) {\n        const q = `create retention policy ${grammar.escape.quoted(name)} on ` +\n            grammar.escape.quoted(options.database || this._defaultDB()) +\n            ` duration ${options.duration} replication ${options.replication}` +\n            (options.isDefault ? \" default\" : \"\");\n        return this._pool\n            .json(this._getQueryOpts({ q }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Alters an existing retention policy on a database.\n     *\n     * @param name The retention policy name\n     * @param options\n     * @param [options.database] Database to create the policy on,\n     *     uses the default database if not provided.\n     * @param options.duration How long data in the retention policy\n     *     should be stored for, should be in a format like `7d`. See details\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n     * @param options.replication How many servers data in the series\n     *     should be replicated to.\n     * @param [options.default] Whether the retention policy should\n     *     be the default policy on the database.\n     * @return\n     * @example\n     * influx.alterRetentionPolicy('7d', {\n     *  duration: '7d',\n     *  replication: 1,\n     *  default: true\n     * })\n     */\n    alterRetentionPolicy(name, options) {\n        const q = `alter retention policy ${grammar.escape.quoted(name)} on ` +\n            grammar.escape.quoted(options.database || this._defaultDB()) +\n            ` duration ${options.duration} replication ${options.replication}` +\n            (options.isDefault ? \" default\" : \"\");\n        return this._pool\n            .json(this._getQueryOpts({ q }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Deletes a retention policy and associated data. Note that the data will\n     * not be immediately destroyed, and will hang around until Influx's\n     * bi-hourly cron.\n     *\n     * @param name The retention policy name\n     * @param [database] Database name that the policy lives in,\n     *     uses the default database if not provided.\n     * @return\n     * @example\n     * influx.dropRetentionPolicy('7d')\n     */\n    dropRetentionPolicy(name, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop retention policy ${grammar.escape.quoted(name)} ` +\n                `on ${grammar.escape.quoted(database)}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * Shows retention policies on the database\n     *\n     * @param [database] The database to list policies on, uses the\n     *     default database if not provided.\n     * @return\n     * @example\n     * influx.showRetentionPolicies().then(policies => {\n     *   expect(policies.slice()).to.deep.equal([\n     *     {\n     *       name: 'autogen',\n     *       duration: '0s',\n     *       shardGroupDuration: '168h0m0s',\n     *       replicaN: 1,\n     *       default: true,\n     *     },\n     *     {\n     *       name: '7d',\n     *       duration: '168h0m0s',\n     *       shardGroupDuration: '24h0m0s',\n     *       replicaN: 1,\n     *       default: false,\n     *     },\n     *   ])\n     * })\n     */\n    showRetentionPolicies(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `show retention policies on ${grammar.escape.quoted(database)}`,\n        }, \"GET\"))\n            .then((result) => parseSingle(result));\n    }\n    /**\n     * Shows shards on the database\n     *\n     * @param [database] The database to list policies on, uses the\n     *     default database if not provided.\n     * @return\n     * @example\n     * influx.showShards().then(shards => {\n     *   expect(shards.slice()).to.deep.equal([\n     *     {\n     *\t\tid: 1\n     *\t\tdatabase: 'database',\n     *\t\tretention_policy: 'autogen',\n     *\t\tshard_group: 1,\n     *\t\tstart_time: '2019-05-06T00:00:00Z',\n     *\t\tend_time: '2019-05-13T00:00:00Z',\n     *\t\texpiry_time: '2019-05-13T00:00:00Z',\n     *\t\towners: null,\n     *     },\n     *   ])\n     * })\n     */\n    showShards(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: \"show shards \",\n        }, \"GET\"))\n            .then((result) => parseSingle(result).filter(function (i) {\n            return i.database === database;\n        }));\n    }\n    /**\n     * Drops a shard with the provided number.\n     * @param shard_id\n     * @return\n     * @example\n     * influx.dropShard(3)\n     */\n    dropShard(shard_id) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop shard ${shard_id}`,\n        }, \"POST\"))\n            .then(assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n     * WritePoints sends a list of points together in a batch to InfluxDB. In\n     * each point you must specify the measurement name to write into as well\n     * as a list of tag and field values. Optionally, you can specify the\n     * time to tag that point at, defaulting to the current time.\n     *\n     * If you defined a schema for the measurement in the options you passed\n     * to `new Influx(options)`, we'll use that to make sure that types get\n     * cast correctly and that there are no extraneous fields or columns.\n     *\n     * For best performance, it's recommended that you batch your data into\n     * sets of a couple thousand records before writing it. In the future we'll\n     * have some utilities within node-influx to make this easier.\n     *\n     * ---\n     *\n     * A note when using manually-specified times and precisions: by default\n     * we write using the `ms` precision since that's what JavaScript gives us.\n     * You can adjust this. However, there is some special behaviour if you\n     * manually specify a timestamp in your points:\n     *  - if you specify the timestamp as a Date object, we'll convert it to\n     *    milliseconds and manipulate it as needed to get the right precision\n     *  - if provide a INanoDate as returned from {@link toNanoTime} or the\n     *    results from an Influx query, we'll be able to pull the precise\n     *    nanosecond timestamp and manipulate it to get the right precision\n     *  - if you provide a string or number as the timestamp, we'll pass it\n     *    straight into Influx.\n     *\n     * Please see the IPoint and IWriteOptions types for a\n     * full list of possible options.\n     *\n     * @param points\n     * @param [options]\n     * @return\n     * @example\n     * // write a point into the default database with\n     * // the default retention policy.\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     *\n     * // you can manually specify the database,\n     * // retention policy, and time precision:\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *     timestamp: getLastRecordedTime(),\n     *   }\n     * ], {\n     *   database: 'my_db',\n     *   retentionPolicy: '1d',\n     *   precision: 's'\n     * })\n     */\n    writePoints(points, options = {}) {\n        const { database = this._defaultDB(), precision = \"n\", retentionPolicy, } = options;\n        let payload = \"\";\n        points.forEach((point) => {\n            const { measurement, tags, fieldsPairs, tagsNames, castedTimestamp } = this.parsePoint(point, { database, precision });\n            payload += (payload.length > 0 ? \"\\n\" : \"\") + measurement;\n            for (let tagsName of tagsNames) {\n                payload +=\n                    \",\" +\n                        grammar.escape.tag(tagsName) +\n                        \"=\" +\n                        grammar.escape.tag(tags[tagsName]);\n            }\n            for (let i = 0; i < fieldsPairs.length; i += 1) {\n                payload +=\n                    (i === 0 ? \" \" : \",\") +\n                        grammar.escape.tag(fieldsPairs[i][0]) +\n                        \"=\" +\n                        fieldsPairs[i][1];\n            }\n            if (castedTimestamp !== undefined) {\n                payload += \" \" + castedTimestamp;\n            }\n        });\n        return this._pool.discard({\n            body: payload,\n            method: \"POST\",\n            path: \"/write\",\n            query: {\n                db: database,\n                p: this._options.password,\n                precision,\n                rp: retentionPolicy,\n                u: this._options.username,\n            },\n        });\n    }\n    /**\n     * ParsePoint will perform the coercions/schema checks and return the data\n     * required for writing a point. This will throw an error if a schema check\n     * or coercion fails. This can be useful for flagging or \"throwing out\" bad\n     * points in a batch write to prevent the entire batch from getting aborted\n     *\n     * ---\n     *\n     * A note when using this function, {@link InfluxDB#writePoints} will still perform\n     * the same checks, so any pre-processed data will be checked for validity twice which\n     * has potential performance implications on large data sets\n     *\n     * @param point\n     * @param [options]\n     * @return\n     * @example\n     * // parse a point as if it is getting written to the default\n     * // databse with the default time precision\n     * influx.parsePoint({\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     * })\n     *\n     * // you can manually specify the database and time precision\n     * influx.parsePoint({\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     * }, {\n     *   precision: 's',\n     *   database: 'my_db'\n     * })\n     *\n     * // if an error occurs, you can catch the error with try...catch\n     * try {\n     *   influx.parsePoint({\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com', myExtraneousTag: 'value' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage(), myExtraneousField: 'value' },\n     *   })\n     * } catch(err) {\n     *   handleError(err);\n     * }\n     */\n    parsePoint(point, options = {}) {\n        const { database = this._defaultDB(), precision = \"n\" } = options;\n        const { fields = {}, tags = {}, measurement, timestamp } = point;\n        const schema = this._schema[database] && this._schema[database][measurement];\n        const fieldsPairs = schema\n            ? schema.coerceFields(fields)\n            : coerceBadly(fields);\n        const tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\n        const castedTimestamp = timestamp && grammar.castTimestamp(timestamp, precision);\n        return {\n            fields,\n            tags,\n            measurement,\n            timestamp,\n            fieldsPairs,\n            tagsNames,\n            castedTimestamp,\n        };\n    }\n    /**\n     * WriteMeasurement functions similarly to {@link InfluxDB#writePoints}, but\n     * it automatically fills in the `measurement` value for all points for you.\n     *\n     * @param measurement\n     * @param points\n     * @param [options]\n     * @return\n     * @example\n     * influx.writeMeasurement('perf', [\n     *   {\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     */\n    writeMeasurement(measurement, points, options = {}) {\n        points = points.map((p) => (Object.assign({ measurement }, p)));\n        return this.writePoints(points, options);\n    }\n    /**\n     * .query() runs a query (or list of queries), and returns the results in a\n     * friendly format, {@link IResults}. If you run multiple queries, an array of results\n     * will be returned, otherwise a single result (array of objects) will be returned.\n     *\n     * @param query\n     * @param [options]\n     * @return result(s)\n     * @example\n     * influx.query('select * from perf').then(results => {\n     *   console.log(results)\n     * })\n     */\n    query(query, options = {}) {\n        if (Array.isArray(query)) {\n            query = query.join(\";\");\n        }\n        // If the consumer asked explicitly for nanosecond precision parsing,\n        // remove that to cause Influx to give us ISO dates that\n        // we can parse correctly.\n        if (options.precision === \"n\") {\n            options = Object.assign({}, options); // Avoid mutating\n            delete options.precision;\n        }\n        return this.queryRaw(query, options).then((res) => parse(res, options.precision));\n    }\n    /**\n     * QueryRaw functions similarly to .query() but it does no fancy\n     * transformations on the returned data; it calls `JSON.parse` and returns\n     * those results verbatim.\n     *\n     * @param query\n     * @param [options]\n     * @return\n     * @example\n     * influx.queryRaw('select * from perf').then(rawData => {\n     *   console.log(rawData)\n     * })\n     */\n    queryRaw(query, options = {}) {\n        const { database = this._defaultDB(), retentionPolicy, placeholders = {}, } = options;\n        if (query instanceof Array) {\n            query = query.join(\";\");\n        }\n        return this._pool.json(this._getQueryOpts({\n            db: database,\n            epoch: options.precision,\n            q: query,\n            rp: retentionPolicy,\n            params: JSON.stringify(placeholders),\n        }));\n    }\n    /**\n     * Pings all available hosts, collecting online status and version info.\n     * @param timeout Given in milliseconds\n     * @return\n     * @example\n     * influx.ping(5000).then(hosts => {\n     *   hosts.forEach(host => {\n     *     if (host.online) {\n     *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n     *     } else {\n     *       console.log(`${host.url.host} is offline :(`)\n     *     }\n     *   })\n     * })\n     */\n    ping(timeout) {\n        let auth = undefined;\n        if (typeof this._options.username === \"string\") {\n            auth = `${this._options.username}:${this._options.password || \"\"}`;\n        }\n        return this._pool.ping(timeout, \"/ping\", auth);\n    }\n    /**\n     * Returns the default database that queries operates on. It throws if called\n     * when a default database isn't set.\n     * @private\n     */\n    _defaultDB() {\n        if (!this._options.database) {\n            throw new Error(\"Attempted to run an influx query without a default\" +\n                \" database specified or an explicit database provided.\");\n        }\n        return this._options.database;\n    }\n    /**\n     * Creates options to be passed into the pool to query databases.\n     * @private\n     */\n    _getQueryOpts(params, method = \"GET\") {\n        return {\n            method,\n            path: \"/query\",\n            query: Object.assign({ p: this._options.password, u: this._options.username }, params),\n        };\n    }\n    /**\n     * Creates specified measurement schema\n     *\n     * @private\n     * @param {ISchemaOptions} schema\n     * @memberof InfluxDB\n     */\n    _createSchema(schema) {\n        schema.database = schema.database || this._options.database;\n        if (!schema.database) {\n            throw new Error(`Schema ${schema.measurement} doesn't have a database specified,` +\n                \"and no default database is provided!\");\n        }\n        if (!this._schema[schema.database]) {\n            this._schema[schema.database] = Object.create(null);\n        }\n        this._schema[schema.database][schema.measurement] = new Schema(schema);\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "variable",
    "name": "defaultHost",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~defaultHost",
    "access": "public",
    "export": false,
    "importPath": "influx/src/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "variable",
    "name": "defaultOptions",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~defaultOptions",
    "access": "public",
    "export": false,
    "importPath": "influx/src/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "parseOptionsUrl",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~parseOptionsUrl",
    "access": "public",
    "export": false,
    "importPath": "influx/src/index.js",
    "importStyle": null,
    "description": "Parses the URL out into into a IClusterConfig object",
    "lineNumber": 28,
    "params": [
      {
        "name": "addr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 154,
    "kind": "function",
    "name": "defaults",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~defaults",
    "access": "public",
    "export": false,
    "importPath": "influx/src/index.js",
    "importStyle": null,
    "description": "Works similarly to Object.assign, but only overwrites\nproperties that resolve to undefined.",
    "lineNumber": 47,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "srcs",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "class",
    "name": "InfluxDB",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~InfluxDB",
    "access": "public",
    "export": true,
    "importPath": "influx/src/index.js",
    "importStyle": "{InfluxDB}",
    "description": "InfluxDB is the public interface to run queries against your database.\nThis is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\nqueries directly by calling methods on this class.\n\nPlease check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\nif you want help getting started!",
    "examples": [
      "const Influx = require('influx');\nconst influx = new Influx.InfluxDB({\n host: 'localhost',\n database: 'express_response_db',\n schema: [\n   {\n     measurement: 'response_times',\n     fields: {\n       path: Influx.FieldType.STRING,\n       duration: Influx.FieldType.INTEGER\n     },\n     tags: [\n       'host'\n     ]\n   }\n ]\n})",
      "// Connect over HTTPS\nconst Influx = require('influx');\nconst influx = new Influx.InfluxDB({\n host: 'myinfluxdbhost',\n port: 443,\n protocol: 'https'\n database: 'express_response_db',\n schema: [\n   {\n     measurement: 'response_times',\n     fields: {\n       path: Influx.FieldType.STRING,\n       duration: Influx.FieldType.INTEGER\n     },\n     tags: [\n       'host'\n     ]\n   }\n ]\n})\n\ninflux.writePoints([\n  {\n    measurement: 'response_times',\n    tags: { host: os.hostname() },\n    fields: { duration, path: req.path },\n  }\n]).then(() => {\n  return influx.query(`\n    select * from response_times\n    where host = $<host>\n    order by time desc\n    limit 10\n  `, {\n     placeholders: {\n       host: os.hostname()\n     }\n  })\n}).then(rows => {\n  rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n})"
    ],
    "lineNumber": 127,
    "interface": false
  },
  {
    "__docId__": 156,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#constructor",
    "access": "public",
    "description": "Connect to a single InfluxDB instance by specifying\na set of connection options.",
    "examples": [
      "const Influx = require('influx')\n\n// Connect to a single host with a DSN:\nconst influx = new Influx.InfluxDB('http://user:password@host:8086/database')",
      "const Influx = require('influx')\n\n// Connect to a single host with a full set of config details and\n// a custom schema\nconst client = new Influx.InfluxDB({\n  database: 'my_db',\n  host: 'localhost',\n  port: 8086,\n  username: 'connor',\n  password: 'pa$$w0rd',\n  schema: [\n    {\n      measurement: 'perf',\n      fields: {\n        memory_usage: Influx.FieldType.INTEGER,\n        cpu_usage: Influx.FieldType.FLOAT,\n        is_online: Influx.FieldType.BOOLEAN\n      }\n      tags: [\n        'hostname'\n      ]\n    }\n  ]\n})",
      "const Influx = require('influx')\n\n// Use a pool of several host connections and balance queries across them:\nconst client = new Influx.InfluxDB({\n  database: 'my_db',\n  username: 'connor',\n  password: 'pa$$w0rd',\n  hosts: [\n    { host: 'db1.example.com' },\n    { host: 'db2.example.com' },\n  ],\n  schema: [\n    {\n      measurement: 'perf',\n      fields: {\n        memory_usage: Influx.FieldType.INTEGER,\n        cpu_usage: Influx.FieldType.FLOAT,\n        is_online: Influx.FieldType.BOOLEAN\n      }\n      tags: [\n        'hostname'\n      ]\n    }\n  ]\n})"
    ],
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'http://root:root@127.0.0.1:8086'",
        "defaultRaw": "'http://root:root@127.0.0.1:8086'",
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "_schema",
    "memberof": "src/index.js~InfluxDB",
    "static": false,
    "longname": "src/index.js~InfluxDB#_schema",
    "access": "private",
    "description": "Map of Schema instances defining measurements in Influx.",
    "lineNumber": 198,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "_pool",
    "memberof": "src/index.js~InfluxDB",
    "static": false,
    "longname": "src/index.js~InfluxDB#_pool",
    "access": "private",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "_options",
    "memberof": "src/index.js~InfluxDB",
    "static": false,
    "longname": "src/index.js~InfluxDB#_options",
    "access": "private",
    "description": null,
    "lineNumber": 229,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "addSchema",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#addSchema",
    "access": "public",
    "description": "Adds specified schema for better fields coercing.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "ISchemaOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "createDatabase",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#createDatabase",
    "access": "public",
    "description": "Creates a new database with the provided name.",
    "examples": [
      "influx.createDatabase('mydb')"
    ],
    "lineNumber": 251,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "dropDatabase",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropDatabase",
    "access": "public",
    "description": "Deletes a database with the provided name.",
    "examples": [
      "influx.dropDatabase('mydb')"
    ],
    "lineNumber": 266,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "getDatabaseNames",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#getDatabaseNames",
    "access": "public",
    "description": "Returns array of database names. Requires cluster admin privileges.",
    "examples": [
      "influx.getDatabaseNames().then(names =>\n  console.log('My database names are: ' + names.join(', ')));"
    ],
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a list of database names"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a list of database names"
    },
    "params": []
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "getMeasurements",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#getMeasurements",
    "access": "public",
    "description": "Returns array of measurements.",
    "examples": [
      "influx.getMeasurements().then(names =>\n  console.log('My measurement names are: ' + names.join(', ')));"
    ],
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a list of measurement names"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "the database the measurement lives in, optional\n    if a default database is provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a list of measurement names"
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "getSeries",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#getSeries",
    "access": "public",
    "description": "Returns a list of all series within the target measurement, or from the\nentire database if a measurement isn't provided.",
    "examples": [
      "influx.getSeries().then(names => {\n  console.log('My series names in my_measurement are: ' + names.join(', '))\n})\n\ninflux.getSeries({\n  measurement: 'my_measurement',\n  database: 'my_db'\n}).then(names => {\n  console.log('My series names in my_measurement are: ' + names.join(', '))\n})"
    ],
    "lineNumber": 324,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a list of series names"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.measurement",
        "description": "if provided, we'll only get series\n    from within that measurement."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "the database the series lives in,\n    optional if a default database is provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a list of series names"
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "dropMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropMeasurement",
    "access": "public",
    "description": "Removes a measurement from the database.",
    "examples": [
      "influx.dropMeasurement('my_measurement')"
    ],
    "lineNumber": 346,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "the database the measurement lives in, optional\n    if a default database is provided."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "dropSeries",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropSeries",
    "access": "public",
    "description": "Removes a one or more series from InfluxDB.",
    "examples": [
      "// The following pairs of queries are equivalent: you can chose either to\n// use our builder or pass in string directly. The builder takes care\n// of escaping and most syntax handling for you.\n\ninflux.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\ninflux.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n// DROP SERIES WHERE \"cpu\" = 'cpu8'\n\ninflux.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\ninflux.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n// DROP SERIES FROM \"autogen\".\"cpu\"\n\ninflux.dropSeries({\n  measurement: m => m.name('cpu').policy('autogen'),\n  where: e => e.tag('cpu').equals.value('cpu8'),\n  database: 'my_db'\n})\n// DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'"
    ],
    "lineNumber": 379,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "getUsers",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#getUsers",
    "access": "public",
    "description": "Returns a list of users on the Influx database.",
    "examples": [
      "influx.getUsers().then(users => {\n  users.forEach(user => {\n    if (user.admin) {\n      console.log(user.user, 'is an admin!')\n    } else {\n      console.log(user.user, 'is not an admin!')\n    }\n  })\n})"
    ],
    "lineNumber": 407,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "createUser",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#createUser",
    "access": "public",
    "description": "Creates a new InfluxDB user.",
    "examples": [
      "influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n\n// make non-admins:\ninflux.createUser('not_admin', 'pa55w0rd')"
    ],
    "lineNumber": 425,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "admin",
        "description": "If true, the user will be given all\n    privileges on all databases."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "setPassword",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#setPassword",
    "access": "public",
    "description": "Sets a password for an Influx user.",
    "examples": [
      "influx.setPassword('connor', 'pa55w0rd')"
    ],
    "lineNumber": 443,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "grantPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#grantPrivilege",
    "access": "public",
    "description": "Grants a privilege to a specified user.",
    "examples": [
      "influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor"
    ],
    "lineNumber": 461,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of 'READ' or 'WRITE'"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "revokePrivilege",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#revokePrivilege",
    "access": "public",
    "description": "Removes a privilege from a specified user.",
    "examples": [
      "influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor"
    ],
    "lineNumber": 479,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of 'READ' or 'WRITE'"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "grantAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#grantAdminPrivilege",
    "access": "public",
    "description": "Grants admin privileges to a specified user.",
    "examples": [
      "influx.grantAdminPrivilege('connor')"
    ],
    "lineNumber": 494,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "revokeAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#revokeAdminPrivilege",
    "access": "public",
    "description": "Removes a admin privilege from a specified user.",
    "examples": [
      "influx.revokeAdminPrivilege('connor')"
    ],
    "lineNumber": 509,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "dropUser",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropUser",
    "access": "public",
    "description": "Removes a user from the database.",
    "examples": [
      "influx.dropUser('connor')"
    ],
    "lineNumber": 524,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "createContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#createContinuousQuery",
    "access": "public",
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.createContinuousQuery('downsample_cpu_1h', `\n  SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n  FROM \"1d\".\"perf\" GROUP BY time(1m)\n`, undefined, 'RESAMPLE FOR 7m')"
    ],
    "lineNumber": 545,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name, for later reference"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "The body of the query to run"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "resample",
        "description": "If provided, adds resample policy"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "showContinousQueries",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#showContinousQueries",
    "access": "public",
    "description": "Returns a list of continous queries in the database.",
    "examples": [
      "influx.showContinousQueries()"
    ],
    "lineNumber": 561,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "dropContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropContinuousQuery",
    "access": "public",
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.dropContinuousQuery('downsample_cpu_1h')"
    ],
    "lineNumber": 577,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "createRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#createRetentionPolicy",
    "access": "public",
    "description": "Creates a new retention policy on a database. You can read more about\n[Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\nguides/downsampling_and_retention/) on the InfluxDB website.",
    "examples": [
      "influx.createRetentionPolicy('7d', {\n duration: '7d',\n replication: 1\n})"
    ],
    "lineNumber": 609,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "Database to create the policy on,\n    uses the default database if not provided."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options.duration",
        "description": "How long data in the retention policy\n    should be stored for, should be in a format like `7d`. See details\n    [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options.replication",
        "description": "How many servers data in the series\n    should be replicated to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.isDefault",
        "description": "Whether the retention policy should\n    be the default policy on the database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "alterRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#alterRetentionPolicy",
    "access": "public",
    "description": "Alters an existing retention policy on a database.",
    "examples": [
      "influx.alterRetentionPolicy('7d', {\n duration: '7d',\n replication: 1,\n default: true\n})"
    ],
    "lineNumber": 641,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "Database to create the policy on,\n    uses the default database if not provided."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options.duration",
        "description": "How long data in the retention policy\n    should be stored for, should be in a format like `7d`. See details\n    [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options.replication",
        "description": "How many servers data in the series\n    should be replicated to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options.default",
        "description": "Whether the retention policy should\n    be the default policy on the database."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "dropRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropRetentionPolicy",
    "access": "public",
    "description": "Deletes a retention policy and associated data. Note that the data will\nnot be immediately destroyed, and will hang around until Influx's\nbi-hourly cron.",
    "examples": [
      "influx.dropRetentionPolicy('7d')"
    ],
    "lineNumber": 663,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Database name that the policy lives in,\n    uses the default database if not provided."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "showRetentionPolicies",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#showRetentionPolicies",
    "access": "public",
    "description": "Shows retention policies on the database",
    "examples": [
      "influx.showRetentionPolicies().then(policies => {\n  expect(policies.slice()).to.deep.equal([\n    {\n      name: 'autogen',\n      duration: '0s',\n      shardGroupDuration: '168h0m0s',\n      replicaN: 1,\n      default: true,\n    },\n    {\n      name: '7d',\n      duration: '168h0m0s',\n      shardGroupDuration: '24h0m0s',\n      replicaN: 1,\n      default: false,\n    },\n  ])\n})"
    ],
    "lineNumber": 698,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database to list policies on, uses the\n    default database if not provided."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "showShards",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#showShards",
    "access": "public",
    "description": "Shows shards on the database",
    "examples": [
      "influx.showShards().then(shards => {\n  expect(shards.slice()).to.deep.equal([\n    {\n\tid: 1\n\tdatabase: 'database',\n\tretention_policy: 'autogen',\n\tshard_group: 1,\n\tstart_time: '2019-05-06T00:00:00Z',\n\tend_time: '2019-05-13T00:00:00Z',\n\texpiry_time: '2019-05-13T00:00:00Z',\n\towners: null,\n    },\n  ])\n})"
    ],
    "lineNumber": 727,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database to list policies on, uses the\n    default database if not provided."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "dropShard",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#dropShard",
    "access": "public",
    "description": "Drops a shard with the provided number.",
    "examples": [
      "influx.dropShard(3)"
    ],
    "lineNumber": 743,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "shard_id",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "writePoints",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#writePoints",
    "access": "public",
    "description": "WritePoints sends a list of points together in a batch to InfluxDB. In\neach point you must specify the measurement name to write into as well\nas a list of tag and field values. Optionally, you can specify the\ntime to tag that point at, defaulting to the current time.\n\nIf you defined a schema for the measurement in the options you passed\nto `new Influx(options)`, we'll use that to make sure that types get\ncast correctly and that there are no extraneous fields or columns.\n\nFor best performance, it's recommended that you batch your data into\nsets of a couple thousand records before writing it. In the future we'll\nhave some utilities within node-influx to make this easier.\n\n---\n\nA note when using manually-specified times and precisions: by default\nwe write using the `ms` precision since that's what JavaScript gives us.\nYou can adjust this. However, there is some special behaviour if you\nmanually specify a timestamp in your points:\n - if you specify the timestamp as a Date object, we'll convert it to\n   milliseconds and manipulate it as needed to get the right precision\n - if provide a INanoDate as returned from {@link toNanoTime} or the\n   results from an Influx query, we'll be able to pull the precise\n   nanosecond timestamp and manipulate it to get the right precision\n - if you provide a string or number as the timestamp, we'll pass it\n   straight into Influx.\n\nPlease see the IPoint and IWriteOptions types for a\nfull list of possible options.",
    "examples": [
      "// write a point into the default database with\n// the default retention policy.\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])\n\n// you can manually specify the database,\n// retention policy, and time precision:\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n    timestamp: getLastRecordedTime(),\n  }\n], {\n  database: 'my_db',\n  retentionPolicy: '1d',\n  precision: 's'\n})"
    ],
    "lineNumber": 811,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "parsePoint",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#parsePoint",
    "access": "public",
    "description": "ParsePoint will perform the coercions/schema checks and return the data\nrequired for writing a point. This will throw an error if a schema check\nor coercion fails. This can be useful for flagging or \"throwing out\" bad\npoints in a batch write to prevent the entire batch from getting aborted\n\n---\n\nA note when using this function, {@link InfluxDB#writePoints} will still perform\nthe same checks, so any pre-processed data will be checked for validity twice which\nhas potential performance implications on large data sets",
    "examples": [
      "// parse a point as if it is getting written to the default\n// databse with the default time precision\ninflux.parsePoint({\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n})\n\n// you can manually specify the database and time precision\ninflux.parsePoint({\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n}, {\n  precision: 's',\n  database: 'my_db'\n})\n\n// if an error occurs, you can catch the error with try...catch\ntry {\n  influx.parsePoint({\n    measurement: 'perf',\n    tags: { host: 'box1.example.com', myExtraneousTag: 'value' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage(), myExtraneousField: 'value' },\n  })\n} catch(err) {\n  handleError(err);\n}"
    ],
    "lineNumber": 893,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "{\"fields\": *, \"tags\": *, \"measurement\": *, \"timestamp\": *, \"fieldsPairs\": *, \"tagsNames\": *, \"castedTimestamp\": *}"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "writeMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#writeMeasurement",
    "access": "public",
    "description": "WriteMeasurement functions similarly to {@link InfluxDB#writePoints}, but\nit automatically fills in the `measurement` value for all points for you.",
    "examples": [
      "influx.writeMeasurement('perf', [\n  {\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])"
    ],
    "lineNumber": 928,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "query",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#query",
    "access": "public",
    "description": ".query() runs a query (or list of queries), and returns the results in a\nfriendly format, {@link IResults}. If you run multiple queries, an array of results\nwill be returned, otherwise a single result (array of objects) will be returned.",
    "examples": [
      "influx.query('select * from perf').then(results => {\n  console.log(results)\n})"
    ],
    "lineNumber": 945,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "result(s)"
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "queryRaw",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#queryRaw",
    "access": "public",
    "description": "QueryRaw functions similarly to .query() but it does no fancy\ntransformations on the returned data; it calls `JSON.parse` and returns\nthose results verbatim.",
    "examples": [
      "influx.queryRaw('select * from perf').then(rawData => {\n  console.log(rawData)\n})"
    ],
    "lineNumber": 971,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "ping",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#ping",
    "access": "public",
    "description": "Pings all available hosts, collecting online status and version info.",
    "examples": [
      "influx.ping(5000).then(hosts => {\n  hosts.forEach(host => {\n    if (host.online) {\n      console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n    } else {\n      console.log(`${host.url.host} is offline :(`)\n    }\n  })\n})"
    ],
    "lineNumber": 999,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Given in milliseconds"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "_defaultDB",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#_defaultDB",
    "access": "private",
    "description": "Returns the default database that queries operates on. It throws if called\nwhen a default database isn't set.",
    "lineNumber": 1011,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "_getQueryOpts",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#_getQueryOpts",
    "access": "private",
    "description": "Creates options to be passed into the pool to query databases.",
    "lineNumber": 1022,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "method",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "GET",
        "defaultValue": "GET"
      }
    ],
    "return": {
      "types": [
        "{\"method\": *, \"path\": string, \"query\": *}"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "_createSchema",
    "memberof": "src/index.js~InfluxDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~InfluxDB#_createSchema",
    "access": "private",
    "description": "Creates specified measurement schema",
    "lineNumber": 1036,
    "params": [
      {
        "nullable": null,
        "types": [
          "ISchemaOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 194,
    "kind": "file",
    "name": "src/pool.js",
    "content": "import { ExponentialBackoff } from \"./backoff/exponential\";\nimport { Host } from \"./host\";\nimport * as http from \"http\";\nimport * as https from \"https\";\nimport * as querystring from \"querystring\";\n/**\n * Status codes that will cause a host to be marked as 'failed' if we get\n * them from a request to Influx.\n * @type {Array}\n */\nconst resubmitErrorCodes = [\n    \"ETIMEDOUT\",\n    \"ESOCKETTIMEDOUT\",\n    \"ECONNRESET\",\n    \"ECONNREFUSED\",\n    \"EHOSTUNREACH\",\n];\n/**\n * An ServiceNotAvailableError is returned as an error from requests that\n * result in a > 500 error code.\n */\nexport class ServiceNotAvailableError extends Error {\n    constructor(message) {\n        super();\n        this.message = message;\n        Object.setPrototypeOf(this, ServiceNotAvailableError.prototype);\n    }\n}\n/**\n * An RequestError is returned as an error from requests that\n * result in a 300 <= error code <= 500.\n */\nexport class RequestError extends Error {\n    constructor(req, res, body) {\n        super();\n        this.req = req;\n        this.res = res;\n        this.message = `A ${res.statusCode} ${res.statusMessage} error occurred: ${body}`;\n        Object.setPrototypeOf(this, RequestError.prototype);\n    }\n    static Create(req, res, callback) {\n        let body = \"\";\n        res.on(\"data\", (str) => {\n            body += str.toString();\n        });\n        res.on(\"end\", () => callback(new RequestError(req, res, body)));\n    }\n}\n/**\n * Creates a function generation that returns a wrapper which only allows\n * through the first call of any function that it generated.\n */\nfunction doOnce() {\n    let handled = false;\n    return (fn) => {\n        return (arg) => {\n            if (handled) {\n                return;\n            }\n            handled = true;\n            fn(arg);\n        };\n    };\n}\nfunction setToArray(itemSet) {\n    const output = [];\n    itemSet.forEach((value) => {\n        output.push(value);\n    });\n    return output;\n}\nconst request = (options, callback) => {\n    if (options.protocol === \"https:\") {\n        return https.request(options, callback);\n    }\n    return http.request(options, callback);\n};\n/**\n *\n * The Pool maintains a list available Influx hosts and dispatches requests\n * to them. If there are errors connecting to hosts, it will disable that\n * host for a period of time.\n */\nexport class Pool {\n    /**\n     * Creates a new Pool instance.\n     * @param {IPoolOptions} options\n     */\n    constructor(options) {\n        this._options = Object.assign({ backoff: new ExponentialBackoff({\n                initial: 300,\n                max: 10 * 1000,\n                random: 1,\n            }), maxRetries: 2, requestTimeout: 30 * 1000 }, options);\n        this._index = 0;\n        this._hostsAvailable = new Set();\n        this._hostsDisabled = new Set();\n        this._timeout = this._options.requestTimeout;\n    }\n    /**\n     * Returns a list of currently active hosts.\n     * @return {Host[]}\n     */\n    getHostsAvailable() {\n        return setToArray(this._hostsAvailable);\n    }\n    /**\n     * Returns a list of hosts that are currently disabled due to network\n     * errors.\n     * @return {Host[]}\n     */\n    getHostsDisabled() {\n        return setToArray(this._hostsDisabled);\n    }\n    /**\n     * Inserts a new host to the pool.\n     */\n    addHost(url, options = {}) {\n        const host = new Host(url, this._options.backoff.reset(), options);\n        this._hostsAvailable.add(host);\n        return host;\n    }\n    /**\n     * Returns true if there's any host available to by queried.\n     * @return {Boolean}\n     */\n    hostIsAvailable() {\n        return this._hostsAvailable.size > 0;\n    }\n    /**\n     * Makes a request and calls back with the response, parsed as JSON.\n     * An error is returned on a non-2xx status code or on a parsing exception.\n     */\n    json(options) {\n        return this.text(options).then((res) => JSON.parse(res));\n    }\n    /**\n     * Makes a request and resolves with the plain text response,\n     * if possible. An error is raised on a non-2xx status code.\n     */\n    text(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                let output = \"\";\n                res.on(\"data\", (str) => {\n                    output += str.toString();\n                });\n                res.on(\"end\", () => resolve(output));\n            });\n        });\n    }\n    /**\n     * Makes a request and discards any response body it receives.\n     * An error is returned on a non-2xx status code.\n     */\n    discard(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                res.on(\"data\", () => {\n                    /* ignore */\n                });\n                res.on(\"end\", () => resolve());\n            });\n        });\n    }\n    /**\n     * Ping sends out a request to all available Influx servers, reporting on\n     * their response time and version number.\n     */\n    ping(timeout, path = \"/ping\", auth = undefined) {\n        const todo = [];\n        setToArray(this._hostsAvailable)\n            .concat(setToArray(this._hostsDisabled))\n            .forEach((host) => {\n            const start = Date.now();\n            const url = host.url;\n            const once = doOnce();\n            return todo.push(new Promise((resolve) => {\n                const headers = {};\n                if (typeof auth !== \"undefined\") {\n                    const encodedAuth = Buffer.from(auth).toString(\"base64\");\n                    headers[\"Authorization\"] = `Basic ${encodedAuth}`;\n                }\n                const req = request(Object.assign({ hostname: url.hostname, method: \"GET\", path, port: Number(url.port), protocol: url.protocol, timeout, headers: headers }, host.options), once((res) => {\n                    resolve({\n                        url,\n                        res: res.resume(),\n                        online: res.statusCode < 300,\n                        rtt: Date.now() - start,\n                        version: res.headers[\"x-influxdb-version\"],\n                    });\n                }));\n                const fail = once(() => {\n                    req.abort();\n                    resolve({\n                        online: false,\n                        res: null,\n                        rtt: Infinity,\n                        url,\n                        version: null,\n                    });\n                });\n                // Support older Nodes and polyfills which don't allow .timeout() in\n                // the request options, wrapped in a conditional for even worse\n                // polyfills. See: https://github.com/node-influx/node-influx/issues/221\n                if (typeof req.setTimeout === \"function\") {\n                    req.setTimeout(timeout, () => {\n                        fail.call(fail, arguments);\n                    }); // Tslint:disable-line\n                }\n                req.on(\"timeout\", fail);\n                req.on(\"error\", fail);\n                req.end();\n            }));\n        });\n        return Promise.all(todo);\n    }\n    /**\n     * Makes a request and calls back with the IncomingMessage stream,\n     * if possible. An error is returned on a non-2xx status code.\n     */\n    stream(options, callback) {\n        if (!this.hostIsAvailable()) {\n            return callback(new ServiceNotAvailableError(\"No host available\"), null);\n        }\n        const once = doOnce();\n        const host = this._getHost();\n        let path = host.url.pathname === \"/\" ? \"\" : host.url.pathname;\n        path += options.path;\n        if (options.query) {\n            path += \"?\" + querystring.stringify(options.query);\n        }\n        const req = request(Object.assign({ headers: {\n                \"content-length\": options.body ? Buffer.from(options.body).length : 0,\n            }, hostname: host.url.hostname, method: options.method, path, port: Number(host.url.port), protocol: host.url.protocol, timeout: this._timeout }, host.options), once((res) => {\n            res.setEncoding(\"utf8\");\n            if (res.statusCode >= 500) {\n                res.on(\"data\", () => {\n                    /* ignore */\n                });\n                res.on(\"end\", () => {\n                    return this._handleRequestError(new ServiceNotAvailableError(res.statusMessage), host, options, callback);\n                });\n                return;\n            }\n            if (res.statusCode >= 300) {\n                return RequestError.Create(req, res, (err) => callback(err, res));\n            }\n            host.success();\n            return callback(undefined, res);\n        }));\n        // Handle network or HTTP parsing errors:\n        req.on(\"error\", once((err) => {\n            this._handleRequestError(err, host, options, callback);\n        }));\n        // Handle timeouts:\n        req.on(\"timeout\", once(() => {\n            req.abort();\n            this._handleRequestError(new ServiceNotAvailableError(\"Request timed out\"), host, options, callback);\n        }));\n        // Support older Nodes and polyfills which don't allow .timeout() in the\n        // request options, wrapped in a conditional for even worse polyfills. See:\n        // https://github.com/node-influx/node-influx/issues/221\n        if (typeof req.setTimeout === \"function\") {\n            req.setTimeout(host.options.timeout || this._timeout); // Tslint:disable-line\n        }\n        // Write out the body:\n        if (options.body) {\n            req.write(options.body);\n        }\n        req.end();\n    }\n    /**\n     * Returns the next available host for querying.\n     * @return {Host}\n     */\n    _getHost() {\n        const available = setToArray(this._hostsAvailable);\n        const host = available[this._index];\n        this._index = (this._index + 1) % available.length;\n        return host;\n    }\n    /**\n     * Re-enables the provided host, returning it to the pool to query.\n     * @param  {Host} host\n     */\n    _enableHost(host) {\n        this._hostsDisabled.delete(host);\n        this._hostsAvailable.add(host);\n    }\n    /**\n     * Disables the provided host, removing it from the query pool. It will be\n     * re-enabled after a backoff interval\n     */\n    _disableHost(host) {\n        const delay = host.fail();\n        if (delay > 0) {\n            this._hostsAvailable.delete(host);\n            this._hostsDisabled.add(host);\n            this._index %= Math.max(1, this._hostsAvailable.size);\n            setTimeout(() => this._enableHost(host), delay);\n        }\n    }\n    _handleRequestError(err, host, options, callback) {\n        if (!(err instanceof ServiceNotAvailableError) &&\n            !resubmitErrorCodes.includes(err.code)) {\n            return callback(err, null);\n        }\n        this._disableHost(host);\n        const retries = options.retries || 0;\n        if (retries < this._options.maxRetries && this.hostIsAvailable()) {\n            options.retries = retries + 1;\n            return this.stream(options, callback);\n        }\n        callback(err, null);\n    }\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/pool.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 195,
    "kind": "variable",
    "name": "resubmitErrorCodes",
    "memberof": "src/pool.js",
    "static": true,
    "longname": "src/pool.js~resubmitErrorCodes",
    "access": "public",
    "export": false,
    "importPath": "influx/src/pool.js",
    "importStyle": null,
    "description": "Status codes that will cause a host to be marked as 'failed' if we get\nthem from a request to Influx.",
    "lineNumber": 11,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 196,
    "kind": "class",
    "name": "ServiceNotAvailableError",
    "memberof": "src/pool.js",
    "static": true,
    "longname": "src/pool.js~ServiceNotAvailableError",
    "access": "public",
    "export": true,
    "importPath": "influx/src/pool.js",
    "importStyle": "{ServiceNotAvailableError}",
    "description": "An ServiceNotAvailableError is returned as an error from requests that\nresult in a > 500 error code.",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 197,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/pool.js~ServiceNotAvailableError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~ServiceNotAvailableError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "message",
    "memberof": "src/pool.js~ServiceNotAvailableError",
    "static": false,
    "longname": "src/pool.js~ServiceNotAvailableError#message",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "class",
    "name": "RequestError",
    "memberof": "src/pool.js",
    "static": true,
    "longname": "src/pool.js~RequestError",
    "access": "public",
    "export": true,
    "importPath": "influx/src/pool.js",
    "importStyle": "{RequestError}",
    "description": "An RequestError is returned as an error from requests that\nresult in a 300 <= error code <= 500.",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 200,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/pool.js~RequestError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~RequestError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "req",
    "memberof": "src/pool.js~RequestError",
    "static": false,
    "longname": "src/pool.js~RequestError#req",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "member",
    "name": "res",
    "memberof": "src/pool.js~RequestError",
    "static": false,
    "longname": "src/pool.js~RequestError#res",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "member",
    "name": "message",
    "memberof": "src/pool.js~RequestError",
    "static": false,
    "longname": "src/pool.js~RequestError#message",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "Create",
    "memberof": "src/pool.js~RequestError",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pool.js~RequestError.Create",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "req",
        "types": [
          "*"
        ]
      },
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "function",
    "name": "doOnce",
    "memberof": "src/pool.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pool.js~doOnce",
    "access": "public",
    "export": false,
    "importPath": "influx/src/pool.js",
    "importStyle": null,
    "description": "Creates a function generation that returns a wrapper which only allows\nthrough the first call of any function that it generated.",
    "lineNumber": 53,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "setToArray",
    "memberof": "src/pool.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pool.js~setToArray",
    "access": "public",
    "export": false,
    "importPath": "influx/src/pool.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "itemSet",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "function",
    "name": "request",
    "memberof": "src/pool.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pool.js~request",
    "access": "public",
    "export": false,
    "importPath": "influx/src/pool.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "class",
    "name": "Pool",
    "memberof": "src/pool.js",
    "static": true,
    "longname": "src/pool.js~Pool",
    "access": "public",
    "export": true,
    "importPath": "influx/src/pool.js",
    "importStyle": "{Pool}",
    "description": "\nThe Pool maintains a list available Influx hosts and dispatches requests\nto them. If there are errors connecting to hosts, it will disable that\nhost for a period of time.",
    "lineNumber": 84,
    "interface": false
  },
  {
    "__docId__": 209,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#constructor",
    "access": "public",
    "description": "Creates a new Pool instance.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "IPoolOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "_options",
    "memberof": "src/pool.js~Pool",
    "static": false,
    "longname": "src/pool.js~Pool#_options",
    "access": "private",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "_index",
    "memberof": "src/pool.js~Pool",
    "static": false,
    "longname": "src/pool.js~Pool#_index",
    "access": "private",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "_hostsAvailable",
    "memberof": "src/pool.js~Pool",
    "static": false,
    "longname": "src/pool.js~Pool#_hostsAvailable",
    "access": "private",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "_hostsDisabled",
    "memberof": "src/pool.js~Pool",
    "static": false,
    "longname": "src/pool.js~Pool#_hostsDisabled",
    "access": "private",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "_timeout",
    "memberof": "src/pool.js~Pool",
    "static": false,
    "longname": "src/pool.js~Pool#_timeout",
    "access": "private",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "getHostsAvailable",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#getHostsAvailable",
    "access": "public",
    "description": "Returns a list of currently active hosts.",
    "lineNumber": 104,
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "getHostsDisabled",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#getHostsDisabled",
    "access": "public",
    "description": "Returns a list of hosts that are currently disabled due to network\nerrors.",
    "lineNumber": 112,
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "addHost",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#addHost",
    "access": "public",
    "description": "Inserts a new host to the pool.",
    "lineNumber": 118,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "hostIsAvailable",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#hostIsAvailable",
    "access": "public",
    "description": "Returns true if there's any host available to by queried.",
    "lineNumber": 127,
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "json",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#json",
    "access": "public",
    "description": "Makes a request and calls back with the response, parsed as JSON.\nAn error is returned on a non-2xx status code or on a parsing exception.",
    "lineNumber": 134,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "text",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#text",
    "access": "public",
    "description": "Makes a request and resolves with the plain text response,\nif possible. An error is raised on a non-2xx status code.",
    "lineNumber": 141,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "discard",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#discard",
    "access": "public",
    "description": "Makes a request and discards any response body it receives.\nAn error is returned on a non-2xx status code.",
    "lineNumber": 159,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "ping",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#ping",
    "access": "public",
    "description": "Ping sends out a request to all available Influx servers, reporting on\ntheir response time and version number.",
    "lineNumber": 176,
    "params": [
      {
        "name": "timeout",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "/ping",
        "defaultValue": "/ping"
      },
      {
        "name": "auth",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "stream",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#stream",
    "access": "public",
    "description": "Makes a request and calls back with the IncomingMessage stream,\nif possible. An error is returned on a non-2xx status code.",
    "lineNumber": 228,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "_getHost",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#_getHost",
    "access": "private",
    "description": "Returns the next available host for querying.",
    "lineNumber": 283,
    "return": {
      "nullable": null,
      "types": [
        "Host"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "_enableHost",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#_enableHost",
    "access": "private",
    "description": "Re-enables the provided host, returning it to the pool to query.",
    "lineNumber": 293,
    "params": [
      {
        "nullable": null,
        "types": [
          "Host"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "_disableHost",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#_disableHost",
    "access": "private",
    "description": "Disables the provided host, removing it from the query pool. It will be\nre-enabled after a backoff interval",
    "lineNumber": 301,
    "params": [
      {
        "name": "host",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "_handleRequestError",
    "memberof": "src/pool.js~Pool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/pool.js~Pool#_handleRequestError",
    "access": "private",
    "description": null,
    "lineNumber": 310,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "host",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 230,
    "kind": "file",
    "name": "src/results.js",
    "content": "import { isoOrTimeToDate } from \"./grammar\";\n/**\n * A ResultError is thrown when a query generates errorful results from Influx.\n */\nexport class ResultError extends Error {\n    constructor(message) {\n        super();\n        this.message = `Error from InfluxDB: ${message}`;\n    }\n}\nfunction groupMethod(matcher) {\n    // We do a tiny bit of 'custom' deep equality checking here, taking\n    // advantage of the fact that the tag keys are consistent across all\n    // series results. This lets us match groupings much more efficiently,\n    // ~6000x faster than the fastest vanilla equality checker (lodash)\n    // when operating on large (~100,000 grouping) sets.\n    const srcKeys = this.groupsTagsKeys;\n    const dstKeys = Object.keys(matcher);\n    if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\n        return [];\n    }\n    L: for (let row of this.groupRows) {\n        // eslint-disable-line no-labels\n        for (let src of srcKeys) {\n            if (row.tags[src] !== matcher[src]) {\n                continue L; // eslint-disable-line no-labels\n            }\n        }\n        return row.rows;\n    }\n    return [];\n}\nfunction groupsMethod() {\n    return this.groupRows;\n}\n/**\n * Inner parsing function which unpacks the series into a table and attaches\n * methods to the array. This is quite optimized and a bit of a mess to read,\n * but it's all fairly easy procedural logic.\n *\n * We do this instead of subclassing Array since subclassing has some\n * undesirable side-effects. For example, calling .slice() on the array\n * makes it impossible to preserve groups as would be necessary if it's\n * subclassed.\n */\nfunction parseInner(series = [], precision) {\n    const results = [];\n    results.groupsTagsKeys =\n        series.length && series[0].tags ? Object.keys(series[0].tags) : [];\n    const tags = results.groupsTagsKeys;\n    let nextGroup = [];\n    results.groupRows = new Array(series.length); // Tslint:disable-line\n    for (let i = 0; i < series.length; i += 1, results.length) {\n        const { columns = [], values = [] } = series[i];\n        for (let value of values) {\n            const obj = {};\n            for (let j = 0; j < columns.length; j += 1) {\n                if (columns[j] === \"time\") {\n                    obj.time = isoOrTimeToDate(value[j], precision);\n                }\n                else {\n                    obj[columns[j]] = value[j];\n                }\n            }\n            for (let tag of tags) {\n                obj[tag] = series[i].tags[tag];\n            }\n            results.push(obj);\n            nextGroup.push(obj);\n        }\n        results.groupRows[i] = {\n            name: series[i].name,\n            rows: nextGroup,\n            tags: series[i].tags || {},\n        };\n        nextGroup = [];\n    }\n    results.group = groupMethod;\n    results.groups = groupsMethod;\n    return results;\n}\n/**\n * Checks if there are any errors in the IResponse and, if so, it throws them.\n * @private\n * @throws {ResultError}\n */\nexport function assertNoErrors(res) {\n    for (let result of res.results) {\n        const { error } = result;\n        if (error) {\n            throw new ResultError(error);\n        }\n    }\n    return res;\n}\n/**\n * From parses out a response to a result or list of responses.\n * There are three situations we cover here:\n *  1. A single query without groups, like `select * from myseries`\n *  2. A single query with groups, generated with a `group by` statement\n *     which groups by series *tags*, grouping by times is case (1)\n *  3. Multiple queries of types 1 and 2\n * @private\n */\nexport function parse(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length === 1) {\n        // Normalize case 3\n        return parseInner(res.results[0].series, precision);\n    }\n    return res.results.map((result) => parseInner(result.series, precision));\n}\n/**\n * ParseSingle asserts that the response contains a single result,\n * and returns that result.\n * @throws {Error} if the number of results is not exactly one\n * @private\n */\nexport function parseSingle(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length !== 1) {\n        throw new Error(\"node-influx expected the results length to equal 1, but \" +\n            `it was ${0}. Please report this here: https://git.io/influx-err`);\n    }\n    return parseInner(res.results[0].series, precision);\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/results.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 231,
    "kind": "class",
    "name": "ResultError",
    "memberof": "src/results.js",
    "static": true,
    "longname": "src/results.js~ResultError",
    "access": "public",
    "export": true,
    "importPath": "influx/src/results.js",
    "importStyle": "{ResultError}",
    "description": "A ResultError is thrown when a query generates errorful results from Influx.",
    "lineNumber": 5,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 232,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/results.js~ResultError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/results.js~ResultError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "message",
    "memberof": "src/results.js~ResultError",
    "static": false,
    "longname": "src/results.js~ResultError#message",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 234,
    "kind": "function",
    "name": "groupMethod",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~groupMethod",
    "access": "public",
    "export": false,
    "importPath": "influx/src/results.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "matcher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 235,
    "kind": "function",
    "name": "groupsMethod",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~groupsMethod",
    "access": "public",
    "export": false,
    "importPath": "influx/src/results.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 236,
    "kind": "function",
    "name": "parseInner",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~parseInner",
    "access": "public",
    "export": false,
    "importPath": "influx/src/results.js",
    "importStyle": null,
    "description": "Inner parsing function which unpacks the series into a table and attaches\nmethods to the array. This is quite optimized and a bit of a mess to read,\nbut it's all fairly easy procedural logic.\n\nWe do this instead of subclassing Array since subclassing has some\nundesirable side-effects. For example, calling .slice() on the array\nmakes it impossible to preserve groups as would be necessary if it's\nsubclassed.",
    "lineNumber": 46,
    "params": [
      {
        "name": "series",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 237,
    "kind": "function",
    "name": "assertNoErrors",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~assertNoErrors",
    "access": "private",
    "export": true,
    "importPath": "influx/src/results.js",
    "importStyle": "{assertNoErrors}",
    "description": "Checks if there are any errors in the IResponse and, if so, it throws them.",
    "lineNumber": 87,
    "throws": [
      {
        "types": [
          "ResultError"
        ],
        "description": ""
      }
    ],
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "function",
    "name": "parse",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~parse",
    "access": "private",
    "export": true,
    "importPath": "influx/src/results.js",
    "importStyle": "{parse}",
    "description": "From parses out a response to a result or list of responses.\nThere are three situations we cover here:\n 1. A single query without groups, like `select * from myseries`\n 2. A single query with groups, generated with a `group by` statement\n    which groups by series *tags*, grouping by times is case (1)\n 3. Multiple queries of types 1 and 2",
    "lineNumber": 105,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "function",
    "name": "parseSingle",
    "memberof": "src/results.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/results.js~parseSingle",
    "access": "private",
    "export": true,
    "importPath": "influx/src/results.js",
    "importStyle": "{parseSingle}",
    "description": "ParseSingle asserts that the response contains a single result,\nand returns that result.",
    "lineNumber": 119,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the number of results is not exactly one"
      }
    ],
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "file",
    "name": "src/schema.js",
    "content": "import { escape, FieldType, isNumeric } from \"./grammar\";\n/**\n * The Schema provides information and utilities for an InfluxDB measurement.\n * @private\n */\nexport class Schema {\n    constructor(options) {\n        this.options = options;\n        this._tagHash = {};\n        // FieldNames are sorted for performance: when coerceFields is run the\n        // fields will be added to the output in order.\n        this._fieldNames = Object.keys(options.fields).sort();\n        options.tags.forEach((tag) => {\n            this._tagHash[tag] = true;\n        });\n    }\n    /**\n     * CoerceFields converts a map of field values to a strings which\n     * can be injected into the line protocol without further escaping.\n     * The output is given in [key, value] pairs.\n     */\n    coerceFields(fields) {\n        let consumed = 0;\n        const output = [];\n        this._fieldNames.forEach((field) => {\n            if (!fields.hasOwnProperty(field)) {\n                return;\n            }\n            const value = fields[field];\n            const typ = typeof value;\n            consumed += 1;\n            if (value === null || value === undefined) {\n                return;\n            }\n            let coerced;\n            switch (this.options.fields[field]) {\n                case FieldType.STRING:\n                    coerced = escape.quoted(String(value));\n                    break;\n                case FieldType.INTEGER:\n                    if (typ !== \"number\" && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this._ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(Math.floor(value)) + \"i\";\n                    break;\n                case FieldType.FLOAT:\n                    if (typ !== \"number\" && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this._ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(value);\n                    break;\n                case FieldType.BOOLEAN:\n                    if (typ !== \"boolean\") {\n                        throw new Error(`Expected boolean value for ${this._ref(field)}, but got a ${typ}!`);\n                    }\n                    coerced = value ? \"T\" : \"F\";\n                    break;\n                default:\n                    throw new Error(`Unknown field type ${this.options.fields[field]} for ${field} in ` +\n                        `${this._ref()}. Please ensure that your configuration is correct.`);\n            }\n            output.push([field, coerced]);\n        });\n        const keys = Object.keys(fields);\n        if (consumed !== keys.length) {\n            const extraneous = keys.filter((f) => !this._fieldNames.includes(f));\n            throw new Error(\"Extraneous fields detected for writing InfluxDB point in \" +\n                `${this._ref()}: \\`${extraneous.join(\"`, `\")}\\`.`);\n        }\n        return output;\n    }\n    /**\n     * Throws an error if the tags include values other than\n     * what was specified in the schema. It returns a list of tag names.\n     */\n    checkTags(tags) {\n        const names = Object.keys(tags);\n        const extraneous = names.filter((tag) => !this._tagHash[tag]);\n        if (extraneous.length > 0) {\n            throw new Error(\"Extraneous tags detected for writing InfluxDB point in \" +\n                `${this._ref()}: \\`${extraneous.join(\"`, `\")}\\`.`);\n        }\n        return names;\n    }\n    /**\n     * Returns the 'db'.'measurement'[.'field'] referencing the current schema.\n     */\n    _ref(field) {\n        let out = this.options.database + \".\" + this.options.measurement;\n        if (field) {\n            out += \".\" + field;\n        }\n        return out;\n    }\n}\n/**\n * Coerces the field map to a set of writable values, a la coerceFields,\n * using native guesses based on the field datatypes.\n * @private\n */\nexport function coerceBadly(fields) {\n    return Object.keys(fields)\n        .sort()\n        .map((field) => {\n        const value = fields[field];\n        if (typeof value === \"string\") {\n            return [field, escape.quoted(value)];\n        }\n        return [field, String(value)];\n    });\n}\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/src/schema.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 241,
    "kind": "class",
    "name": "Schema",
    "memberof": "src/schema.js",
    "static": true,
    "longname": "src/schema.js~Schema",
    "access": "private",
    "export": true,
    "importPath": "influx/src/schema.js",
    "importStyle": "{Schema}",
    "description": "The Schema provides information and utilities for an InfluxDB measurement.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 242,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/schema.js~Schema",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/schema.js~Schema#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "options",
    "memberof": "src/schema.js~Schema",
    "static": false,
    "longname": "src/schema.js~Schema#options",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "_tagHash",
    "memberof": "src/schema.js~Schema",
    "static": false,
    "longname": "src/schema.js~Schema#_tagHash",
    "access": "private",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "_fieldNames",
    "memberof": "src/schema.js~Schema",
    "static": false,
    "longname": "src/schema.js~Schema#_fieldNames",
    "access": "private",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "coerceFields",
    "memberof": "src/schema.js~Schema",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/schema.js~Schema#coerceFields",
    "access": "public",
    "description": "CoerceFields converts a map of field values to a strings which\ncan be injected into the line protocol without further escaping.\nThe output is given in [key, value] pairs.",
    "lineNumber": 22,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "checkTags",
    "memberof": "src/schema.js~Schema",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/schema.js~Schema#checkTags",
    "access": "public",
    "description": "Throws an error if the tags include values other than\nwhat was specified in the schema. It returns a list of tag names.",
    "lineNumber": 76,
    "params": [
      {
        "name": "tags",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "_ref",
    "memberof": "src/schema.js~Schema",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/schema.js~Schema#_ref",
    "access": "private",
    "description": "Returns the 'db'.'measurement'[.'field'] referencing the current schema.",
    "lineNumber": 88,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "coerceBadly",
    "memberof": "src/schema.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/schema.js~coerceBadly",
    "access": "private",
    "export": true,
    "importPath": "influx/src/schema.js",
    "importStyle": "{coerceBadly}",
    "description": "Coerces the field map to a set of writable values, a la coerceFields,\nusing native guesses based on the field datatypes.",
    "lineNumber": 101,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "<p align=\"center\">\n  <img src=\"https://raw.github.com/node-influx/node-influx/master/logo.png?v3\" alt=\"node-influx, an InfluxDB client for Node.js and Browsers\">\n</p>\n\n<hr/>\n\n<p align=\"center\">\n  <b><!--An InfluxDB Client for Node.js and Browsers--></b>\n</p>\n\n<p align=\"center\">\n <a href=\"https://github.com/node-influx/node-influx/actions\">\n    <img src=\"https://img.shields.io/github/workflow/status/node-influx/node-influx/CI/master?style=flat-square\"\n         alt=\"CI Status\">\n  </a>\n  <a href=\"\">\n    <img alt=\"Coveralls github branch\" src=\"https://img.shields.io/coveralls/github/node-influx/node-influx/master.svg?style=flat-square\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/influx\">\n    <img src=\"https://img.shields.io/npm/v/influx.svg?style=flat-square\"\n          alt=\"NPM Version\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/influx\">\n    <img src=\"https://img.shields.io/npm/dm/influx.svg?style=flat-square\"\n         alt=\"NPM Downloads\">\n\n  </a>\n</p>\n\n# InfluxDB v1.x JavaScript library\n\nNode and browser library for InfluxDB v1.x and older. For v2, please use the [official client](https://github.com/influxdata/influxdb-client-js/).\n\n<hr/>\n\n## Installation\n\nFor Node, simply:\n\n    $ npm install --save influx\n\nFor browsers, see the [browser setup](https://node-influx.github.io/manual/usage.html#browser-setup) instructions.\n\n## Features\n\n- Simple API for nearly all Influx operations\n- Fully supported in Node and the browser\n- Performant, processing millions of rows/sec on modest hardware\n- Zero dependencies\n\n## Compatibility\n\nVersion 5.x.x is compatible with InfluxDB 1.x on Node 4 on onwards, and modern browsers\n\nVersion 4.x.x is compatible with InfluxDB 0.9.x - 0.13.x on Node 0.12 and onwards\n\nVersion 3.x.x is compatible with InfluxDB 0.8.x - 3.x will no longer have updates by core contributers, please consider upgrading.\n\n## Usage\n\n- [API Documentation](https://node-influx.github.io/class/src/index.js~InfluxDB.html)\n- [Tutorials & Examples](https://node-influx.github.io/manual/tutorial.html)\n- [Changelog](https://node-influx.github.io/manual/changelog.html)\n- [Contributing](CONTRIBUTING.md)\n",
    "longname": "/Users/ben/Projects/node-influx/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"influx\",\n  \"version\": \"0.0.0-development\",\n  \"description\": \"InfluxDB Client\",\n  \"main\": \"./lib/src/index.js\",\n  \"typings\": \"./lib/src/index\",\n  \"scripts\": {\n    \"build:dist\": \"npm run clean && tsc && cp -R test/fixture lib/test\",\n    \"build:doc\": \"npm run clean && tsc -m es2015 -t es6 --moduleResolution node && esdoc -c esdoc.json\",\n    \"clean\": \"rm -rf coverage doc lib\",\n    \"prepare\": \"npm run clean && tsc -d\",\n    \"fmt\": \"prettier --single-quote --trailing-comma all --print-width 100 --write \\\"{src,test,examples}/**/*.ts\\\" && npm run test:lint -- --fix\",\n    \"test\": \"npm-run-all --parallel test:lint test:unit test:integrate\",\n    \"test:browser\": \"karma start test/karma.conf.js\",\n    \"test:cover\": \"npm run build:dist && istanbul cover _mocha -- lib/test/unit/*.test.js && open-cli coverage/lcov-report/index.html\",\n    \"test:integrate\": \"mocha --require ts-node/register --timeout 20000 test/integrate/*.test.ts\",\n    \"test:lint\": \"prettier -c .\",\n    \"test:ci\": \"npm-run-all clean test:unit test:integrate build:dist && istanbul cover _mocha --report lcovonly -- lib/test/unit/*.test.js\",\n    \"test:unit\": \"mocha --require ts-node/register test/unit/*.test.ts\",\n    \"test:watch\": \"mocha -R min --watch --require ts-node/register test/unit/*.test.ts\",\n    \"semantic-release\": \"semantic-release\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/node-influx/node-influx.git\"\n  },\n  \"keywords\": [\n    \"influx\",\n    \"influxdb\",\n    \"time\",\n    \"series\",\n    \"client\",\n    \"db\"\n  ],\n  \"contributors\": [\n    \"Ben Evans <ben@bensbit.co.uk> (http://bensbit.co.uk)\",\n    \"Connor Peet <connor@peet.io>\",\n    \"Steffen Konerow <steffen@nrg-media.de> (http://www.nrg-media.de)\",\n    \"Timm Murray <tmurray@wumpus-cave.net> (http://wumpus-cave.net)\"\n  ],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@types/chai\": \"^4.2.11\",\n    \"@types/freeport\": \"1.0.21\",\n    \"@types/mocha\": \"^8.0.0\",\n    \"@types/node\": \"^14.0.24\",\n    \"@types/sinon\": \"^10.0.0\",\n    \"@types/sinon-chai\": \"^3.2.4\",\n    \"awesome-typescript-loader\": \"5.2.1\",\n    \"chai\": \"4.3.4\",\n    \"coveralls\": \"^3.1.0\",\n    \"esdoc\": \"1.1.0\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"freeport\": \"1.0.5\",\n    \"istanbul\": \"0.4.5\",\n    \"json-loader\": \"0.5.7\",\n    \"karma\": \"^6.3.2\",\n    \"karma-chrome-launcher\": \"^3.1.0\",\n    \"karma-mocha\": \"^2.0.1\",\n    \"karma-mocha-reporter\": \"2.2.5\",\n    \"karma-sourcemap-loader\": \"0.3.8\",\n    \"karma-webpack\": \"^5.0.0-alpha.5\",\n    \"lodash\": \"4.17.21\",\n    \"mocha\": \"^8.2.1\",\n    \"node-fetch\": \"2.6.1\",\n    \"npm-run-all\": \"4.1.5\",\n    \"open-cli\": \"^7.0.0\",\n    \"prettier\": \"^2.3.0\",\n    \"puppeteer\": \"^10.0.0\",\n    \"semantic-release\": \"^17.4.2\",\n    \"sinon\": \"^11.0.0\",\n    \"sinon-chai\": \"^3.5.0\",\n    \"stream-http\": \"github:node-influx/stream-http\",\n    \"ts-node\": \"^10.0.0\",\n    \"typescript\": \"^4.0.2\",\n    \"webpack\": \"^4.43.0\"\n  }\n}\n",
    "longname": "/Users/ben/Projects/node-influx/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/ben/Projects/node-influx/examples/express_response_times/readme.md",
    "name": "./examples/express_response_times/readme.md",
    "content": "# Express Response Times Example\n\nIn this example we'll create a server which has an index page that prints out \"hello world\", and a page `http://localhost:3000/times` which prints out the last ten response times that InfluxDB gave us.\n\nYou can see annotated the source code [on Github here](https://github.com/node-influx/node-influx/tree/master/examples/express_response_times).\n\nThe end result should look something like this:\n\n```js\n  ~ curl -s localhost:3000\nHello world!\n  ~ curl -s localhost:3000/times | jq\n[\n  {\n    \"time\": \"2016-10-09T19:13:26.815Z\",\n    \"duration\": 205,\n    \"host\": \"ares.peet.io\",\n    \"path\": \"/\"\n  }\n]\n```\n\nGet started by installing and importing everything we need! This tutorial assumes you're running Node 6.\n\n```\nnpm install influx express\n```\n\nNow create a new file `app.js` and start writing:\n\n```js\nconst Influx = require(\"../../\");\nconst express = require(\"express\");\nconst http = require(\"http\");\nconst os = require(\"os\");\n\nconst app = express();\n```\n\nCreate a new Influx client. We tell it to use the `express_response_db` database by default, and give it some information about the schema we're writing. It can use this to be smarter about what data formats it writes and do some basic validation for us.\n\n```js\nconst influx = new Influx.InfluxDB({\n  host: \"localhost\",\n  database: \"express_response_db\",\n  schema: [\n    {\n      measurement: \"response_times\",\n      fields: {\n        path: Influx.FieldType.STRING,\n        duration: Influx.FieldType.INTEGER,\n      },\n      tags: [\"host\"],\n    },\n  ],\n});\n```\n\n> Things we used:\n>\n> - [new InfluxDB()](https://node-influx.github.io/class/src/index.js~InfluxDB.html#instance-constructor-constructor)\n> - [Influx.FieldType](https://node-influx.github.io/typedef/index.html#static-typedef-FieldType)\n\nNow, we have a working Influx client! We'll make sure the database exists and boot the app.\n\n```js\ninflux\n  .getDatabaseNames()\n  .then((names) => {\n    if (!names.includes(\"express_response_db\")) {\n      return influx.createDatabase(\"express_response_db\");\n    }\n  })\n  .then(() => {\n    http.createServer(app).listen(3000, function () {\n      console.log(\"Listening on port 3000\");\n    });\n  })\n  .catch((err) => {\n    console.error(`Error creating Influx database!`);\n  });\n```\n\n> Things we used:\n>\n> - [InfluxDB#getDatabaseNames](https://node-influx.github.io/class/src/index.js~InfluxDB.html#instance-method-getDatabaseNames)\n> - [InfluxDB#createDatabase](https://node-influx.github.io/class/src/index.js~InfluxDB.html#instance-method-createDatabase)\n\nFinally, we'll define the middleware and routes we'll use. We have a generic middleware that records the time between when requests comes in, and the time we respond to them. We also have another route called `/times` which prints out the last ten timings we recorded.\n\n```js\napp.use((req, res, next) => {\n  const start = Date.now();\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    console.log(`Request to ${req.path} took ${duration}ms`);\n\n    influx\n      .writePoints([\n        {\n          measurement: \"response_times\",\n          tags: { host: os.hostname() },\n          fields: { duration, path: req.path },\n        },\n      ])\n      .catch((err) => {\n        console.error(`Error saving data to InfluxDB! ${err.stack}`);\n      });\n  });\n  return next();\n});\n\napp.get(\"/\", function (req, res) {\n  setTimeout(() => res.end(\"Hello world!\"), Math.random() * 500);\n});\n\napp.get(\"/times\", function (req, res) {\n  influx\n    .query(\n      `\n    select * from response_times\n    where host = ${Influx.escape.stringLit(os.hostname())}\n    order by time desc\n    limit 10\n  `\n    )\n    .then((result) => {\n      res.json(result);\n    })\n    .catch((err) => {\n      res.status(500).send(err.stack);\n    });\n});\n```\n\n> Things we used:\n>\n> - [InfluxDB#writePoints](https://node-influx.github.io/class/src/index.js~InfluxDB.html#instance-method-writePoints)\n> - [InfluxDB#query](https://node-influx.github.io/class/src/index.js~InfluxDB.html#instance-method-query)\n> - [InfluxDB.escape.stringLit](https://node-influx.github.io/variable/index.html#static-variable-escape)\n\nThat's it! Go ahead and boot your app using `node app.js` and try it out! You can see the complete annotated the source code [on Github here](https://github.com/node-influx/node-influx/tree/master/examples/express_response_times).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/ben/Projects/node-influx/examples/times.md",
    "name": "./examples/times.md",
    "content": "# A Moment for Times\n\nInfluxDB is a time series database, so it would make sense that the concept of time is moderately important when dealing with it.\n\nBy default, Influx will store all dates you give to it as a nanosecond-precision timestamp, whereas in JavaScript, most of the time we're dealing with millisecond precision timestamps, which we get from `Date.now()` or `myDate.getTime()`. This presents a bit of a problem for us JavaScripters, since nanosecond-precision timestamps are stored as 64-bit unsigned integers that JavaScript simply cannot represent accurately.\n\n```\n  node-influx git:(master) node\n> 1475985480231035677\n1475985480231035600\n```\n\nThis module tries to make dates as easy as possible for you to deal with, and out of the box everything should \"just work\".\n\nThere are three places that dates can get passed around:\n\n- Dates coming from Influx queries, like `select * from my_series`\n- Dates being interpolated _into_ Influx queries\n- Dates being used when writing points on the line protocol, via `.writePoints()` or `.writeMeasurement()`\n\nTo deal with this, we introduce a new type called **NanoDate**. These dates behave just like the normal `Date` type, but have two additional methods: `.getNanoTime()` and `.getNanoISOString()`. They behave just like the normal `.getTime()` and `getISOString` methods, but they both return nanosecond-precision strings instead of millisecond-precision numbers and timestamps.\n\n```js\nexpect(myNanoDate.getTime()).to.equal(1475985480231);\nexpect(myNanoDate.getNanoTime()).to.equal(\"1475985480231035677\");\nexpect(myNanoDate.toISOString()).to.equal(\"2016-10-09T03:58:00.231Z\");\nexpect(myNanoDate.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035677Z\");\n```\n\n**All times returned from Influx queries are parsed to INanoDates**. For example, you can do something like the following:\n\n```js\ninflux.query(\"select * from perf\").then((results) => {\n  results.forEach((row) =>\n    console.log(`Used ${row.cpu} at ${row.time.toNanoISOString()}`)\n  );\n});\n```\n\nWhen writing data to Influx, **all write methods accept INanoDates in all situations**. This means if you select data from Influx and want to update a data point, you can pass that time right back into the `write` method. (Remember, points within series are unique by their time!) If you have a nanosecond timestamp from some external source, you can convert it to a INanoDate using [`toNanoDate`](https://node-influx.github.io/function/index.html#static-function-toNanoDate).\n\n```js\nimport { toNanoDate } from \"influx\";\n\nconst myNanoDate = toNanoDate(\"1475985480231035600\");\nexpect(myNanoDate.getTime()).to.equal(1475985480231);\nexpect(myNanoDate.getNanoTime()).to.equal(\"1475985480231035600\");\nexpect(myNanoDate.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035600Z\");\n```\n\nFinally, **if you want to embed a INanoDate into an Influx query, you should should use `toNanoISOString`** to so do:\n\n```js\ninflux.query(\n  `select * from perf where time > \"${myNanoDate.toNanoISOString()}\"`\n);\n```\n\n---\n\nAnything unclear? Have some remaining questions or found a bug? Feel free to [open an issue](https://github.com/node-influx/node-influx/issues/new), we respond quickly!\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/ben/Projects/node-influx/examples/browser-setup.md",
    "name": "./examples/browser-setup.md",
    "content": "# Browser Setup\n\nFor Node.js, `influx` can be installed and you can use it out of the box!\n\n```\nnpm install --save influx@next\n```\n\nFor browsers, this will also work provided you have a bundler which can polyfill Node modules, such as Browserify, Webpack, Jspm, or Rollup with [rollup-plugin-node-resolve](https://github.com/rollup/rollup-plugin-node-resolve).\n\nHowever, at the time of writing, request timeouts will not work by default on any of these platforms until they update to the latest Node API changes. If this is an important feature for you, we recommend that you instruct your bundler to use our [patched version](https://github.com/node-influx/stream-http) of `stream-http` as your `http` polyfill. You can install it via:\n\n```\nnpm install --save node-influx/stream-http\n```\n\nYou can tell Webpack to use this module by adding the following section in your `webpack.config.js`:\n\n```js\nconst http = path.resolve(__dirname, \"node_modules/stream-http/index.js\");\n\nmodule.exports = {\n  resolve: {\n    alias: { http, https: http },\n  },\n\n  // the rest of your webpack config\n};\n```\n\nYou can tell Browserify to use this module by adding the following into your build config:\n\n```js\nconst http = require(\"stream-http\");\n\nbrowserify(myFiles, {\n  builtins: Object.assign({}, require(\"browserify/lib/builtins\"), {\n    http,\n    https: http,\n  }),\n\n  // the rest of your browserify config\n});\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/ben/Projects/node-influx/examples/testing.md",
    "name": "./examples/testing.md",
    "content": "# Testing\n\n`influx` is tested primarily with a suite of unit tests in additional to functional tests which require an InfluxDB instance to run. In order to check authentication related tests, the InfluxDB instance must have both HTTP and `/ping` authentication enabled and a `root:root` user must exist.\n\nThe recommended way of running Influx is use their official Docker image:\n\n```\ndocker run -d --name influxdb \\\n  -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 \\\n  -e INFLUXDB_HTTP_AUTH_ENABLED=true \\\n  -e INFLUXDB_HTTP_PING_AUTH_ENABLED=true \\\n  influxdb:1.8\n\ndocker exec influxdb influx -execute \"CREATE USER root WITH PASSWORD 'root' WITH ALL PRIVILEGES\"\n```\n\nAlternately, you can use a local installation of the package. If you would like to contribute and don't want to set up a full Influx testing environment, you can run solely unit tests and linting via `npm-run-all test:unit test:lint`, which do not require anything other than an `npm install`.\n\nWhen running tests you can configure where Influx lives by setting an environment variable which is a valid host to pass into the [IClusterConfig](https://node-influx.github.io/typedef/index.html#static-typedef-IClusterConfig) object.\n\n```\n  node-influx git:(master) export INFLUX_HOST='{\"host\":\"127.0.0.1\",\"port\":12345}'\n  node-influx git:(master) npm test\n```\n\nYou can run `npm run test:watch` to watch files and automatically re-run tests when they change.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/ben/Projects/node-influx/CONTRIBUTING.md",
    "name": "./CONTRIBUTING.md",
    "content": "# Contributing\n\nWe'd like to encourage you to contribute to the repository. You can do this by making an [issue ticket](https://github.com/node-influx/node-influx/issues) or, even better, submitting a patch via a pull request.\n\nWe try to make it as easy as possible for you but there are a few things to consider when contributing. The following guidelines for contribution should be followed if you want to submit a pull request:\n\n## How to prepare\n\n- You need a [GitHub account](https://github.com/signup/free)\n- Submit an [issue ticket](https://github.com/node-influx/node-influx/issues) for your issue if there is not one yet.\n  _ Describe the issue and include steps to reproduce if it's a bug.\n  _ Ensure to mention the earliest version that you know is affected.\n- If you are able and want to fix this, fork the repository on GitHub\n\n## Make Changes\n\n- In your forked repository, create a topic branch for your upcoming patch. (e.g. `feature--autoplay` or `bugfix--ios-crash`)\n  _ Usually this is based on the master branch.\n  _ Create a branch based on master; `git branch fix/master/my_contribution master` then checkout the new branch with `git checkout fix/master/my_contribution`. Please avoid working directly on the `master` branch.\n- Make sure you follow the established coding style. You can run `npm run test:lint` to verify you're all set.\n- Make use of the `.editorconfig`-file if provided with the repository.\n- Make commits of logical units and describe them properly, documenting anything new that you add.\n- If possible, submit tests to your patch / new feature so it can be tested easily.\n- Assure nothing is broken by running all the tests via `npm test`.\n\n## Submit Changes\n\n- Push your changes to a topic branch in your fork of the repository.\n- Open a pull request to the this repository and choose the right original branch you want to patch.\n- If not done in commit messages (which you really should do) please reference and update your issue with the code changes. But _please do not close the issue yourself_.\n- We'll review your changes and respond soon, usually within a day!\n\n## Additional Resources\n\n- [General GitHub documentation](http://help.github.com/)\n- [GitHub pull request documentation](http://help.github.com/send-pull-requests/)\n",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 250,
    "kind": "testFile",
    "name": "unit/backoff.test.js",
    "content": "/* eslint-env node, mocha */\nimport { expect } from \"chai\";\nimport { ConstantBackoff } from \"../../src/backoff/constant\";\nimport { ExponentialBackoff } from \"../../src/backoff/exponential\";\ndescribe(\"backoff strategies\", () => {\n    describe(\"constant strategy\", () => {\n        it(\"appears to work\", () => {\n            let exp = new ConstantBackoff({\n                delay: 500,\n                jitter: 0.5,\n            });\n            function next() {\n                const value = exp.getDelay();\n                exp = exp.next();\n                return value;\n            }\n            const checkSequence = () => {\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n                expect(next()).to.be.within(500 * (1 - 0.5), 500 * (1 + 0.5));\n            };\n            checkSequence();\n            exp = exp.reset();\n            const dupe = exp.reset();\n            checkSequence();\n            exp = dupe;\n            checkSequence();\n        });\n    });\n    describe(\"exponential strategy\", () => {\n        it(\"appears to work\", () => {\n            let exp = new ExponentialBackoff({\n                initial: 500,\n                max: 5000,\n                random: 1,\n            });\n            function next() {\n                const value = exp.getDelay();\n                exp = exp.next();\n                return value;\n            }\n            const checkSequence = () => {\n                expect(next()).to.equal(500);\n                expect(next()).to.be.oneOf([500, 1000]);\n                expect(next()).to.be.oneOf([1000, 2000]);\n                expect(next()).to.be.oneOf([2000, 4000]);\n                expect(next()).to.be.oneOf([4000, 5000]);\n                expect(next()).to.equal(5000);\n            };\n            checkSequence();\n            exp = exp.reset();\n            const dupe = exp.reset();\n            checkSequence();\n            exp = dupe;\n            checkSequence();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/backoff.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "unit/backoff.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/backoff.test.js~describe0",
    "access": null,
    "description": "backoff strategies",
    "lineNumber": 5
  },
  {
    "__docId__": 252,
    "kind": "test",
    "name": "describe1",
    "testId": 1,
    "memberof": "unit/backoff.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "unit/backoff.test.js~describe0.describe1",
    "access": null,
    "description": "constant strategy",
    "lineNumber": 6
  },
  {
    "__docId__": 253,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "unit/backoff.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "unit/backoff.test.js~describe0.describe1.it2",
    "access": null,
    "description": "appears to work",
    "lineNumber": 7
  },
  {
    "__docId__": 254,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "unit/backoff.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "unit/backoff.test.js~describe0.describe3",
    "access": null,
    "description": "exponential strategy",
    "lineNumber": 33
  },
  {
    "__docId__": 255,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "unit/backoff.test.js~describe0.describe3",
    "testDepth": 2,
    "static": true,
    "longname": "unit/backoff.test.js~describe0.describe3.it4",
    "access": null,
    "description": "appears to work",
    "lineNumber": 34
  },
  {
    "__docId__": 256,
    "kind": "testFile",
    "name": "unit/builder.test.js",
    "content": "/* eslint-env node, mocha */\nimport { expect } from \"chai\";\nimport { Expression, Measurement, toNanoDate } from \"../../src/index\";\ndescribe(\"query builder\", () => {\n    describe(\"measurement builder\", () => {\n        it(\"builds with only name\", () => {\n            expect(new Measurement().name('my_\"meas').toString()).to.equal('\"my_\\\\\"meas\"');\n        });\n        it(\"builds with name and rp\", () => {\n            expect(new Measurement().name('my_\"meas').policy('po\"licy').toString()).to.equal('\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it(\"builds with name, rp, and db\", () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .policy('po\"licy')\n                .db('my_\"db')\n                .toString()).to.equal('\"my_\\\\\"db\".\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it(\"builds with name and db\", () => {\n            expect(new Measurement().name('my_\"meas').db('my_\"db').toString()).to.equal('\"my_\\\\\"db\".\"my_\\\\\"meas\"');\n        });\n        it(\"throws when a name is omitted\", () => {\n            expect(() => new Measurement().db('my_\"db').toString()).to.throw(/must specify a measurement/);\n        });\n    });\n    describe(\"expression builder\", () => {\n        it(\"creates basic queries\", () => {\n            expect(new Expression().tag('my_\"tag').equals.value(\"42\").toString()).to.equal('\"my_\\\\\"tag\" = \\'42\\'');\n        });\n        it(\"inserts data types correctly\", () => {\n            expect(new Expression()\n                .field(\"f\")\n                .equals.value(\"str'\")\n                .or.field(\"f\")\n                .matches.value(/[0-9]+/)\n                .or.field(\"f\")\n                .equals.value(42)\n                .or.field(\"f\")\n                .equals.tag('my_\"tag')\n                .or.field(\"f\")\n                .equals.value(new Date(1475985480231))\n                .or.field(\"f\")\n                .equals.value(toNanoDate(\"1475985480231035600\"))\n                .or.field(\"f\")\n                .equals.value(true)\n                .or.exp((e) => e.field(\"a\").equals.value(1).or.field(\"b\").equals.value(2))\n                .or.field(\"f\")\n                .doesntMatch.value({ toString: () => \"/my-custom-re/\" })\n                .toString()).to.equal('\"f\" = \\'str\\\\\\'\\' OR \"f\" =~ /[0-9]+/ OR \"f\" = 42 ' +\n                'OR \"f\" = \"my_\\\\\"tag\" OR \"f\" = \"2016-10-09 03:58:00.231\" ' +\n                'OR \"f\" = \"2016-10-09 03:58:00.231035600\" OR \"f\" = TRUE ' +\n                'OR (\"a\" = 1 OR \"b\" = 2) OR \"f\" !~ /my-custom-re/');\n        });\n        it(\"throws when using a flagged regex\", () => {\n            expect(() => new Expression().field(\"f\").matches.value(/a/i)).to.throw(/doesn't support flags/);\n        });\n        it(\"throws when using un-stringifyable object\", () => {\n            expect(() => new Expression().field(\"f\").equals.value(Object.create(null))).to.throw(/doesn't know how to encode/);\n        });\n        const operationsTable = [\n            { method: \"equals\", yields: \"=\" },\n            { method: \"notEqual\", yields: \"!=\" },\n            { method: \"gt\", yields: \">\" },\n            { method: \"gte\", yields: \">=\" },\n            { method: \"lt\", yields: \"<\" },\n            { method: \"lte\", yields: \"<=\" },\n            { method: \"plus\", yields: \"+\" },\n            { method: \"minus\", yields: \"-\" },\n            { method: \"times\", yields: \"*\" },\n            { method: \"div\", yields: \"/\" },\n            { method: \"and\", yields: \"AND\" },\n            { method: \"or\", yields: \"OR\" },\n            { method: \"matches\", yields: \"=~\" },\n            { method: \"doesntMatch\", yields: \"!~\" },\n        ];\n        operationsTable.forEach(({ method, yields }) => {\n            it(`yields ${yields} from .${method}`, () => {\n                const expr = new Expression().field(\"f\");\n                expect(expr[method].value(true).toString()).to.equal(`\"f\" ${yields} TRUE`);\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/builder.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 257,
    "kind": "test",
    "name": "describe5",
    "testId": 5,
    "memberof": "unit/builder.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/builder.test.js~describe5",
    "access": null,
    "description": "query builder",
    "lineNumber": 4
  },
  {
    "__docId__": 258,
    "kind": "test",
    "name": "describe6",
    "testId": 6,
    "memberof": "unit/builder.test.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6",
    "access": null,
    "description": "measurement builder",
    "lineNumber": 5
  },
  {
    "__docId__": 259,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "unit/builder.test.js~describe5.describe6",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6.it7",
    "access": null,
    "description": "builds with only name",
    "lineNumber": 6
  },
  {
    "__docId__": 260,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "unit/builder.test.js~describe5.describe6",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6.it8",
    "access": null,
    "description": "builds with name and rp",
    "lineNumber": 9
  },
  {
    "__docId__": 261,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "unit/builder.test.js~describe5.describe6",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6.it9",
    "access": null,
    "description": "builds with name, rp, and db",
    "lineNumber": 12
  },
  {
    "__docId__": 262,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "unit/builder.test.js~describe5.describe6",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6.it10",
    "access": null,
    "description": "builds with name and db",
    "lineNumber": 19
  },
  {
    "__docId__": 263,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "unit/builder.test.js~describe5.describe6",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe6.it11",
    "access": null,
    "description": "throws when a name is omitted",
    "lineNumber": 22
  },
  {
    "__docId__": 264,
    "kind": "test",
    "name": "describe12",
    "testId": 12,
    "memberof": "unit/builder.test.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12",
    "access": null,
    "description": "expression builder",
    "lineNumber": 26
  },
  {
    "__docId__": 265,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "unit/builder.test.js~describe5.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12.it13",
    "access": null,
    "description": "creates basic queries",
    "lineNumber": 27
  },
  {
    "__docId__": 266,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "unit/builder.test.js~describe5.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12.it14",
    "access": null,
    "description": "inserts data types correctly",
    "lineNumber": 30
  },
  {
    "__docId__": 267,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "unit/builder.test.js~describe5.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12.it15",
    "access": null,
    "description": "throws when using a flagged regex",
    "lineNumber": 54
  },
  {
    "__docId__": 268,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "unit/builder.test.js~describe5.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12.it16",
    "access": null,
    "description": "throws when using un-stringifyable object",
    "lineNumber": 57
  },
  {
    "__docId__": 269,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "unit/builder.test.js~describe5.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "unit/builder.test.js~describe5.describe12.it17",
    "access": null,
    "lineNumber": 77
  },
  {
    "__docId__": 270,
    "kind": "testFile",
    "name": "unit/grammar.test.js",
    "content": "import { expect } from \"chai\";\nimport * as grammar from \"../../src/grammar\";\nconst escapeTables = require(\"../fixture/escapeTables.json\");\ndescribe(\"grammar\", () => {\n    Object.keys(escapeTables).forEach((escaper) => {\n        describe(escaper, () => {\n            escapeTables[escaper].forEach((test) => {\n                it(`escapes \\`${test[0]}\\` as \\`${test[1]}\\``, () => {\n                    expect(grammar.escape[escaper](test[0])).to.equal(test[1]);\n                });\n            });\n        });\n    });\n    it(\"does not escape raw values\", () => {\n        expect(grammar.escape.quoted(new grammar.Raw('don\"t escape'))).to.equal('don\"t escape');\n    });\n    it(\"escapes backslashes (issues #486, #516)\", () => {\n        // eslint-disable-next-line quotes\n        expect(grammar.escape.stringLit(\"GAZP()\\\\' or 1=1 --\")).to.equal(\"'GAZP()\\\\\\\\\\\\' or 1=1 --'\");\n        expect(grammar.escape.tag(1)).to.equal(\"1\");\n    });\n    it(\"escapes complex values (issue #242)\", () => {\n        const original = JSON.stringify({ a: JSON.stringify({ b: \"c c\" }) });\n        expect(grammar.escape.quoted(original)).to.equal('\"{\\\\\"a\\\\\":\\\\\"{\\\\\\\\\\\\\"b\\\\\\\\\\\\\":\\\\\\\\\\\\\"c c\\\\\\\\\\\\\"}\\\\\"}\"');\n    });\n    let nanoDate;\n    let milliDate;\n    beforeEach(() => {\n        nanoDate = grammar.isoOrTimeToDate(\"2016-10-09T03:58:00.231035677Z\", \"n\");\n        milliDate = new Date(1475985480231);\n    });\n    it(\"converts a nanoseconds timestamp to a nano date\", () => {\n        const date = grammar.toNanoDate(\"1475985480231035600\");\n        expect(date.getTime()).to.equal(1475985480231);\n        expect(date.getNanoTime()).to.equal(\"1475985480231035600\"); // Precision is lost\n        expect(date.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035600Z\");\n    });\n    it(\"converts a nanoseconds timestamp with trailing zeroes to a nano date\", () => {\n        const date = grammar.toNanoDate(\"1254646541002000000\");\n        expect(date.getTime()).to.equal(1254646541002);\n        expect(date.getNanoTime()).to.equal(\"1254646541002000000\"); // Precision is lost\n        expect(date.toNanoISOString()).to.equal(\"2009-10-04T08:55:41.002000000Z\");\n    });\n    describe(\"formatting\", () => {\n        it(\"formats nanosecond dates\", () => {\n            expect(grammar.formatDate(nanoDate)).to.equal('\"2016-10-09 03:58:00.231035677\"');\n        });\n        it(\"formats millisecond dates\", () => {\n            expect(grammar.formatDate(milliDate)).to.equal('\"2016-10-09 03:58:00.231\"');\n        });\n    });\n    describe(\"parsing\", () => {\n        it(\"parses ISO dates correctly\", () => {\n            const parsed = grammar.isoOrTimeToDate(\"2016-10-09T03:58:00.231035677Z\", \"n\");\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480231035677\");\n            expect(parsed.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035677Z\");\n        });\n        it(\"parses numeric `ns` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035677, \"n\");\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480231035600\"); // Precision is lost\n            expect(parsed.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035600Z\");\n        });\n        it(\"parses numeric `u` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035, \"u\");\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480231035000\");\n            expect(parsed.toNanoISOString()).to.equal(\"2016-10-09T03:58:00.231035000Z\");\n        });\n        it(\"parses numeric `ms` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231, \"ms\");\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480231000000\");\n        });\n        it(\"parses numeric `s` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480, \"s\");\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480000000000\");\n        });\n        it(\"parses numeric `m` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(24599758, \"m\");\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed.getNanoTime()).to.equal(\"1475985480000000000\");\n        });\n        it(\"parses numeric `h` timestamps\", () => {\n            const parsed = grammar.isoOrTimeToDate(409995, \"h\");\n            expect(parsed.getTime()).to.equal(1475982000000);\n            expect(parsed.getNanoTime()).to.equal(\"1475982000000000000\");\n        });\n    });\n    describe(\"timestamp casting\", () => {\n        it(\"casts dates into timestamps\", () => {\n            const d = new Date(1475121809084);\n            expect(grammar.castTimestamp(d, \"n\")).to.equal(\"1475121809084000000\");\n            expect(grammar.castTimestamp(d, \"u\")).to.equal(\"1475121809084000\");\n            expect(grammar.castTimestamp(d, \"ms\")).to.equal(\"1475121809084\");\n            expect(grammar.castTimestamp(d, \"s\")).to.equal(\"1475121809\");\n            expect(grammar.castTimestamp(d, \"m\")).to.equal(\"24585363\");\n            expect(grammar.castTimestamp(d, \"h\")).to.equal(\"409756\");\n        });\n        it(\"casts nanodates into timestamps\", () => {\n            const d = grammar.toNanoDate(\"1475985480231035600\");\n            expect(grammar.castTimestamp(d, \"n\")).to.equal(\"1475985480231035600\");\n            expect(grammar.castTimestamp(d, \"u\")).to.equal(\"1475985480231035\");\n            expect(grammar.castTimestamp(d, \"ms\")).to.equal(\"1475985480231\");\n            expect(grammar.castTimestamp(d, \"s\")).to.equal(\"1475985480\");\n            expect(grammar.castTimestamp(d, \"m\")).to.equal(\"24599758\");\n            expect(grammar.castTimestamp(d, \"h\")).to.equal(\"409995\");\n        });\n        it(\"accepts strings, numbers liternally\", () => {\n            expect(grammar.castTimestamp(\"1475985480231035600\", \"s\")).to.equal(\"1475985480231035600\");\n            expect(grammar.castTimestamp(1475985480231, \"s\")).to.equal(\"1475985480231\");\n        });\n        it(\"throws on non-numeric strings\", () => {\n            expect(() => grammar.castTimestamp(\"wut\", \"s\")).to.throw(/numeric value/);\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/grammar.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 271,
    "kind": "test",
    "name": "describe18",
    "testId": 18,
    "memberof": "unit/grammar.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/grammar.test.js~describe18",
    "access": null,
    "description": "grammar",
    "lineNumber": 4
  },
  {
    "__docId__": 272,
    "kind": "test",
    "name": "describe19",
    "testId": 19,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe19",
    "access": null,
    "lineNumber": 6
  },
  {
    "__docId__": 273,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "unit/grammar.test.js~describe18.describe19",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe19.it20",
    "access": null,
    "lineNumber": 8
  },
  {
    "__docId__": 274,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.it21",
    "access": null,
    "description": "does not escape raw values",
    "lineNumber": 14
  },
  {
    "__docId__": 275,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.it22",
    "access": null,
    "description": "escapes backslashes (issues #486, #516)",
    "lineNumber": 17
  },
  {
    "__docId__": 276,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.it23",
    "access": null,
    "description": "escapes complex values (issue #242)",
    "lineNumber": 22
  },
  {
    "__docId__": 277,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.it24",
    "access": null,
    "description": "converts a nanoseconds timestamp to a nano date",
    "lineNumber": 32
  },
  {
    "__docId__": 278,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.it25",
    "access": null,
    "description": "converts a nanoseconds timestamp with trailing zeroes to a nano date",
    "lineNumber": 38
  },
  {
    "__docId__": 279,
    "kind": "test",
    "name": "describe26",
    "testId": 26,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe26",
    "access": null,
    "description": "formatting",
    "lineNumber": 44
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "unit/grammar.test.js~describe18.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe26.it27",
    "access": null,
    "description": "formats nanosecond dates",
    "lineNumber": 45
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "unit/grammar.test.js~describe18.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe26.it28",
    "access": null,
    "description": "formats millisecond dates",
    "lineNumber": 48
  },
  {
    "__docId__": 282,
    "kind": "test",
    "name": "describe29",
    "testId": 29,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29",
    "access": null,
    "description": "parsing",
    "lineNumber": 52
  },
  {
    "__docId__": 283,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it30",
    "access": null,
    "description": "parses ISO dates correctly",
    "lineNumber": 53
  },
  {
    "__docId__": 284,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it31",
    "access": null,
    "description": "parses numeric `ns` timestamps",
    "lineNumber": 59
  },
  {
    "__docId__": 285,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it32",
    "access": null,
    "description": "parses numeric `u` timestamps",
    "lineNumber": 65
  },
  {
    "__docId__": 286,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it33",
    "access": null,
    "description": "parses numeric `ms` timestamps",
    "lineNumber": 71
  },
  {
    "__docId__": 287,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it34",
    "access": null,
    "description": "parses numeric `s` timestamps",
    "lineNumber": 76
  },
  {
    "__docId__": 288,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it35",
    "access": null,
    "description": "parses numeric `m` timestamps",
    "lineNumber": 81
  },
  {
    "__docId__": 289,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "unit/grammar.test.js~describe18.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe29.it36",
    "access": null,
    "description": "parses numeric `h` timestamps",
    "lineNumber": 86
  },
  {
    "__docId__": 290,
    "kind": "test",
    "name": "describe37",
    "testId": 37,
    "memberof": "unit/grammar.test.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe37",
    "access": null,
    "description": "timestamp casting",
    "lineNumber": 92
  },
  {
    "__docId__": 291,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "unit/grammar.test.js~describe18.describe37",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe37.it38",
    "access": null,
    "description": "casts dates into timestamps",
    "lineNumber": 93
  },
  {
    "__docId__": 292,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "unit/grammar.test.js~describe18.describe37",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe37.it39",
    "access": null,
    "description": "casts nanodates into timestamps",
    "lineNumber": 102
  },
  {
    "__docId__": 293,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "unit/grammar.test.js~describe18.describe37",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe37.it40",
    "access": null,
    "description": "accepts strings, numbers liternally",
    "lineNumber": 111
  },
  {
    "__docId__": 294,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "unit/grammar.test.js~describe18.describe37",
    "testDepth": 2,
    "static": true,
    "longname": "unit/grammar.test.js~describe18.describe37.it41",
    "access": null,
    "description": "throws on non-numeric strings",
    "lineNumber": 115
  },
  {
    "__docId__": 295,
    "kind": "testFile",
    "name": "unit/influx.test.js",
    "content": "import { expect } from \"chai\";\nimport * as sinon from \"sinon\";\nimport { FieldType, InfluxDB, toNanoDate } from \"../../src\";\nimport { dbFixture } from \"./helpers\";\ndescribe(\"influxdb\", () => {\n    describe(\"constructor\", () => {\n        it(\"uses default options\", () => {\n            expect(new InfluxDB()._options).to.deep.equal({\n                username: \"root\",\n                password: \"root\",\n                database: null,\n                pool: undefined,\n                schema: [],\n                hosts: [\n                    {\n                        host: \"127.0.0.1\",\n                        port: 8086,\n                        path: \"\",\n                        protocol: \"http\",\n                        options: undefined,\n                    },\n                ],\n            });\n        });\n        it(\"parses dsns\", () => {\n            expect(new InfluxDB(\"https://connor:password@192.168.0.1:1337/foo\")\n                ._options).to.deep.equal({\n                username: \"connor\",\n                password: \"password\",\n                database: \"foo\",\n                pool: undefined,\n                schema: [],\n                hosts: [\n                    {\n                        host: \"192.168.0.1\",\n                        port: 1337,\n                        path: \"\",\n                        protocol: \"https\",\n                        options: undefined,\n                    },\n                ],\n            });\n        });\n        it(\"parses single configs\", () => {\n            expect(new InfluxDB({ database: \"foo\", host: \"192.168.0.1\" })._options).to.deep.equal({\n                username: \"root\",\n                password: \"root\",\n                database: \"foo\",\n                pool: undefined,\n                schema: [],\n                hosts: [\n                    {\n                        host: \"192.168.0.1\",\n                        port: 8086,\n                        path: \"\",\n                        protocol: \"http\",\n                        options: undefined,\n                    },\n                ],\n            });\n        });\n        it(\"parses cluster configs\", () => {\n            expect(new InfluxDB({\n                database: \"foo\",\n                hosts: [{ host: \"192.168.0.1\", options: { ca: null } }],\n            })._options).to.deep.equal({\n                username: \"root\",\n                password: \"root\",\n                database: \"foo\",\n                schema: [],\n                hosts: [\n                    {\n                        host: \"192.168.0.1\",\n                        port: 8086,\n                        path: \"\",\n                        protocol: \"http\",\n                        options: { ca: null },\n                    },\n                ],\n            });\n        });\n        it(\"parses parses schema\", () => {\n            let client = new InfluxDB({\n                schema: [\n                    {\n                        database: \"my_db\",\n                        measurement: \"my_measurement\",\n                        fields: {},\n                        tags: [\"my_tag\"],\n                    },\n                ],\n                hosts: [{ host: \"192.168.0.1\", options: undefined }],\n            });\n            expect(client._schema.my_db.my_measurement).to.not.be.undefined;\n            client = new InfluxDB({\n                schema: [\n                    {\n                        measurement: \"my_measurement\",\n                        fields: {},\n                        tags: [\"my_tag\"],\n                    },\n                ],\n                database: \"my_db\",\n                hosts: [{ host: \"192.168.0.1\" }],\n            });\n            expect(client._schema.my_db.my_measurement).to.not.be.undefined;\n            expect(() => {\n                new InfluxDB({\n                    // eslint-disable-line no-new\n                    schema: [\n                        {\n                            measurement: \"my_measurement\",\n                            fields: {},\n                            tags: [\"my_tag\"],\n                        },\n                    ],\n                    hosts: [{ host: \"192.168.0.1\" }],\n                });\n            }).to.throw(/no default database is provided/);\n        });\n    });\n    describe(\"methods\", () => {\n        let influx;\n        let pool;\n        const expectations = [];\n        beforeEach(() => {\n            influx = new InfluxDB({\n                hosts: [],\n                schema: [\n                    {\n                        database: \"my_db\",\n                        measurement: \"my_schemed_measure\",\n                        tags: [\"my_tag\"],\n                        fields: {\n                            int: FieldType.INTEGER,\n                            float: FieldType.FLOAT,\n                            string: FieldType.STRING,\n                            bool: FieldType.BOOLEAN,\n                        },\n                    },\n                ],\n            });\n            pool = influx._pool;\n            sinon.stub(pool, \"discard\");\n            sinon.stub(pool, \"json\");\n            sinon.stub(pool, \"text\");\n        });\n        afterEach(() => {\n            while (expectations.length) {\n                expectations.pop()();\n            }\n        });\n        const setDefaultDB = (db) => {\n            influx._options.database = db;\n        };\n        const expectQuery = (method, options, httpMethod = \"POST\", yields = { results: [{}] }) => {\n            if (typeof options === \"string\") {\n                options = { q: options };\n            }\n            pool[method].returns(Promise.resolve(yields));\n            expectations.push(() => {\n                expect(pool[method]).to.have.been.calledWith({\n                    method: httpMethod,\n                    path: \"/query\",\n                    query: Object.assign({ u: \"root\", p: \"root\" }, options),\n                });\n            });\n        };\n        const expectWrite = (body, options) => {\n            if (typeof options === \"string\") {\n                options = { q: options };\n            }\n            pool.discard.returns(Promise.resolve());\n            expectations.push(() => {\n                expect(pool.discard).to.have.been.calledWith({\n                    method: \"POST\",\n                    path: \"/write\",\n                    body,\n                    query: Object.assign({ u: \"root\", p: \"root\" }, options),\n                });\n            });\n        };\n        it(\".createDatabase()\", () => {\n            expectQuery(\"json\", 'create database \"foo\"');\n            influx.createDatabase(\"foo\");\n            expectQuery(\"json\", 'create database \"f\\\\\"oo\"');\n            influx.createDatabase('f\"oo');\n        });\n        it(\".dropDatabase()\", () => {\n            expectQuery(\"json\", 'drop database \"foo\"');\n            influx.dropDatabase(\"foo\");\n            expectQuery(\"json\", 'drop database \"f\\\\\"oo\"');\n            influx.dropDatabase('f\"oo');\n        });\n        it(\".dropShard()\", () => {\n            expectQuery(\"json\", \"drop shard 1\");\n            influx.dropShard(1);\n        });\n        it(\".getDatabaseNames()\", () => {\n            expectQuery(\"json\", \"show databases\", \"GET\", dbFixture(\"showDatabases\"));\n            return influx.getDatabaseNames().then((names) => {\n                expect(names).to.deep.equal([\"_internal\", \"influx_test_gen\"]);\n            });\n        });\n        it(\".getMeasurements()\", () => {\n            setDefaultDB(\"mydb\");\n            expectQuery(\"json\", {\n                db: \"mydb\",\n                q: \"show measurements\",\n            }, \"GET\", dbFixture(\"showMeasurements\"));\n            return influx.getMeasurements().then((names) => {\n                expect(names).to.deep.equal([\"series_0\", \"series_1\", \"series_2\"]);\n            });\n        });\n        it(\".getSeries() from all\", () => {\n            setDefaultDB(\"mydb\");\n            expectQuery(\"json\", {\n                db: \"mydb\",\n                q: \"show series\",\n            }, \"GET\", dbFixture(\"showSeries\"));\n            return influx.getSeries().then((names) => {\n                expect(names).to.deep.equal([\n                    \"series_0,my_tag=0\",\n                    \"series_0,my_tag=1\",\n                    \"series_0,my_tag=5\",\n                    \"series_0,my_tag=6\",\n                    \"series_0,my_tag=7\",\n                    \"series_0,my_tag=8\",\n                    \"series_0,my_tag=9\",\n                    \"series_1,my_tag=0\",\n                    \"series_1,my_tag=2\",\n                    \"series_1,my_tag=4\",\n                    \"series_1,my_tag=5\",\n                    \"series_1,my_tag=6\",\n                    \"series_1,my_tag=7\",\n                    \"series_1,my_tag=8\",\n                    \"series_1,my_tag=9\",\n                    \"series_2,my_tag=1\",\n                    \"series_2,my_tag=2\",\n                    \"series_2,my_tag=3\",\n                    \"series_2,my_tag=4\",\n                    \"series_2,my_tag=5\",\n                    \"series_2,my_tag=6\",\n                    \"series_2,my_tag=7\",\n                    \"series_2,my_tag=8\",\n                    \"series_2,my_tag=9\",\n                ]);\n            });\n        });\n        it(\".getSeries() from single\", () => {\n            expectQuery(\"json\", {\n                db: \"mydb\",\n                q: 'show series from \"measure_1\"',\n            }, \"GET\", dbFixture(\"showSeriesFromOne\"));\n            return influx\n                .getSeries({\n                database: \"mydb\",\n                measurement: \"measure_1\",\n            })\n                .then((names) => {\n                expect(names).to.deep.equal([\n                    \"series_1,my_tag=0\",\n                    \"series_1,my_tag=2\",\n                    \"series_1,my_tag=4\",\n                    \"series_1,my_tag=5\",\n                    \"series_1,my_tag=6\",\n                    \"series_1,my_tag=7\",\n                    \"series_1,my_tag=8\",\n                    \"series_1,my_tag=9\",\n                ]);\n            });\n        });\n        it(\".dropMeasurement()\", () => {\n            expectQuery(\"json\", {\n                db: \"my_db\",\n                q: 'drop measurement \"series_1\"',\n            });\n            return influx.dropMeasurement(\"series_1\", \"my_db\");\n        });\n        describe(\".dropSeries()\", () => {\n            beforeEach(() => setDefaultDB(\"my_db\"));\n            it(\"drops with only from clause by string\", () => {\n                expectQuery(\"json\", { db: \"my_db\", q: 'drop series from \"series_0\"' });\n                influx.dropSeries({ measurement: '\"series_0\"' });\n            });\n            it(\"drops with only from clause by builder\", () => {\n                expectQuery(\"json\", { db: \"my_db\", q: 'drop series from \"series_0\"' });\n                influx.dropSeries({ measurement: (m) => m.name(\"series_0\") });\n            });\n            it(\"drops with only where clause by string\", () => {\n                expectQuery(\"json\", {\n                    db: \"my_db\",\n                    q: 'drop series where \"my_tag\" = 1',\n                });\n                influx.dropSeries({ where: '\"my_tag\" = 1' });\n            });\n            it(\"drops with only where clause by builder\", () => {\n                expectQuery(\"json\", {\n                    db: \"my_db\",\n                    q: 'drop series where \"my_tag\" = 1',\n                });\n                influx.dropSeries({ where: (e) => e.tag(\"my_tag\").equals.value(1) });\n            });\n            it(\"drops with both\", () => {\n                expectQuery(\"json\", {\n                    db: \"my_db\",\n                    q: 'drop series from \"series_0\" where \"my_tag\" = 1',\n                });\n                influx.dropSeries({\n                    measurement: (m) => m.name(\"series_0\"),\n                    where: (e) => e.tag(\"my_tag\").equals.value(1),\n                });\n            });\n        });\n        it(\".getUsers()\", () => {\n            expectQuery(\"json\", \"show users\", \"GET\", dbFixture(\"showUsers\"));\n            return influx.getUsers().then((names) => {\n                expect(names.slice()).to.deep.equal([\n                    { user: \"john\", admin: true },\n                    { user: \"steve\", admin: false },\n                ]);\n            });\n        });\n        describe(\".createUser()\", () => {\n            it(\"works with admin specified == true\", () => {\n                expectQuery(\"json\", \"create user \\\"con\\\\\\\"nor\\\" with password 'pa55\\\\'word' with all privileges\");\n                return influx.createUser('con\"nor', \"pa55'word\", true);\n            });\n            it(\"works with admin specified == false\", () => {\n                expectQuery(\"json\", \"create user \\\"con\\\\\\\"nor\\\" with password 'pa55\\\\'word'\");\n                return influx.createUser('con\"nor', \"pa55'word\", false);\n            });\n            it(\"works with admin unspecified\", () => {\n                expectQuery(\"json\", \"create user \\\"con\\\\\\\"nor\\\" with password 'pa55\\\\'word'\");\n                return influx.createUser('con\"nor', \"pa55'word\");\n            });\n        });\n        describe(\".grantPrivilege()\", () => {\n            it(\"queries correctly\", () => {\n                expectQuery(\"json\", 'grant READ on \"my_\\\\\"_db\" to \"con\\\\\"nor\"');\n                return influx.grantPrivilege('con\"nor', \"READ\", 'my_\"_db');\n            });\n            it(\"throws if DB unspecified\", () => {\n                expect(() => influx.grantPrivilege('con\"nor', \"READ\")).to.throw(/default database/);\n            });\n            it(\"fills in default DB\", () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery(\"json\", 'grant READ on \"my_\\\\\"_db\" to \"con\\\\\"nor\"');\n                return influx.grantPrivilege('con\"nor', \"READ\", 'my_\"_db');\n            });\n        });\n        describe(\".revokePrivilege()\", () => {\n            it(\"queries correctly\", () => {\n                expectQuery(\"json\", 'revoke READ on \"my_\\\\\"_db\" from \"con\\\\\"nor\"');\n                return influx.revokePrivilege('con\"nor', \"READ\", 'my_\"_db');\n            });\n            it(\"throws if DB unspecified\", () => {\n                expect(() => influx.revokePrivilege('con\"nor', \"READ\")).to.throw(/default database/);\n            });\n            it(\"fills in default DB\", () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery(\"json\", 'revoke READ on \"my_\\\\\"_db\" from \"con\\\\\"nor\"');\n                return influx.revokePrivilege('con\"nor', \"READ\", 'my_\"_db');\n            });\n        });\n        it(\".grantAdminPrivilege()\", () => {\n            expectQuery(\"json\", 'grant all to \"con\\\\\"nor\"');\n            return influx.grantAdminPrivilege('con\"nor');\n        });\n        it(\".revokeAdminPrivilege()\", () => {\n            expectQuery(\"json\", 'revoke all from \"con\\\\\"nor\"');\n            return influx.revokeAdminPrivilege('con\"nor');\n        });\n        it(\".dropUser()\", () => {\n            expectQuery(\"json\", 'drop user \"con\\\\\"nor\"');\n            return influx.dropUser('con\"nor');\n        });\n        describe(\".createContinuousQuery()\", () => {\n            it(\"queries correctly no resample\", () => {\n                expectQuery(\"json\", 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"  begin foo end');\n                return influx.createContinuousQuery('my_\"q', \"foo\", 'my_\"_db');\n            });\n            it(\"queries correctly with resample\", () => {\n                expectQuery(\"json\", 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\" resample for 4m begin foo end');\n                return influx.createContinuousQuery('my_\"q', \"foo\", 'my_\"_db', \"resample for 4m\");\n            });\n            it(\"throws if DB unspecified\", () => {\n                expect(() => influx.createContinuousQuery('my_\"q', \"foo\")).to.throw(/default database/);\n            });\n            it(\"fills in default DB\", () => {\n                setDefaultDB('my_\"_db');\n                expectQuery(\"json\", 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"  begin foo end');\n                return influx.createContinuousQuery('my_\"q', \"foo\");\n            });\n        });\n        describe(\".dropContinuousQuery()\", () => {\n            it(\"queries correctly\", () => {\n                expectQuery(\"json\", 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q', 'my_\"_db');\n            });\n            it(\"throws if DB unspecified\", () => {\n                expect(() => influx.dropContinuousQuery('my_\"q')).to.throw(/default database/);\n            });\n            it(\"fills in default DB\", () => {\n                setDefaultDB('my_\"_db');\n                expectQuery(\"json\", 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q');\n            });\n        });\n        describe(\".showContinousQueries()\", () => {\n            it(\"queries correctly\", () => {\n                expectQuery(\"json\", { q: \"show continuous queries\", db: \"my_db\" }, \"GET\");\n                return influx.showContinousQueries(\"my_db\");\n            });\n            it(\"throws if DB unspecified\", () => {\n                expect(() => influx.showContinousQueries()).to.throw(/default database/);\n            });\n            it(\"fills in default DB\", () => {\n                setDefaultDB(\"my_db\");\n                expectQuery(\"json\", { q: \"show continuous queries\", db: \"my_db\" }, \"GET\");\n                return influx.showContinousQueries();\n            });\n        });\n        describe(\".writePoints()\", () => {\n            it(\"writes with all options specified without a schema\", () => {\n                expectWrite(\"mymeas,my_tag=1 myfield=90 1463683075\", {\n                    precision: \"s\",\n                    rp: \"1day\",\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"mymeas\",\n                        tags: { my_tag: \"1\" },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ], {\n                    database: \"my_db\",\n                    precision: \"s\",\n                    retentionPolicy: \"1day\",\n                });\n            });\n            it(\"writes using default options without a schema\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"mymeas,my_tag=1 myfield=90 1463683075000000000\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"mymeas\",\n                        tags: { my_tag: \"1\" },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it(\"uses a schema to coerce\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"my_schemed_measure,my_tag=1 bool=T,float=43,int=42i\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"my_schemed_measure\",\n                        tags: { my_tag: \"1\" },\n                        fields: {\n                            int: 42,\n                            float: 43,\n                            bool: true,\n                        },\n                    },\n                ]);\n            });\n            it(\"can accept a schema at runtime\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"my_runtime_schema_measure,my_tag=1 bool=T,float=43,int=42i\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                influx.addSchema({\n                    database: \"my_db\",\n                    measurement: \"my_runtime_schema_measure\",\n                    fields: {\n                        bool: FieldType.BOOLEAN,\n                        float: FieldType.FLOAT,\n                        int: FieldType.INTEGER,\n                    },\n                    tags: [\"my_tag\"],\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"my_runtime_schema_measure\",\n                        tags: { my_tag: \"1\" },\n                        fields: {\n                            int: 42,\n                            float: 43,\n                            bool: true,\n                        },\n                    },\n                ]);\n            });\n            it(\"handles lack of tags\", () => {\n                expectWrite(\"mymeas myfield=90\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"mymeas\",\n                        fields: { myfield: 90 },\n                    },\n                ], { database: \"my_db\" });\n            });\n            it(\"handles lack of fields\", () => {\n                expectWrite(\"mymeas,my_tag=90\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"mymeas\",\n                        tags: { my_tag: \"90\" },\n                    },\n                ], { database: \"my_db\" });\n            });\n            it(\"handles multiple tags\", () => {\n                expectWrite(\"mymeas,my_tag1=90,my_tag2=45\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writePoints([\n                    {\n                        measurement: \"mymeas\",\n                        tags: { my_tag1: \"90\", my_tag2: \"45\" },\n                    },\n                ], { database: \"my_db\" });\n            });\n            it(\"writes with the .writeMeasurement method\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"mymeas,my_tag=1 myfield=90 1463683075000000000\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writeMeasurement(\"mymeas\", [\n                    {\n                        tags: { my_tag: \"1\" },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it(\"accepts nanoseconds (as ms)\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"mymeas,my_tag=1 myfield=90 1463683075000000000\", {\n                    precision: \"n\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writeMeasurement(\"mymeas\", [\n                    {\n                        tags: { my_tag: \"1\" },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate(\"1463683075000000000\"),\n                    },\n                ]);\n            });\n            it(\"accepts timestamp overriding\", () => {\n                setDefaultDB(\"my_db\");\n                expectWrite(\"mymeas,my_tag=1 myfield=90 1463683075000\", {\n                    precision: \"ms\",\n                    rp: undefined,\n                    db: \"my_db\",\n                });\n                return influx.writeMeasurement(\"mymeas\", [\n                    {\n                        tags: { my_tag: \"1\" },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate(\"1463683075000000000\"),\n                    },\n                ], { precision: \"ms\" });\n            });\n        });\n        describe(\".parsePoint()\", () => {\n            it(\"parses a minimal valid point with default options\", () => {\n                setDefaultDB(\"my_db\");\n                let point = {\n                    measurement: \"mymeas\",\n                    fields: { myfield: 90 },\n                };\n                let parsedPoint = influx.parsePoint(point);\n                expect(parsedPoint.measurement).to.equal(point.measurement);\n                expect(parsedPoint.fields).to.equal(point.fields);\n                expect(parsedPoint.tags).to.deep.equals({});\n                expect(parsedPoint.fieldsPairs).to.deep.equals([[\"myfield\", \"90\"]]);\n                expect(parsedPoint.tagsNames).to.deep.equals([]);\n                expect(parsedPoint.castedTimestamp).to.be.undefined;\n            });\n            it(\"parses a point with fields, tags, and timestamp\", () => {\n                setDefaultDB(\"my_db\");\n                let date = new Date();\n                let point = {\n                    measurement: \"mymeas\",\n                    fields: { myfield: 90 },\n                    tags: { my_tag: \"2\" },\n                    timestamp: date,\n                };\n                let parsedPoint = influx.parsePoint(point);\n                expect(parsedPoint.measurement).to.equal(point.measurement);\n                expect(parsedPoint.fields).to.equal(point.fields);\n                expect(parsedPoint.tags).to.equals(point.tags);\n                expect(parsedPoint.fieldsPairs).to.deep.equals([[\"myfield\", \"90\"]]);\n                expect(parsedPoint.tagsNames).to.deep.equals([\"my_tag\"]);\n                expect(parsedPoint.castedTimestamp).not.to.be.undefined;\n            });\n            it(\"accepts custom precision option\", () => {\n                setDefaultDB(\"my_db\");\n                let date = new Date();\n                let point = {\n                    measurement: \"mymeas\",\n                    fields: { myfield: 90 },\n                    timestamp: date,\n                };\n                let parsedPoint = influx.parsePoint(point, { precision: \"ms\" });\n                expect(parsedPoint.castedTimestamp).to.equal(date.getTime().toString());\n            });\n            it(\"accepts custom database option\", () => {\n                let date = new Date();\n                let point = {\n                    measurement: \"mymeas\",\n                    fields: { myfield: 90 },\n                    timestamp: date,\n                };\n                let parsedPoint = influx.parsePoint(point, { database: \"my_db\" });\n                expect(parsedPoint).to.exist;\n            });\n            it(\"uses a schema to coerce\", () => {\n                setDefaultDB(\"my_db\");\n                let date = new Date();\n                let point = {\n                    measurement: \"my_schemed_measure\",\n                    fields: { bool: true, float: 43, int: 42 },\n                    tags: { my_tag: \"2\" },\n                    timestamp: date,\n                };\n                let parsedPoint = influx.parsePoint(point);\n                expect(parsedPoint.measurement).to.equal(point.measurement);\n                expect(parsedPoint.fields).to.equal(point.fields);\n                expect(parsedPoint.tags).to.equals(point.tags);\n                expect(parsedPoint.fieldsPairs).to.deep.equals([\n                    [\"bool\", \"T\"],\n                    [\"float\", \"43\"],\n                    [\"int\", \"42i\"],\n                ]);\n                expect(parsedPoint.tagsNames).to.deep.equals([\"my_tag\"]);\n                expect(parsedPoint.castedTimestamp).not.to.be.undefined;\n            });\n            it(\"should throw an error if extraneous tags are given\", () => {\n                setDefaultDB(\"my_db\");\n                expect(() => {\n                    let point = {\n                        measurement: \"my_schemed_measure\",\n                        tags: { not_a_tag: \"1\" },\n                    };\n                    influx.parsePoint(point);\n                }).to.throw(/extraneous tags/i);\n            });\n            it(\"should throw an error if extraneous fields are given\", () => {\n                setDefaultDB(\"my_db\");\n                expect(() => {\n                    let point = {\n                        measurement: \"my_schemed_measure\",\n                        fields: { not_a_field: \"1\" },\n                    };\n                    influx.parsePoint(point);\n                }).to.throw(/extraneous fields/i);\n            });\n            it(\"should throw an error if invalid value for field type given\", () => {\n                setDefaultDB(\"my_db\");\n                expect(() => {\n                    let point = {\n                        measurement: \"my_schemed_measure\",\n                        fields: { bool: \"lol, not a bool\" },\n                    };\n                    influx.parsePoint(point);\n                }).to.throw(/expected bool/i);\n            });\n        });\n        describe(\".query\", () => {\n            beforeEach(() => setDefaultDB(\"my_db\"));\n            it(\"runs raw queries\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0\",\n                    epoch: undefined,\n                    rp: undefined,\n                    db: \"my_db\",\n                    params: \"{}\",\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.queryRaw(\"select * from series_0\").then((res) => {\n                    expect(res).to.deep.equal(dbFixture(\"selectFromOne\"));\n                });\n            });\n            it(\"parses query output\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0\",\n                    epoch: undefined,\n                    rp: undefined,\n                    db: \"my_db\",\n                    params: \"{}\",\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.query(\"select * from series_0\").then((res) => {\n                    expect(res.slice()).to.deep.equal([\n                        {\n                            time: new Date(\"2016-09-29T02:19:09.38Z\"),\n                            my_tag: \"1\",\n                            my_value: 67,\n                        },\n                        {\n                            time: new Date(\"2016-09-29T02:19:09.379Z\"),\n                            my_tag: \"1\",\n                            my_value: 32,\n                        },\n                    ]);\n                });\n            });\n            it(\"selects from multiple\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0;select * from series_1\",\n                    epoch: undefined,\n                    rp: undefined,\n                    db: \"my_db\",\n                    params: \"{}\",\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.query([\n                    \"select * from series_0\",\n                    \"select * from series_1\",\n                ]);\n            });\n            it(\"passes in options\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0\",\n                    epoch: \"ms\",\n                    rp: \"asdf\",\n                    db: \"my_db\",\n                    params: \"{}\",\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.query([\"select * from series_0\"], {\n                    precision: \"ms\",\n                    retentionPolicy: \"asdf\",\n                });\n            });\n            it(\"rewrites nanosecond precisions\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0\",\n                    epoch: undefined,\n                    rp: \"asdf\",\n                    db: \"my_db\",\n                    params: \"{}\",\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.query([\"select * from series_0\"], {\n                    precision: \"n\",\n                    retentionPolicy: \"asdf\",\n                });\n            });\n            it(\"uses placeholders\", () => {\n                expectQuery(\"json\", {\n                    q: \"select * from series_0 WHERE time > now() - $<since> AND value >= $<minimumValue>\",\n                    epoch: undefined,\n                    rp: \"asdf\",\n                    db: \"my_db\",\n                    params: '{\"since\":\"10s\",\"minimumValue\":12}',\n                }, \"GET\", dbFixture(\"selectFromOne\"));\n                return influx.query([\n                    \"select * from series_0 WHERE time > now() - $<since> AND value >= $<minimumValue>\",\n                ], {\n                    precision: \"n\",\n                    retentionPolicy: \"asdf\",\n                    placeholders: {\n                        since: \"10s\",\n                        minimumValue: 12,\n                    },\n                });\n            });\n        });\n        describe(\".createRetentionPolicy\", () => {\n            beforeEach(() => setDefaultDB(\"my_db\"));\n            it(\"creates non-default policies\", () => {\n                expectQuery(\"json\", 'create retention policy \"7d\\\\\"\" on \"test\" duration 7d replication 1');\n                return influx.createRetentionPolicy('7d\"', {\n                    database: \"test\",\n                    duration: \"7d\",\n                    replication: 1,\n                });\n            });\n            it(\"creates default policies\", () => {\n                expectQuery(\"json\", 'create retention policy \"7d\\\\\"\" on \"my_db\" duration 7d replication 1 default');\n                return influx.createRetentionPolicy('7d\"', {\n                    duration: \"7d\",\n                    replication: 1,\n                    isDefault: true,\n                });\n            });\n        });\n        describe(\".alterRetentionPolicy\", () => {\n            beforeEach(() => setDefaultDB(\"my_db\"));\n            it(\"creates non-default policies\", () => {\n                expectQuery(\"json\", 'alter retention policy \"7d\\\\\"\" on \"test\" duration 7d replication 1');\n                return influx.alterRetentionPolicy('7d\"', {\n                    database: \"test\",\n                    duration: \"7d\",\n                    replication: 1,\n                });\n            });\n            it(\"creates default policies\", () => {\n                expectQuery(\"json\", 'alter retention policy \"7d\\\\\"\" on \"my_db\" duration 7d replication 1 default');\n                return influx.alterRetentionPolicy('7d\"', {\n                    duration: \"7d\",\n                    replication: 1,\n                    isDefault: true,\n                });\n            });\n        });\n        it(\"drops retention policies\", () => {\n            setDefaultDB(\"my_db\");\n            expectQuery(\"json\", 'drop retention policy \"7d\\\\\"\" on \"my_db\"');\n            return influx.dropRetentionPolicy('7d\"');\n        });\n        it(\"shows retention policies\", () => {\n            const data = dbFixture(\"showRetentionPolicies\");\n            expectQuery(\"json\", 'show retention policies on \"my\\\\\"db\"', \"GET\", data);\n            influx.showRetentionPolicies('my\"db');\n            setDefaultDB(\"my_db\");\n            expectQuery(\"json\", 'show retention policies on \"my_db\"', \"GET\", data);\n            return influx.showRetentionPolicies().then((res) => {\n                expect(res.slice()).to.deep.equal([\n                    {\n                        name: \"autogen\",\n                        duration: \"0s\",\n                        shardGroupDuration: \"168h0m0s\",\n                        replicaN: 1,\n                        default: true,\n                    },\n                    {\n                        name: \"7d\",\n                        duration: \"168h0m0s\",\n                        shardGroupDuration: \"24h0m0s\",\n                        replicaN: 1,\n                        default: false,\n                    },\n                ]);\n            });\n        });\n        it(\"shows shards\", () => {\n            setDefaultDB(\"_internal\");\n            expectQuery(\"json\", \"show shards \", \"GET\", dbFixture(\"showShards\"));\n            return influx.showShards().then((res) => {\n                expect(res.slice()).to.deep.equal([\n                    {\n                        id: 1,\n                        database: \"_internal\",\n                        retention_policy: \"monitor\",\n                        shard_group: 1,\n                        start_time: \"2019-06-13T00:00:00Z\",\n                        end_time: \"2019-06-14T00:00:00Z\",\n                        expiry_time: \"2019-06-21T00:00:00Z\",\n                        owners: \"\",\n                    },\n                ]);\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/influx.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 296,
    "kind": "test",
    "name": "describe42",
    "testId": 42,
    "memberof": "unit/influx.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/influx.test.js~describe42",
    "access": null,
    "description": "influxdb",
    "lineNumber": 5
  },
  {
    "__docId__": 297,
    "kind": "test",
    "name": "describe43",
    "testId": 43,
    "memberof": "unit/influx.test.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43",
    "access": null,
    "description": "constructor",
    "lineNumber": 6
  },
  {
    "__docId__": 298,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "unit/influx.test.js~describe42.describe43",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43.it44",
    "access": null,
    "description": "uses default options",
    "lineNumber": 7
  },
  {
    "__docId__": 299,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "unit/influx.test.js~describe42.describe43",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43.it45",
    "access": null,
    "description": "parses dsns",
    "lineNumber": 25
  },
  {
    "__docId__": 300,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "unit/influx.test.js~describe42.describe43",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43.it46",
    "access": null,
    "description": "parses single configs",
    "lineNumber": 44
  },
  {
    "__docId__": 301,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "unit/influx.test.js~describe42.describe43",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43.it47",
    "access": null,
    "description": "parses cluster configs",
    "lineNumber": 62
  },
  {
    "__docId__": 302,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "unit/influx.test.js~describe42.describe43",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe43.it48",
    "access": null,
    "description": "parses parses schema",
    "lineNumber": 82
  },
  {
    "__docId__": 303,
    "kind": "test",
    "name": "describe49",
    "testId": 49,
    "memberof": "unit/influx.test.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49",
    "access": null,
    "description": "methods",
    "lineNumber": 122
  },
  {
    "__docId__": 304,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it50",
    "access": null,
    "description": ".createDatabase()",
    "lineNumber": 183
  },
  {
    "__docId__": 305,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it51",
    "access": null,
    "description": ".dropDatabase()",
    "lineNumber": 189
  },
  {
    "__docId__": 306,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it52",
    "access": null,
    "description": ".dropShard()",
    "lineNumber": 195
  },
  {
    "__docId__": 307,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it53",
    "access": null,
    "description": ".getDatabaseNames()",
    "lineNumber": 199
  },
  {
    "__docId__": 308,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it54",
    "access": null,
    "description": ".getMeasurements()",
    "lineNumber": 205
  },
  {
    "__docId__": 309,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it55",
    "access": null,
    "description": ".getSeries() from all",
    "lineNumber": 215
  },
  {
    "__docId__": 310,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it56",
    "access": null,
    "description": ".getSeries() from single",
    "lineNumber": 250
  },
  {
    "__docId__": 311,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it57",
    "access": null,
    "description": ".dropMeasurement()",
    "lineNumber": 273
  },
  {
    "__docId__": 312,
    "kind": "test",
    "name": "describe58",
    "testId": 58,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58",
    "access": null,
    "description": ".dropSeries()",
    "lineNumber": 280
  },
  {
    "__docId__": 313,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "unit/influx.test.js~describe42.describe49.describe58",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58.it59",
    "access": null,
    "description": "drops with only from clause by string",
    "lineNumber": 282
  },
  {
    "__docId__": 314,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "unit/influx.test.js~describe42.describe49.describe58",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58.it60",
    "access": null,
    "description": "drops with only from clause by builder",
    "lineNumber": 286
  },
  {
    "__docId__": 315,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "unit/influx.test.js~describe42.describe49.describe58",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58.it61",
    "access": null,
    "description": "drops with only where clause by string",
    "lineNumber": 290
  },
  {
    "__docId__": 316,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "unit/influx.test.js~describe42.describe49.describe58",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58.it62",
    "access": null,
    "description": "drops with only where clause by builder",
    "lineNumber": 297
  },
  {
    "__docId__": 317,
    "kind": "test",
    "name": "it63",
    "testId": 63,
    "memberof": "unit/influx.test.js~describe42.describe49.describe58",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe58.it63",
    "access": null,
    "description": "drops with both",
    "lineNumber": 304
  },
  {
    "__docId__": 318,
    "kind": "test",
    "name": "it64",
    "testId": 64,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it64",
    "access": null,
    "description": ".getUsers()",
    "lineNumber": 315
  },
  {
    "__docId__": 319,
    "kind": "test",
    "name": "describe65",
    "testId": 65,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe65",
    "access": null,
    "description": ".createUser()",
    "lineNumber": 324
  },
  {
    "__docId__": 320,
    "kind": "test",
    "name": "it66",
    "testId": 66,
    "memberof": "unit/influx.test.js~describe42.describe49.describe65",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe65.it66",
    "access": null,
    "description": "works with admin specified == true",
    "lineNumber": 325
  },
  {
    "__docId__": 321,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "unit/influx.test.js~describe42.describe49.describe65",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe65.it67",
    "access": null,
    "description": "works with admin specified == false",
    "lineNumber": 329
  },
  {
    "__docId__": 322,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "unit/influx.test.js~describe42.describe49.describe65",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe65.it68",
    "access": null,
    "description": "works with admin unspecified",
    "lineNumber": 333
  },
  {
    "__docId__": 323,
    "kind": "test",
    "name": "describe69",
    "testId": 69,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe69",
    "access": null,
    "description": ".grantPrivilege()",
    "lineNumber": 338
  },
  {
    "__docId__": 324,
    "kind": "test",
    "name": "it70",
    "testId": 70,
    "memberof": "unit/influx.test.js~describe42.describe49.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe69.it70",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 339
  },
  {
    "__docId__": 325,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "unit/influx.test.js~describe42.describe49.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe69.it71",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 343
  },
  {
    "__docId__": 326,
    "kind": "test",
    "name": "it72",
    "testId": 72,
    "memberof": "unit/influx.test.js~describe42.describe49.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe69.it72",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 346
  },
  {
    "__docId__": 327,
    "kind": "test",
    "name": "describe73",
    "testId": 73,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe73",
    "access": null,
    "description": ".revokePrivilege()",
    "lineNumber": 352
  },
  {
    "__docId__": 328,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "unit/influx.test.js~describe42.describe49.describe73",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe73.it74",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 353
  },
  {
    "__docId__": 329,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "unit/influx.test.js~describe42.describe49.describe73",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe73.it75",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 357
  },
  {
    "__docId__": 330,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "unit/influx.test.js~describe42.describe49.describe73",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe73.it76",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 360
  },
  {
    "__docId__": 331,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it77",
    "access": null,
    "description": ".grantAdminPrivilege()",
    "lineNumber": 366
  },
  {
    "__docId__": 332,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it78",
    "access": null,
    "description": ".revokeAdminPrivilege()",
    "lineNumber": 370
  },
  {
    "__docId__": 333,
    "kind": "test",
    "name": "it79",
    "testId": 79,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it79",
    "access": null,
    "description": ".dropUser()",
    "lineNumber": 374
  },
  {
    "__docId__": 334,
    "kind": "test",
    "name": "describe80",
    "testId": 80,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe80",
    "access": null,
    "description": ".createContinuousQuery()",
    "lineNumber": 378
  },
  {
    "__docId__": 335,
    "kind": "test",
    "name": "it81",
    "testId": 81,
    "memberof": "unit/influx.test.js~describe42.describe49.describe80",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe80.it81",
    "access": null,
    "description": "queries correctly no resample",
    "lineNumber": 379
  },
  {
    "__docId__": 336,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "unit/influx.test.js~describe42.describe49.describe80",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe80.it82",
    "access": null,
    "description": "queries correctly with resample",
    "lineNumber": 383
  },
  {
    "__docId__": 337,
    "kind": "test",
    "name": "it83",
    "testId": 83,
    "memberof": "unit/influx.test.js~describe42.describe49.describe80",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe80.it83",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 387
  },
  {
    "__docId__": 338,
    "kind": "test",
    "name": "it84",
    "testId": 84,
    "memberof": "unit/influx.test.js~describe42.describe49.describe80",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe80.it84",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 390
  },
  {
    "__docId__": 339,
    "kind": "test",
    "name": "describe85",
    "testId": 85,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe85",
    "access": null,
    "description": ".dropContinuousQuery()",
    "lineNumber": 396
  },
  {
    "__docId__": 340,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "unit/influx.test.js~describe42.describe49.describe85",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe85.it86",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 397
  },
  {
    "__docId__": 341,
    "kind": "test",
    "name": "it87",
    "testId": 87,
    "memberof": "unit/influx.test.js~describe42.describe49.describe85",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe85.it87",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 401
  },
  {
    "__docId__": 342,
    "kind": "test",
    "name": "it88",
    "testId": 88,
    "memberof": "unit/influx.test.js~describe42.describe49.describe85",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe85.it88",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 404
  },
  {
    "__docId__": 343,
    "kind": "test",
    "name": "describe89",
    "testId": 89,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe89",
    "access": null,
    "description": ".showContinousQueries()",
    "lineNumber": 410
  },
  {
    "__docId__": 344,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "unit/influx.test.js~describe42.describe49.describe89",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe89.it90",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 411
  },
  {
    "__docId__": 345,
    "kind": "test",
    "name": "it91",
    "testId": 91,
    "memberof": "unit/influx.test.js~describe42.describe49.describe89",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe89.it91",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 415
  },
  {
    "__docId__": 346,
    "kind": "test",
    "name": "it92",
    "testId": 92,
    "memberof": "unit/influx.test.js~describe42.describe49.describe89",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe89.it92",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 418
  },
  {
    "__docId__": 347,
    "kind": "test",
    "name": "describe93",
    "testId": 93,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93",
    "access": null,
    "description": ".writePoints()",
    "lineNumber": 424
  },
  {
    "__docId__": 348,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it94",
    "access": null,
    "description": "writes with all options specified without a schema",
    "lineNumber": 425
  },
  {
    "__docId__": 349,
    "kind": "test",
    "name": "it95",
    "testId": 95,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it95",
    "access": null,
    "description": "writes using default options without a schema",
    "lineNumber": 444
  },
  {
    "__docId__": 350,
    "kind": "test",
    "name": "it96",
    "testId": 96,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it96",
    "access": null,
    "description": "uses a schema to coerce",
    "lineNumber": 460
  },
  {
    "__docId__": 351,
    "kind": "test",
    "name": "it97",
    "testId": 97,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it97",
    "access": null,
    "description": "can accept a schema at runtime",
    "lineNumber": 479
  },
  {
    "__docId__": 352,
    "kind": "test",
    "name": "it98",
    "testId": 98,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it98",
    "access": null,
    "description": "handles lack of tags",
    "lineNumber": 508
  },
  {
    "__docId__": 353,
    "kind": "test",
    "name": "it99",
    "testId": 99,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it99",
    "access": null,
    "description": "handles lack of fields",
    "lineNumber": 521
  },
  {
    "__docId__": 354,
    "kind": "test",
    "name": "it100",
    "testId": 100,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it100",
    "access": null,
    "description": "handles multiple tags",
    "lineNumber": 534
  },
  {
    "__docId__": 355,
    "kind": "test",
    "name": "it101",
    "testId": 101,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it101",
    "access": null,
    "description": "writes with the .writeMeasurement method",
    "lineNumber": 547
  },
  {
    "__docId__": 356,
    "kind": "test",
    "name": "it102",
    "testId": 102,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it102",
    "access": null,
    "description": "accepts nanoseconds (as ms)",
    "lineNumber": 562
  },
  {
    "__docId__": 357,
    "kind": "test",
    "name": "it103",
    "testId": 103,
    "memberof": "unit/influx.test.js~describe42.describe49.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe93.it103",
    "access": null,
    "description": "accepts timestamp overriding",
    "lineNumber": 577
  },
  {
    "__docId__": 358,
    "kind": "test",
    "name": "describe104",
    "testId": 104,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104",
    "access": null,
    "description": ".parsePoint()",
    "lineNumber": 593
  },
  {
    "__docId__": 359,
    "kind": "test",
    "name": "it105",
    "testId": 105,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it105",
    "access": null,
    "description": "parses a minimal valid point with default options",
    "lineNumber": 594
  },
  {
    "__docId__": 360,
    "kind": "test",
    "name": "it106",
    "testId": 106,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it106",
    "access": null,
    "description": "parses a point with fields, tags, and timestamp",
    "lineNumber": 608
  },
  {
    "__docId__": 361,
    "kind": "test",
    "name": "it107",
    "testId": 107,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it107",
    "access": null,
    "description": "accepts custom precision option",
    "lineNumber": 625
  },
  {
    "__docId__": 362,
    "kind": "test",
    "name": "it108",
    "testId": 108,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it108",
    "access": null,
    "description": "accepts custom database option",
    "lineNumber": 636
  },
  {
    "__docId__": 363,
    "kind": "test",
    "name": "it109",
    "testId": 109,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it109",
    "access": null,
    "description": "uses a schema to coerce",
    "lineNumber": 646
  },
  {
    "__docId__": 364,
    "kind": "test",
    "name": "it110",
    "testId": 110,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it110",
    "access": null,
    "description": "should throw an error if extraneous tags are given",
    "lineNumber": 667
  },
  {
    "__docId__": 365,
    "kind": "test",
    "name": "it111",
    "testId": 111,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it111",
    "access": null,
    "description": "should throw an error if extraneous fields are given",
    "lineNumber": 677
  },
  {
    "__docId__": 366,
    "kind": "test",
    "name": "it112",
    "testId": 112,
    "memberof": "unit/influx.test.js~describe42.describe49.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe104.it112",
    "access": null,
    "description": "should throw an error if invalid value for field type given",
    "lineNumber": 687
  },
  {
    "__docId__": 367,
    "kind": "test",
    "name": "describe113",
    "testId": 113,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113",
    "access": null,
    "description": ".query",
    "lineNumber": 698
  },
  {
    "__docId__": 368,
    "kind": "test",
    "name": "it114",
    "testId": 114,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it114",
    "access": null,
    "description": "runs raw queries",
    "lineNumber": 700
  },
  {
    "__docId__": 369,
    "kind": "test",
    "name": "it115",
    "testId": 115,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it115",
    "access": null,
    "description": "parses query output",
    "lineNumber": 712
  },
  {
    "__docId__": 370,
    "kind": "test",
    "name": "it116",
    "testId": 116,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it116",
    "access": null,
    "description": "selects from multiple",
    "lineNumber": 735
  },
  {
    "__docId__": 371,
    "kind": "test",
    "name": "it117",
    "testId": 117,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it117",
    "access": null,
    "description": "passes in options",
    "lineNumber": 748
  },
  {
    "__docId__": 372,
    "kind": "test",
    "name": "it118",
    "testId": 118,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it118",
    "access": null,
    "description": "rewrites nanosecond precisions",
    "lineNumber": 761
  },
  {
    "__docId__": 373,
    "kind": "test",
    "name": "it119",
    "testId": 119,
    "memberof": "unit/influx.test.js~describe42.describe49.describe113",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe113.it119",
    "access": null,
    "description": "uses placeholders",
    "lineNumber": 774
  },
  {
    "__docId__": 374,
    "kind": "test",
    "name": "describe120",
    "testId": 120,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe120",
    "access": null,
    "description": ".createRetentionPolicy",
    "lineNumber": 794
  },
  {
    "__docId__": 375,
    "kind": "test",
    "name": "it121",
    "testId": 121,
    "memberof": "unit/influx.test.js~describe42.describe49.describe120",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe120.it121",
    "access": null,
    "description": "creates non-default policies",
    "lineNumber": 796
  },
  {
    "__docId__": 376,
    "kind": "test",
    "name": "it122",
    "testId": 122,
    "memberof": "unit/influx.test.js~describe42.describe49.describe120",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe120.it122",
    "access": null,
    "description": "creates default policies",
    "lineNumber": 804
  },
  {
    "__docId__": 377,
    "kind": "test",
    "name": "describe123",
    "testId": 123,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe123",
    "access": null,
    "description": ".alterRetentionPolicy",
    "lineNumber": 813
  },
  {
    "__docId__": 378,
    "kind": "test",
    "name": "it124",
    "testId": 124,
    "memberof": "unit/influx.test.js~describe42.describe49.describe123",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe123.it124",
    "access": null,
    "description": "creates non-default policies",
    "lineNumber": 815
  },
  {
    "__docId__": 379,
    "kind": "test",
    "name": "it125",
    "testId": 125,
    "memberof": "unit/influx.test.js~describe42.describe49.describe123",
    "testDepth": 3,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.describe123.it125",
    "access": null,
    "description": "creates default policies",
    "lineNumber": 823
  },
  {
    "__docId__": 380,
    "kind": "test",
    "name": "it126",
    "testId": 126,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it126",
    "access": null,
    "description": "drops retention policies",
    "lineNumber": 832
  },
  {
    "__docId__": 381,
    "kind": "test",
    "name": "it127",
    "testId": 127,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it127",
    "access": null,
    "description": "shows retention policies",
    "lineNumber": 837
  },
  {
    "__docId__": 382,
    "kind": "test",
    "name": "it128",
    "testId": 128,
    "memberof": "unit/influx.test.js~describe42.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "unit/influx.test.js~describe42.describe49.it128",
    "access": null,
    "description": "shows shards",
    "lineNumber": 862
  },
  {
    "__docId__": 383,
    "kind": "testFile",
    "name": "unit/pool.test.js",
    "content": "/* eslint-env node, browser, mocha */\n/* eslint-disable no-unused-expressions */\n/* eslint-disable @typescript-eslint/no-var-requires */\nimport { expect } from \"chai\";\nimport * as http from \"http\";\nimport * as sinon from \"sinon\";\nimport * as https from \"https\";\nimport { ExponentialBackoff } from \"../../src/backoff/exponential\";\nimport { ConstantBackoff } from \"../../src/backoff/constant\";\nimport { Pool, RequestError, ServiceNotAvailableError } from \"../../src/pool\";\nconst hosts = 2;\ndescribe(\"pool\", () => {\n    let pool;\n    let clock;\n    let server;\n    let sid; // Random string to avoid conflicts with other running tests\n    const createPool = (backoff) => {\n        return new Pool({\n            backoff: backoff ||\n                new ExponentialBackoff({\n                    initial: 300,\n                    random: 0,\n                    max: 10 * 1000,\n                }),\n        });\n    };\n    beforeEach((done) => {\n        pool = createPool();\n        sid = `${Date.now()}${Math.random()}`;\n        if (process.env.WEBPACK) {\n            for (let i = 0; i < hosts; i += 1) {\n                pool.addHost(location.origin);\n            }\n            done();\n        }\n        else {\n            const handler = require(\"../fixture/pool-middleware\"); // eslint-disable-line @typescript-eslint/no-require-imports\n            server = http.createServer(handler());\n            server.listen(3005, () => {\n                for (let i = 0; i < hosts; i += 1) {\n                    pool.addHost(`http://127.0.0.1:${3005}`);\n                }\n                done();\n            });\n        }\n    });\n    afterEach((done) => {\n        if (clock) {\n            clock.restore();\n        }\n        if (process.env.WEBPACK) {\n            done();\n        }\n        else {\n            server.close(() => done());\n        }\n    });\n    it(\"attempts to make an https request\", () => {\n        const p = createPool();\n        p.addHost(\"https://httpbin.org\");\n        return p.json({ method: \"GET\", path: \"/get\" });\n    });\n    it(\"passes through request options\", () => {\n        const spy = sinon.spy(https, \"request\");\n        const p = createPool();\n        p.addHost(\"https://httpbin.org\", { rejectUnauthorized: false });\n        return p.json({ method: \"GET\", path: \"/get\" }).then(() => {\n            expect(spy.args[0][0].rejectUnauthorized).to.be.false;\n        });\n    });\n    it(\"valid request data content length\", () => {\n        const p = createPool();\n        const body = \"\\u00FF\";\n        p.addHost(\"https://httpbin.org\");\n        p.json({ method: \"POST\", path: \"/post\", body: body }).then((data) => expect(data.data).to.equal(body));\n    });\n    it(\"handles unicode chunks correctly\", () => {\n        const p = createPool();\n        const body = \"\".repeat(40960);\n        p.addHost(\"https://httpbin.org\");\n        p.json({ method: \"POST\", path: \"/post\", body: body }).then((data) => expect(data.data).to.equal(body));\n    });\n    describe(\"request generators\", () => {\n        it(\"makes a text request\", () => {\n            return pool\n                .text({ method: \"GET\", path: \"/pool/json\" })\n                .then((data) => expect(data).to.equal('{\"ok\":true}'));\n        });\n        it(\"includes request query strings and bodies\", () => {\n            return pool\n                .json({\n                method: \"POST\",\n                path: \"/pool/echo\",\n                query: { a: 42 },\n                body: \"asdf\",\n            })\n                .then((data) => {\n                expect(data).to.deep.equal({\n                    query: \"a=42\",\n                    body: \"asdf\",\n                    method: \"POST\",\n                });\n            });\n        });\n        it(\"discards responses\", () => {\n            return pool.discard({ method: \"GET\", path: \"/pool/204\" });\n        });\n        it(\"parses JSON responses\", () => {\n            return pool\n                .json({ method: \"GET\", path: \"/pool/json\" })\n                .then((data) => expect(data).to.deep.equal({ ok: true }));\n        });\n        it(\"errors if JSON parsing fails\", () => {\n            return pool\n                .json({ method: \"GET\", path: \"/pool/badjson\" })\n                .then(() => {\n                throw new Error(\"Expected to have thrown\");\n            })\n                .catch((err) => expect(err).to.be.an.instanceof(SyntaxError));\n        });\n    });\n    it(\"times out requests\", () => {\n        pool._timeout = 1;\n        return pool\n            .text({ method: \"GET\", path: \"/pool/wait-json\" })\n            .then(() => {\n            throw new Error(\"Expected to have thrown\");\n        })\n            .catch((err) => expect(err).be.an.instanceof(ServiceNotAvailableError))\n            .then(() => {\n            pool._timeout = 10000;\n        });\n    });\n    it(\"retries on a request error\", () => {\n        return pool\n            .text({ method: \"GET\", path: `/pool/altFail-${sid}/json` })\n            .then((body) => expect(body).to.equal('{\"ok\":true}'));\n    });\n    it(\"fails if too many errors happen\", () => {\n        expect(pool.hostIsAvailable()).to.be.true;\n        return pool\n            .discard({ method: \"GET\", path: \"/pool/502\" })\n            .then(() => {\n            throw new Error(\"Expected to have thrown\");\n        })\n            .catch((err) => {\n            expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n            expect(pool.hostIsAvailable()).to.be.false;\n        });\n    });\n    it(\"calls back immediately on un-retryable error\", () => {\n        return pool\n            .discard({ method: \"GET\", path: \"/pool/400\" })\n            .then(() => {\n            throw new Error(\"Expected to have thrown\");\n        })\n            .catch((err) => {\n            expect(err).to.be.an.instanceof(RequestError);\n            expect(err.res.statusCode).to.equal(400);\n            expect(pool.hostIsAvailable()).to.be.true;\n        });\n    });\n    it(\"pings servers\", () => {\n        return pool.ping(1000, `/pool/altFail-${sid}/ping`).then((results) => {\n            if (results[0].online) {\n                [results[0], results[1]] = [results[1], results[0]];\n            }\n            expect(results[0].online).to.be.false;\n            expect(results[1].online).to.be.true;\n            expect(results[1].version).to.equal(\"v1.0.0\");\n        });\n    });\n    it(\"times out in pings\", () => {\n        return pool.ping(1).then((results) => {\n            expect(results[0].online).to.be.false;\n            expect(results[1].online).to.be.false;\n        });\n    });\n    describe(\"backoff\", () => {\n        describe(\"exponential\", () => {\n            beforeEach(() => {\n                clock = sinon.useFakeTimers();\n                return pool.discard({ method: \"GET\", path: \"/pool/502\" }).catch(() => {\n                    /* ignore */\n                });\n            });\n            it(\"should error if there are no available hosts\", () => {\n                return pool\n                    .discard({ method: \"GET\", path: \"/pool/json\" })\n                    .then(() => {\n                    throw new Error(\"Expected to have thrown\");\n                })\n                    .catch((err) => {\n                    expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                    expect(err.message).to.equal(\"No host available\");\n                });\n            });\n            it(\"should reenable hosts after the backoff expires\", () => {\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n            });\n            it(\"should back off if failures continue\", () => {\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n                return pool\n                    .discard({ method: \"GET\", path: \"/pool/502\" })\n                    .then(() => {\n                    throw new Error(\"Expected to have thrown\");\n                })\n                    .catch((err) => {\n                    expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                    expect(pool.hostIsAvailable()).to.be.false;\n                    clock.tick(300);\n                    expect(pool.hostIsAvailable()).to.be.false;\n                    clock.tick(300);\n                    expect(pool.hostIsAvailable()).to.be.true;\n                });\n            });\n            it(\"should reset backoff after success\", () => {\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n                return pool\n                    .discard({ method: \"GET\", path: \"/pool/204\" })\n                    .then(() => {\n                    return pool.discard({ method: \"GET\", path: \"/pool/502\" });\n                })\n                    .then(() => {\n                    throw new Error(\"Expected to have thrown\");\n                })\n                    .catch((err) => {\n                    expect(err).not.to.be.undefined;\n                    expect(pool.hostIsAvailable()).to.be.false;\n                    clock.tick(300);\n                    expect(pool.hostIsAvailable()).to.be.true;\n                });\n            });\n        });\n        describe(\"constant\", () => {\n            const createConstantBackoffPool = (options) => {\n                const p = createPool(new ConstantBackoff(options));\n                for (let i = 0; i < hosts; i += 1) {\n                    p.addHost(process.env.WEBPACK ? location.origin : `http://127.0.0.1:${3005}`);\n                }\n                return p;\n            };\n            it(\"should disable hosts if backoff delay is greater than zero\", () => {\n                const p = createConstantBackoffPool({ delay: 300, jitter: 0 });\n                return p\n                    .discard({ method: \"GET\", path: \"/pool/502\" })\n                    .then(() => {\n                    throw new Error(\"Expected to have thrown\");\n                })\n                    .catch((err) => {\n                    expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                    expect(err.message).to.equal(\"Bad Gateway\");\n                    expect(p.getHostsDisabled().length).to.be.greaterThan(0);\n                });\n            });\n            it(\"should not disable hosts if backoff delay is zero\", () => {\n                const p = createConstantBackoffPool({ delay: 0, jitter: 0 });\n                return p\n                    .discard({ method: \"GET\", path: \"/pool/502\" })\n                    .then(() => {\n                    throw new Error(\"Expected to have thrown\");\n                })\n                    .catch((err) => {\n                    expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                    expect(err.message).to.equal(\"Bad Gateway\");\n                    expect(p.getHostsDisabled().length).to.be.equal(0);\n                });\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/pool.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 384,
    "kind": "test",
    "name": "describe129",
    "testId": 129,
    "memberof": "unit/pool.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/pool.test.js~describe129",
    "access": null,
    "description": "pool",
    "lineNumber": 12
  },
  {
    "__docId__": 385,
    "kind": "test",
    "name": "it130",
    "testId": 130,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it130",
    "access": null,
    "description": "attempts to make an https request",
    "lineNumber": 58
  },
  {
    "__docId__": 386,
    "kind": "test",
    "name": "it131",
    "testId": 131,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it131",
    "access": null,
    "description": "passes through request options",
    "lineNumber": 63
  },
  {
    "__docId__": 387,
    "kind": "test",
    "name": "it132",
    "testId": 132,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it132",
    "access": null,
    "description": "valid request data content length",
    "lineNumber": 71
  },
  {
    "__docId__": 388,
    "kind": "test",
    "name": "it133",
    "testId": 133,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it133",
    "access": null,
    "description": "handles unicode chunks correctly",
    "lineNumber": 77
  },
  {
    "__docId__": 389,
    "kind": "test",
    "name": "describe134",
    "testId": 134,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134",
    "access": null,
    "description": "request generators",
    "lineNumber": 83
  },
  {
    "__docId__": 390,
    "kind": "test",
    "name": "it135",
    "testId": 135,
    "memberof": "unit/pool.test.js~describe129.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134.it135",
    "access": null,
    "description": "makes a text request",
    "lineNumber": 84
  },
  {
    "__docId__": 391,
    "kind": "test",
    "name": "it136",
    "testId": 136,
    "memberof": "unit/pool.test.js~describe129.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134.it136",
    "access": null,
    "description": "includes request query strings and bodies",
    "lineNumber": 89
  },
  {
    "__docId__": 392,
    "kind": "test",
    "name": "it137",
    "testId": 137,
    "memberof": "unit/pool.test.js~describe129.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134.it137",
    "access": null,
    "description": "discards responses",
    "lineNumber": 105
  },
  {
    "__docId__": 393,
    "kind": "test",
    "name": "it138",
    "testId": 138,
    "memberof": "unit/pool.test.js~describe129.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134.it138",
    "access": null,
    "description": "parses JSON responses",
    "lineNumber": 108
  },
  {
    "__docId__": 394,
    "kind": "test",
    "name": "it139",
    "testId": 139,
    "memberof": "unit/pool.test.js~describe129.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe134.it139",
    "access": null,
    "description": "errors if JSON parsing fails",
    "lineNumber": 113
  },
  {
    "__docId__": 395,
    "kind": "test",
    "name": "it140",
    "testId": 140,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it140",
    "access": null,
    "description": "times out requests",
    "lineNumber": 122
  },
  {
    "__docId__": 396,
    "kind": "test",
    "name": "it141",
    "testId": 141,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it141",
    "access": null,
    "description": "retries on a request error",
    "lineNumber": 134
  },
  {
    "__docId__": 397,
    "kind": "test",
    "name": "it142",
    "testId": 142,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it142",
    "access": null,
    "description": "fails if too many errors happen",
    "lineNumber": 139
  },
  {
    "__docId__": 398,
    "kind": "test",
    "name": "it143",
    "testId": 143,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it143",
    "access": null,
    "description": "calls back immediately on un-retryable error",
    "lineNumber": 151
  },
  {
    "__docId__": 399,
    "kind": "test",
    "name": "it144",
    "testId": 144,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it144",
    "access": null,
    "description": "pings servers",
    "lineNumber": 163
  },
  {
    "__docId__": 400,
    "kind": "test",
    "name": "it145",
    "testId": 145,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.it145",
    "access": null,
    "description": "times out in pings",
    "lineNumber": 173
  },
  {
    "__docId__": 401,
    "kind": "test",
    "name": "describe146",
    "testId": 146,
    "memberof": "unit/pool.test.js~describe129",
    "testDepth": 1,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146",
    "access": null,
    "description": "backoff",
    "lineNumber": 179
  },
  {
    "__docId__": 402,
    "kind": "test",
    "name": "describe147",
    "testId": 147,
    "memberof": "unit/pool.test.js~describe129.describe146",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe147",
    "access": null,
    "description": "exponential",
    "lineNumber": 180
  },
  {
    "__docId__": 403,
    "kind": "test",
    "name": "it148",
    "testId": 148,
    "memberof": "unit/pool.test.js~describe129.describe146.describe147",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe147.it148",
    "access": null,
    "description": "should error if there are no available hosts",
    "lineNumber": 187
  },
  {
    "__docId__": 404,
    "kind": "test",
    "name": "it149",
    "testId": 149,
    "memberof": "unit/pool.test.js~describe129.describe146.describe147",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe147.it149",
    "access": null,
    "description": "should reenable hosts after the backoff expires",
    "lineNumber": 198
  },
  {
    "__docId__": 405,
    "kind": "test",
    "name": "it150",
    "testId": 150,
    "memberof": "unit/pool.test.js~describe129.describe146.describe147",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe147.it150",
    "access": null,
    "description": "should back off if failures continue",
    "lineNumber": 203
  },
  {
    "__docId__": 406,
    "kind": "test",
    "name": "it151",
    "testId": 151,
    "memberof": "unit/pool.test.js~describe129.describe146.describe147",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe147.it151",
    "access": null,
    "description": "should reset backoff after success",
    "lineNumber": 220
  },
  {
    "__docId__": 407,
    "kind": "test",
    "name": "describe152",
    "testId": 152,
    "memberof": "unit/pool.test.js~describe129.describe146",
    "testDepth": 2,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe152",
    "access": null,
    "description": "constant",
    "lineNumber": 239
  },
  {
    "__docId__": 408,
    "kind": "test",
    "name": "it153",
    "testId": 153,
    "memberof": "unit/pool.test.js~describe129.describe146.describe152",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe152.it153",
    "access": null,
    "description": "should disable hosts if backoff delay is greater than zero",
    "lineNumber": 247
  },
  {
    "__docId__": 409,
    "kind": "test",
    "name": "it154",
    "testId": 154,
    "memberof": "unit/pool.test.js~describe129.describe146.describe152",
    "testDepth": 3,
    "static": true,
    "longname": "unit/pool.test.js~describe129.describe146.describe152.it154",
    "access": null,
    "description": "should not disable hosts if backoff delay is zero",
    "lineNumber": 260
  },
  {
    "__docId__": 410,
    "kind": "testFile",
    "name": "unit/result.test.js",
    "content": "/* eslint-env node, mocha */\nimport { expect } from \"chai\";\nimport * as results from \"../../src/results\";\ndescribe(\"results\", () => {\n    it(\"parses a empty result\", () => {\n        expect(results\n            .parse({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            columns: [\"time\", \"mean\"],\n                            values: [],\n                        },\n                    ],\n                },\n            ],\n        })\n            .slice()).to.deep.equal([]);\n    });\n    it(\"parses a simple table of results\", () => {\n        const r = results.parseSingle({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            columns: [\"time\", \"mean\"],\n                            values: [\n                                [\"2016-09-25T16:12:51.787Z\", 42],\n                                [\"2016-09-25T16:34:31.999Z\", 44],\n                            ],\n                        },\n                    ],\n                },\n            ],\n        });\n        expect(r.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n        expect(r.groups()).to.deep.equal([\n            { name: \"test_series\", tags: {}, rows: r.slice() },\n        ]);\n        expect(r.group({ tag: \"a\" })).to.deep.equal([]);\n    });\n    it(\"parses a results with second-precision\", () => {\n        const r = results.parseSingle({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            columns: [\"time\", \"mean\"],\n                            values: [\n                                [\"2015-08-18T00:00:00Z\", 42],\n                                [\"2015-08-18T00:06:00Z\", 44],\n                            ],\n                        },\n                    ],\n                },\n            ],\n        });\n        expect(r.slice()).to.deep.equal([\n            { time: new Date(1439856000000), mean: 42 },\n            { time: new Date(1439856360000), mean: 44 },\n        ]);\n        expect(r[0].time.getNanoTime()).to.equal(\"1439856000000000000\");\n    });\n    it(\"parses alternate epochs\", () => {\n        const r1 = results.parseSingle({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            columns: [\"time\", \"mean\"],\n                            values: [\n                                [1474819971787, 42],\n                                [1474821271999, 44],\n                            ],\n                        },\n                    ],\n                },\n            ],\n        }, \"ms\");\n        expect(r1.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n        const r2 = results.parseSingle({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            columns: [\"time\", \"mean\"],\n                            values: [\n                                [1474819971787000, 42],\n                                [1474821271999000, 44],\n                            ],\n                        },\n                    ],\n                },\n            ],\n        }, \"u\");\n        expect(r2.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n    });\n    it(\"parses grouped results\", () => {\n        const r = results.parseSingle({\n            results: [\n                {\n                    series: [\n                        {\n                            name: \"test_series\",\n                            tags: { tag: \"a\" },\n                            columns: [\"mean\"],\n                            values: [[1], [2]],\n                        },\n                        {\n                            name: \"test_series\",\n                            tags: { tag: \"b\" },\n                            columns: [\"mean\"],\n                            values: [[3], [4]],\n                        },\n                    ],\n                },\n            ],\n        });\n        expect(r.slice()).to.deep.equal([\n            { tag: \"a\", mean: 1 },\n            { tag: \"a\", mean: 2 },\n            { tag: \"b\", mean: 3 },\n            { tag: \"b\", mean: 4 },\n        ]);\n        expect(r.groups()).to.deep.equal([\n            {\n                name: \"test_series\",\n                tags: { tag: \"a\" },\n                rows: [\n                    { tag: \"a\", mean: 1 },\n                    { tag: \"a\", mean: 2 },\n                ],\n            },\n            {\n                name: \"test_series\",\n                tags: { tag: \"b\" },\n                rows: [\n                    { tag: \"b\", mean: 3 },\n                    { tag: \"b\", mean: 4 },\n                ],\n            },\n        ]);\n        expect(r.group({ tag: \"a\" })).to.deep.equal([\n            { tag: \"a\", mean: 1 },\n            { tag: \"a\", mean: 2 },\n        ]);\n        expect(r.group({ tag: \"b\" })).to.deep.equal([\n            { tag: \"b\", mean: 3 },\n            { tag: \"b\", mean: 4 },\n        ]);\n        expect(r.group({ tag: \"c\" })).to.deep.equal([]);\n    });\n    it(\"parses empty series\", () => {\n        const r1 = results.parseSingle({\n            results: [{}],\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it(\"parses empty values\", () => {\n        const r1 = results.parseSingle({\n            results: [\n                {\n                    series: [{ columns: [\"user\", \"admin\"] }],\n                },\n            ],\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it(\"throws error on an errorful series\", () => {\n        expect(() => results.parseSingle({\n            results: [{ error: \"user already exists\" }],\n        })).to.throw(/already exists/);\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/result.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 411,
    "kind": "test",
    "name": "describe155",
    "testId": 155,
    "memberof": "unit/result.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/result.test.js~describe155",
    "access": null,
    "description": "results",
    "lineNumber": 4
  },
  {
    "__docId__": 412,
    "kind": "test",
    "name": "it156",
    "testId": 156,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it156",
    "access": null,
    "description": "parses a empty result",
    "lineNumber": 5
  },
  {
    "__docId__": 413,
    "kind": "test",
    "name": "it157",
    "testId": 157,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it157",
    "access": null,
    "description": "parses a simple table of results",
    "lineNumber": 22
  },
  {
    "__docId__": 414,
    "kind": "test",
    "name": "it158",
    "testId": 158,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it158",
    "access": null,
    "description": "parses a results with second-precision",
    "lineNumber": 48
  },
  {
    "__docId__": 415,
    "kind": "test",
    "name": "it159",
    "testId": 159,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it159",
    "access": null,
    "description": "parses alternate epochs",
    "lineNumber": 71
  },
  {
    "__docId__": 416,
    "kind": "test",
    "name": "it160",
    "testId": 160,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it160",
    "access": null,
    "description": "parses grouped results",
    "lineNumber": 113
  },
  {
    "__docId__": 417,
    "kind": "test",
    "name": "it161",
    "testId": 161,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it161",
    "access": null,
    "description": "parses empty series",
    "lineNumber": 168
  },
  {
    "__docId__": 418,
    "kind": "test",
    "name": "it162",
    "testId": 162,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it162",
    "access": null,
    "description": "parses empty values",
    "lineNumber": 174
  },
  {
    "__docId__": 419,
    "kind": "test",
    "name": "it163",
    "testId": 163,
    "memberof": "unit/result.test.js~describe155",
    "testDepth": 1,
    "static": true,
    "longname": "unit/result.test.js~describe155.it163",
    "access": null,
    "description": "throws error on an errorful series",
    "lineNumber": 184
  },
  {
    "__docId__": 420,
    "kind": "testFile",
    "name": "unit/schema.test.js",
    "content": "/* eslint-env node, mocha */\nimport { expect } from \"chai\";\nimport { FieldType } from \"../../src/grammar\";\nimport { coerceBadly, Schema } from \"../../src/schema\";\ndescribe(\"schema\", () => {\n    let schema;\n    beforeEach(() => {\n        schema = new Schema({\n            database: \"my_db\",\n            measurement: \"my_measure\",\n            tags: [\"my_tag\"],\n            fields: {\n                int: FieldType.INTEGER,\n                float: FieldType.FLOAT,\n                string: FieldType.STRING,\n                bool: FieldType.BOOLEAN,\n            },\n        });\n    });\n    describe(\"coerceBadly\", () => {\n        it(\"apparently works\", () => {\n            expect(coerceBadly({\n                b: 42,\n                a: true,\n                c: 'hello\"world',\n            })).to.deep.equal([\n                [\"a\", \"true\"],\n                [\"b\", \"42\"],\n                [\"c\", '\"hello\\\\\"world\"'],\n            ]);\n        });\n    });\n    describe(\"basic schema\", () => {\n        it(\"coerces data correctly\", () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: 43,\n                string: 'hello\"world',\n                bool: true,\n            })).to.deep.equal([\n                [\"bool\", \"T\"],\n                [\"float\", \"43\"],\n                [\"int\", \"42i\"],\n                [\"string\", '\"hello\\\\\"world\"'],\n            ]);\n        });\n        it(\"accepts partial data\", () => {\n            expect(schema.coerceFields({\n                int: 42,\n            })).to.deep.equal([[\"int\", \"42i\"]]);\n        });\n        it(\"coerces numeric string data\", () => {\n            expect(schema.coerceFields({\n                int: \"42\",\n            })).to.deep.equal([[\"int\", \"42i\"]]);\n        });\n        it(\"strips null and undefined values\", () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: undefined,\n                bool: null,\n            })).to.deep.equal([[\"int\", \"42i\"]]);\n        });\n        it(\"throws if wrong data type provided (bool)\", () => {\n            expect(() => schema.coerceFields({ bool: 42 })).to.throw(/expected bool/i);\n            expect(() => schema.coerceFields({ bool: \"asdf\" })).to.throw(/expected bool/i);\n        });\n        it(\"throws if wrong data type provided (float)\", () => {\n            expect(() => schema.coerceFields({ float: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ float: \"asdf\" })).to.throw(/expected numeric/i);\n        });\n        it(\"throws if wrong data type provided (int)\", () => {\n            expect(() => schema.coerceFields({ int: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ int: \"asdf\" })).to.throw(/expected numeric/i);\n        });\n        it(\"allows valid tags\", () => {\n            expect(schema.checkTags({ my_tag: \"value\" })).to.deep.equal([\"my_tag\"]);\n            expect(schema.checkTags({})).to.deep.equal([]);\n        });\n        it(\"throws if invalid tags are provided\", () => {\n            expect(() => schema.checkTags({ whatever: \"value\" })).to.throw(/extraneous tags/i);\n        });\n        it(\"throws if invalid fields are provided\", () => {\n            expect(() => expect(schema.coerceFields({ x: 42 }))).to.throw(/extraneous fields/i);\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ben/Projects/node-influx/lib/test/unit/schema.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 421,
    "kind": "test",
    "name": "describe164",
    "testId": 164,
    "memberof": "unit/schema.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "unit/schema.test.js~describe164",
    "access": null,
    "description": "schema",
    "lineNumber": 5
  },
  {
    "__docId__": 422,
    "kind": "test",
    "name": "describe165",
    "testId": 165,
    "memberof": "unit/schema.test.js~describe164",
    "testDepth": 1,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe165",
    "access": null,
    "description": "coerceBadly",
    "lineNumber": 20
  },
  {
    "__docId__": 423,
    "kind": "test",
    "name": "it166",
    "testId": 166,
    "memberof": "unit/schema.test.js~describe164.describe165",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe165.it166",
    "access": null,
    "description": "apparently works",
    "lineNumber": 21
  },
  {
    "__docId__": 424,
    "kind": "test",
    "name": "describe167",
    "testId": 167,
    "memberof": "unit/schema.test.js~describe164",
    "testDepth": 1,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167",
    "access": null,
    "description": "basic schema",
    "lineNumber": 33
  },
  {
    "__docId__": 425,
    "kind": "test",
    "name": "it168",
    "testId": 168,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it168",
    "access": null,
    "description": "coerces data correctly",
    "lineNumber": 34
  },
  {
    "__docId__": 426,
    "kind": "test",
    "name": "it169",
    "testId": 169,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it169",
    "access": null,
    "description": "accepts partial data",
    "lineNumber": 47
  },
  {
    "__docId__": 427,
    "kind": "test",
    "name": "it170",
    "testId": 170,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it170",
    "access": null,
    "description": "coerces numeric string data",
    "lineNumber": 52
  },
  {
    "__docId__": 428,
    "kind": "test",
    "name": "it171",
    "testId": 171,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it171",
    "access": null,
    "description": "strips null and undefined values",
    "lineNumber": 57
  },
  {
    "__docId__": 429,
    "kind": "test",
    "name": "it172",
    "testId": 172,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it172",
    "access": null,
    "description": "throws if wrong data type provided (bool)",
    "lineNumber": 64
  },
  {
    "__docId__": 430,
    "kind": "test",
    "name": "it173",
    "testId": 173,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it173",
    "access": null,
    "description": "throws if wrong data type provided (float)",
    "lineNumber": 68
  },
  {
    "__docId__": 431,
    "kind": "test",
    "name": "it174",
    "testId": 174,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it174",
    "access": null,
    "description": "throws if wrong data type provided (int)",
    "lineNumber": 72
  },
  {
    "__docId__": 432,
    "kind": "test",
    "name": "it175",
    "testId": 175,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it175",
    "access": null,
    "description": "allows valid tags",
    "lineNumber": 76
  },
  {
    "__docId__": 433,
    "kind": "test",
    "name": "it176",
    "testId": 176,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it176",
    "access": null,
    "description": "throws if invalid tags are provided",
    "lineNumber": 80
  },
  {
    "__docId__": 434,
    "kind": "test",
    "name": "it177",
    "testId": 177,
    "memberof": "unit/schema.test.js~describe164.describe167",
    "testDepth": 2,
    "static": true,
    "longname": "unit/schema.test.js~describe164.describe167.it177",
    "access": null,
    "description": "throws if invalid fields are provided",
    "lineNumber": 83
  }
]