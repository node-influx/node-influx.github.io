<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">unit/influx.test.js | node-influx</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="InfluxDB Client"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="node-influx"><meta property="twitter:description" content="InfluxDB Client"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/node-influx/node-influx.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Measurement.html">Measurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~InfluxDB.html">InfluxDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~Pool.html">Pool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~RequestError.html">RequestError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~ServiceNotAvailableError.html">ServiceNotAvailableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~ResultError.html">ResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/schema.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assertNoErrors">assertNoErrors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parse">parse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSingle">parseSingle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-coerceBadly">coerceBadly</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backoff">backoff</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/constant.js~ConstantBackoff.html">ConstantBackoff</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/exponential.js~ExponentialBackoff.html">ExponentialBackoff</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#grammar">grammar</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/grammar/ds.js~Raw.html">Raw</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-castTimestamp">castTimestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dateToTime">dateToTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatDate">formatDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isoOrTimeToDate">isoOrTimeToDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toNanoDate">toNanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-escape">escape</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Precision">Precision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">unit/influx.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { expect } from &quot;chai&quot;;
import * as sinon from &quot;sinon&quot;;
import { FieldType, InfluxDB, toNanoDate } from &quot;../../src&quot;;
import { dbFixture } from &quot;./helpers&quot;;
describe(&quot;influxdb&quot;, () =&gt; {
    describe(&quot;constructor&quot;, () =&gt; {
        it(&quot;uses default options&quot;, () =&gt; {
            expect(new InfluxDB()._options).to.deep.equal({
                username: &quot;root&quot;,
                password: &quot;root&quot;,
                database: null,
                pool: undefined,
                schema: [],
                hosts: [
                    {
                        host: &quot;127.0.0.1&quot;,
                        port: 8086,
                        path: &quot;&quot;,
                        protocol: &quot;http&quot;,
                        options: undefined,
                    },
                ],
            });
        });
        it(&quot;parses dsns&quot;, () =&gt; {
            expect(new InfluxDB(&quot;https://connor:password@192.168.0.1:1337/foo&quot;)
                ._options).to.deep.equal({
                username: &quot;connor&quot;,
                password: &quot;password&quot;,
                database: &quot;foo&quot;,
                pool: undefined,
                schema: [],
                hosts: [
                    {
                        host: &quot;192.168.0.1&quot;,
                        port: 1337,
                        path: &quot;&quot;,
                        protocol: &quot;https&quot;,
                        options: undefined,
                    },
                ],
            });
        });
        it(&quot;parses single configs&quot;, () =&gt; {
            expect(new InfluxDB({ database: &quot;foo&quot;, host: &quot;192.168.0.1&quot; })._options).to.deep.equal({
                username: &quot;root&quot;,
                password: &quot;root&quot;,
                database: &quot;foo&quot;,
                pool: undefined,
                schema: [],
                hosts: [
                    {
                        host: &quot;192.168.0.1&quot;,
                        port: 8086,
                        path: &quot;&quot;,
                        protocol: &quot;http&quot;,
                        options: undefined,
                    },
                ],
            });
        });
        it(&quot;parses cluster configs&quot;, () =&gt; {
            expect(new InfluxDB({
                database: &quot;foo&quot;,
                hosts: [{ host: &quot;192.168.0.1&quot;, options: { ca: null } }],
            })._options).to.deep.equal({
                username: &quot;root&quot;,
                password: &quot;root&quot;,
                database: &quot;foo&quot;,
                schema: [],
                hosts: [
                    {
                        host: &quot;192.168.0.1&quot;,
                        port: 8086,
                        path: &quot;&quot;,
                        protocol: &quot;http&quot;,
                        options: { ca: null },
                    },
                ],
            });
        });
        it(&quot;parses parses schema&quot;, () =&gt; {
            let client = new InfluxDB({
                schema: [
                    {
                        database: &quot;my_db&quot;,
                        measurement: &quot;my_measurement&quot;,
                        fields: {},
                        tags: [&quot;my_tag&quot;],
                    },
                ],
                hosts: [{ host: &quot;192.168.0.1&quot;, options: undefined }],
            });
            expect(client._schema.my_db.my_measurement).to.not.be.undefined;
            client = new InfluxDB({
                schema: [
                    {
                        measurement: &quot;my_measurement&quot;,
                        fields: {},
                        tags: [&quot;my_tag&quot;],
                    },
                ],
                database: &quot;my_db&quot;,
                hosts: [{ host: &quot;192.168.0.1&quot; }],
            });
            expect(client._schema.my_db.my_measurement).to.not.be.undefined;
            expect(() =&gt; {
                new InfluxDB({
                    // eslint-disable-line no-new
                    schema: [
                        {
                            measurement: &quot;my_measurement&quot;,
                            fields: {},
                            tags: [&quot;my_tag&quot;],
                        },
                    ],
                    hosts: [{ host: &quot;192.168.0.1&quot; }],
                });
            }).to.throw(/no default database is provided/);
        });
    });
    describe(&quot;methods&quot;, () =&gt; {
        let influx;
        let pool;
        const expectations = [];
        beforeEach(() =&gt; {
            influx = new InfluxDB({
                hosts: [],
                schema: [
                    {
                        database: &quot;my_db&quot;,
                        measurement: &quot;my_schemed_measure&quot;,
                        tags: [&quot;my_tag&quot;],
                        fields: {
                            int: FieldType.INTEGER,
                            float: FieldType.FLOAT,
                            string: FieldType.STRING,
                            bool: FieldType.BOOLEAN,
                        },
                    },
                ],
            });
            pool = influx._pool;
            sinon.stub(pool, &quot;discard&quot;);
            sinon.stub(pool, &quot;json&quot;);
            sinon.stub(pool, &quot;text&quot;);
        });
        afterEach(() =&gt; {
            while (expectations.length) {
                expectations.pop()();
            }
        });
        const setDefaultDB = (db) =&gt; {
            influx._options.database = db;
        };
        const expectQuery = (method, options, httpMethod = &quot;POST&quot;, yields = { results: [{}] }) =&gt; {
            if (typeof options === &quot;string&quot;) {
                options = { q: options };
            }
            pool[method].returns(Promise.resolve(yields));
            expectations.push(() =&gt; {
                expect(pool[method]).to.have.been.calledWith({
                    method: httpMethod,
                    path: &quot;/query&quot;,
                    query: Object.assign({ u: &quot;root&quot;, p: &quot;root&quot; }, options),
                });
            });
        };
        const expectWrite = (body, options) =&gt; {
            if (typeof options === &quot;string&quot;) {
                options = { q: options };
            }
            pool.discard.returns(Promise.resolve());
            expectations.push(() =&gt; {
                expect(pool.discard).to.have.been.calledWith({
                    method: &quot;POST&quot;,
                    path: &quot;/write&quot;,
                    body,
                    query: Object.assign({ u: &quot;root&quot;, p: &quot;root&quot; }, options),
                });
            });
        };
        it(&quot;.createDatabase()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &apos;create database &quot;foo&quot;&apos;);
            influx.createDatabase(&quot;foo&quot;);
            expectQuery(&quot;json&quot;, &apos;create database &quot;f\\&quot;oo&quot;&apos;);
            influx.createDatabase(&apos;f&quot;oo&apos;);
        });
        it(&quot;.dropDatabase()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &apos;drop database &quot;foo&quot;&apos;);
            influx.dropDatabase(&quot;foo&quot;);
            expectQuery(&quot;json&quot;, &apos;drop database &quot;f\\&quot;oo&quot;&apos;);
            influx.dropDatabase(&apos;f&quot;oo&apos;);
        });
        it(&quot;.dropShard()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &quot;drop shard 1&quot;);
            influx.dropShard(1);
        });
        it(&quot;.getDatabaseNames()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &quot;show databases&quot;, &quot;GET&quot;, dbFixture(&quot;showDatabases&quot;));
            return influx.getDatabaseNames().then((names) =&gt; {
                expect(names).to.deep.equal([&quot;_internal&quot;, &quot;influx_test_gen&quot;]);
            });
        });
        it(&quot;.getMeasurements()&quot;, () =&gt; {
            setDefaultDB(&quot;mydb&quot;);
            expectQuery(&quot;json&quot;, {
                db: &quot;mydb&quot;,
                q: &quot;show measurements&quot;,
            }, &quot;GET&quot;, dbFixture(&quot;showMeasurements&quot;));
            return influx.getMeasurements().then((names) =&gt; {
                expect(names).to.deep.equal([&quot;series_0&quot;, &quot;series_1&quot;, &quot;series_2&quot;]);
            });
        });
        it(&quot;.getSeries() from all&quot;, () =&gt; {
            setDefaultDB(&quot;mydb&quot;);
            expectQuery(&quot;json&quot;, {
                db: &quot;mydb&quot;,
                q: &quot;show series&quot;,
            }, &quot;GET&quot;, dbFixture(&quot;showSeries&quot;));
            return influx.getSeries().then((names) =&gt; {
                expect(names).to.deep.equal([
                    &quot;series_0,my_tag=0&quot;,
                    &quot;series_0,my_tag=1&quot;,
                    &quot;series_0,my_tag=5&quot;,
                    &quot;series_0,my_tag=6&quot;,
                    &quot;series_0,my_tag=7&quot;,
                    &quot;series_0,my_tag=8&quot;,
                    &quot;series_0,my_tag=9&quot;,
                    &quot;series_1,my_tag=0&quot;,
                    &quot;series_1,my_tag=2&quot;,
                    &quot;series_1,my_tag=4&quot;,
                    &quot;series_1,my_tag=5&quot;,
                    &quot;series_1,my_tag=6&quot;,
                    &quot;series_1,my_tag=7&quot;,
                    &quot;series_1,my_tag=8&quot;,
                    &quot;series_1,my_tag=9&quot;,
                    &quot;series_2,my_tag=1&quot;,
                    &quot;series_2,my_tag=2&quot;,
                    &quot;series_2,my_tag=3&quot;,
                    &quot;series_2,my_tag=4&quot;,
                    &quot;series_2,my_tag=5&quot;,
                    &quot;series_2,my_tag=6&quot;,
                    &quot;series_2,my_tag=7&quot;,
                    &quot;series_2,my_tag=8&quot;,
                    &quot;series_2,my_tag=9&quot;,
                ]);
            });
        });
        it(&quot;.getSeries() from single&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, {
                db: &quot;mydb&quot;,
                q: &apos;show series from &quot;measure_1&quot;&apos;,
            }, &quot;GET&quot;, dbFixture(&quot;showSeriesFromOne&quot;));
            return influx
                .getSeries({
                database: &quot;mydb&quot;,
                measurement: &quot;measure_1&quot;,
            })
                .then((names) =&gt; {
                expect(names).to.deep.equal([
                    &quot;series_1,my_tag=0&quot;,
                    &quot;series_1,my_tag=2&quot;,
                    &quot;series_1,my_tag=4&quot;,
                    &quot;series_1,my_tag=5&quot;,
                    &quot;series_1,my_tag=6&quot;,
                    &quot;series_1,my_tag=7&quot;,
                    &quot;series_1,my_tag=8&quot;,
                    &quot;series_1,my_tag=9&quot;,
                ]);
            });
        });
        it(&quot;.dropMeasurement()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, {
                db: &quot;my_db&quot;,
                q: &apos;drop measurement &quot;series_1&quot;&apos;,
            });
            return influx.dropMeasurement(&quot;series_1&quot;, &quot;my_db&quot;);
        });
        describe(&quot;.dropSeries()&quot;, () =&gt; {
            beforeEach(() =&gt; setDefaultDB(&quot;my_db&quot;));
            it(&quot;drops with only from clause by string&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, { db: &quot;my_db&quot;, q: &apos;drop series from &quot;series_0&quot;&apos; });
                influx.dropSeries({ measurement: &apos;&quot;series_0&quot;&apos; });
            });
            it(&quot;drops with only from clause by builder&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, { db: &quot;my_db&quot;, q: &apos;drop series from &quot;series_0&quot;&apos; });
                influx.dropSeries({ measurement: (m) =&gt; m.name(&quot;series_0&quot;) });
            });
            it(&quot;drops with only where clause by string&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    db: &quot;my_db&quot;,
                    q: &apos;drop series where &quot;my_tag&quot; = 1&apos;,
                });
                influx.dropSeries({ where: &apos;&quot;my_tag&quot; = 1&apos; });
            });
            it(&quot;drops with only where clause by builder&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    db: &quot;my_db&quot;,
                    q: &apos;drop series where &quot;my_tag&quot; = 1&apos;,
                });
                influx.dropSeries({ where: (e) =&gt; e.tag(&quot;my_tag&quot;).equals.value(1) });
            });
            it(&quot;drops with both&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    db: &quot;my_db&quot;,
                    q: &apos;drop series from &quot;series_0&quot; where &quot;my_tag&quot; = 1&apos;,
                });
                influx.dropSeries({
                    measurement: (m) =&gt; m.name(&quot;series_0&quot;),
                    where: (e) =&gt; e.tag(&quot;my_tag&quot;).equals.value(1),
                });
            });
        });
        it(&quot;.getUsers()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &quot;show users&quot;, &quot;GET&quot;, dbFixture(&quot;showUsers&quot;));
            return influx.getUsers().then((names) =&gt; {
                expect(names.slice()).to.deep.equal([
                    { user: &quot;john&quot;, admin: true },
                    { user: &quot;steve&quot;, admin: false },
                ]);
            });
        });
        describe(&quot;.createUser()&quot;, () =&gt; {
            it(&quot;works with admin specified == true&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &quot;create user \&quot;con\\\&quot;nor\&quot; with password &apos;pa55\\&apos;word&apos; with all privileges&quot;);
                return influx.createUser(&apos;con&quot;nor&apos;, &quot;pa55&apos;word&quot;, true);
            });
            it(&quot;works with admin specified == false&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &quot;create user \&quot;con\\\&quot;nor\&quot; with password &apos;pa55\\&apos;word&apos;&quot;);
                return influx.createUser(&apos;con&quot;nor&apos;, &quot;pa55&apos;word&quot;, false);
            });
            it(&quot;works with admin unspecified&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &quot;create user \&quot;con\\\&quot;nor\&quot; with password &apos;pa55\\&apos;word&apos;&quot;);
                return influx.createUser(&apos;con&quot;nor&apos;, &quot;pa55&apos;word&quot;);
            });
        });
        describe(&quot;.grantPrivilege()&quot;, () =&gt; {
            it(&quot;queries correctly&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;grant READ on &quot;my_\\&quot;_db&quot; to &quot;con\\&quot;nor&quot;&apos;);
                return influx.grantPrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;, &apos;my_&quot;_db&apos;);
            });
            it(&quot;throws if DB unspecified&quot;, () =&gt; {
                expect(() =&gt; influx.grantPrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;)).to.throw(/default database/);
            });
            it(&quot;fills in default DB&quot;, () =&gt; {
                setDefaultDB(&apos;my_\\&quot;_db&apos;);
                expectQuery(&quot;json&quot;, &apos;grant READ on &quot;my_\\&quot;_db&quot; to &quot;con\\&quot;nor&quot;&apos;);
                return influx.grantPrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;, &apos;my_&quot;_db&apos;);
            });
        });
        describe(&quot;.revokePrivilege()&quot;, () =&gt; {
            it(&quot;queries correctly&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;revoke READ on &quot;my_\\&quot;_db&quot; from &quot;con\\&quot;nor&quot;&apos;);
                return influx.revokePrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;, &apos;my_&quot;_db&apos;);
            });
            it(&quot;throws if DB unspecified&quot;, () =&gt; {
                expect(() =&gt; influx.revokePrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;)).to.throw(/default database/);
            });
            it(&quot;fills in default DB&quot;, () =&gt; {
                setDefaultDB(&apos;my_\\&quot;_db&apos;);
                expectQuery(&quot;json&quot;, &apos;revoke READ on &quot;my_\\&quot;_db&quot; from &quot;con\\&quot;nor&quot;&apos;);
                return influx.revokePrivilege(&apos;con&quot;nor&apos;, &quot;READ&quot;, &apos;my_&quot;_db&apos;);
            });
        });
        it(&quot;.grantAdminPrivilege()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &apos;grant all to &quot;con\\&quot;nor&quot;&apos;);
            return influx.grantAdminPrivilege(&apos;con&quot;nor&apos;);
        });
        it(&quot;.revokeAdminPrivilege()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &apos;revoke all from &quot;con\\&quot;nor&quot;&apos;);
            return influx.revokeAdminPrivilege(&apos;con&quot;nor&apos;);
        });
        it(&quot;.dropUser()&quot;, () =&gt; {
            expectQuery(&quot;json&quot;, &apos;drop user &quot;con\\&quot;nor&quot;&apos;);
            return influx.dropUser(&apos;con&quot;nor&apos;);
        });
        describe(&quot;.createContinuousQuery()&quot;, () =&gt; {
            it(&quot;queries correctly no resample&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;create continuous query &quot;my_\\&quot;q&quot; on &quot;my_\\&quot;_db&quot;  begin foo end&apos;);
                return influx.createContinuousQuery(&apos;my_&quot;q&apos;, &quot;foo&quot;, &apos;my_&quot;_db&apos;);
            });
            it(&quot;queries correctly with resample&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;create continuous query &quot;my_\\&quot;q&quot; on &quot;my_\\&quot;_db&quot; resample for 4m begin foo end&apos;);
                return influx.createContinuousQuery(&apos;my_&quot;q&apos;, &quot;foo&quot;, &apos;my_&quot;_db&apos;, &quot;resample for 4m&quot;);
            });
            it(&quot;throws if DB unspecified&quot;, () =&gt; {
                expect(() =&gt; influx.createContinuousQuery(&apos;my_&quot;q&apos;, &quot;foo&quot;)).to.throw(/default database/);
            });
            it(&quot;fills in default DB&quot;, () =&gt; {
                setDefaultDB(&apos;my_&quot;_db&apos;);
                expectQuery(&quot;json&quot;, &apos;create continuous query &quot;my_\\&quot;q&quot; on &quot;my_\\&quot;_db&quot;  begin foo end&apos;);
                return influx.createContinuousQuery(&apos;my_&quot;q&apos;, &quot;foo&quot;);
            });
        });
        describe(&quot;.dropContinuousQuery()&quot;, () =&gt; {
            it(&quot;queries correctly&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;drop continuous query &quot;my_\\&quot;q&quot; on &quot;my_\\&quot;_db&quot;&apos;);
                return influx.dropContinuousQuery(&apos;my_&quot;q&apos;, &apos;my_&quot;_db&apos;);
            });
            it(&quot;throws if DB unspecified&quot;, () =&gt; {
                expect(() =&gt; influx.dropContinuousQuery(&apos;my_&quot;q&apos;)).to.throw(/default database/);
            });
            it(&quot;fills in default DB&quot;, () =&gt; {
                setDefaultDB(&apos;my_&quot;_db&apos;);
                expectQuery(&quot;json&quot;, &apos;drop continuous query &quot;my_\\&quot;q&quot; on &quot;my_\\&quot;_db&quot;&apos;);
                return influx.dropContinuousQuery(&apos;my_&quot;q&apos;);
            });
        });
        describe(&quot;.showContinousQueries()&quot;, () =&gt; {
            it(&quot;queries correctly&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, { q: &quot;show continuous queries&quot;, db: &quot;my_db&quot; }, &quot;GET&quot;);
                return influx.showContinousQueries(&quot;my_db&quot;);
            });
            it(&quot;throws if DB unspecified&quot;, () =&gt; {
                expect(() =&gt; influx.showContinousQueries()).to.throw(/default database/);
            });
            it(&quot;fills in default DB&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectQuery(&quot;json&quot;, { q: &quot;show continuous queries&quot;, db: &quot;my_db&quot; }, &quot;GET&quot;);
                return influx.showContinousQueries();
            });
        });
        describe(&quot;.writePoints()&quot;, () =&gt; {
            it(&quot;writes with all options specified without a schema&quot;, () =&gt; {
                expectWrite(&quot;mymeas,my_tag=1 myfield=90 1463683075&quot;, {
                    precision: &quot;s&quot;,
                    rp: &quot;1day&quot;,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;mymeas&quot;,
                        tags: { my_tag: &quot;1&quot; },
                        fields: { myfield: 90 },
                        timestamp: new Date(1463683075000),
                    },
                ], {
                    database: &quot;my_db&quot;,
                    precision: &quot;s&quot;,
                    retentionPolicy: &quot;1day&quot;,
                });
            });
            it(&quot;writes using default options without a schema&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;mymeas,my_tag=1 myfield=90 1463683075000000000&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;mymeas&quot;,
                        tags: { my_tag: &quot;1&quot; },
                        fields: { myfield: 90 },
                        timestamp: new Date(1463683075000),
                    },
                ]);
            });
            it(&quot;uses a schema to coerce&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;my_schemed_measure,my_tag=1 bool=T,float=43,int=42i&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;my_schemed_measure&quot;,
                        tags: { my_tag: &quot;1&quot; },
                        fields: {
                            int: 42,
                            float: 43,
                            bool: true,
                        },
                    },
                ]);
            });
            it(&quot;can accept a schema at runtime&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;my_runtime_schema_measure,my_tag=1 bool=T,float=43,int=42i&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                influx.addSchema({
                    database: &quot;my_db&quot;,
                    measurement: &quot;my_runtime_schema_measure&quot;,
                    fields: {
                        bool: FieldType.BOOLEAN,
                        float: FieldType.FLOAT,
                        int: FieldType.INTEGER,
                    },
                    tags: [&quot;my_tag&quot;],
                });
                return influx.writePoints([
                    {
                        measurement: &quot;my_runtime_schema_measure&quot;,
                        tags: { my_tag: &quot;1&quot; },
                        fields: {
                            int: 42,
                            float: 43,
                            bool: true,
                        },
                    },
                ]);
            });
            it(&quot;throws on schema violations&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expect(() =&gt; {
                    influx.writePoints([
                        {
                            measurement: &quot;my_schemed_measure&quot;,
                            tags: { not_a_tag: &quot;1&quot; },
                        },
                    ]);
                }).to.throw(/extraneous tags/i);
                expect(() =&gt; {
                    influx.writePoints([
                        {
                            measurement: &quot;my_schemed_measure&quot;,
                            fields: { not_a_field: &quot;1&quot; },
                        },
                    ]);
                }).to.throw(/extraneous fields/i);
                expect(() =&gt; {
                    influx.writePoints([
                        {
                            measurement: &quot;my_schemed_measure&quot;,
                            fields: { bool: &quot;lol, not a bool&quot; },
                        },
                    ]);
                }).to.throw(/expected bool/i);
            });
            it(&quot;handles lack of tags&quot;, () =&gt; {
                expectWrite(&quot;mymeas myfield=90&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;mymeas&quot;,
                        fields: { myfield: 90 },
                    },
                ], { database: &quot;my_db&quot; });
            });
            it(&quot;handles lack of fields&quot;, () =&gt; {
                expectWrite(&quot;mymeas,my_tag=90&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;mymeas&quot;,
                        tags: { my_tag: &quot;90&quot; },
                    },
                ], { database: &quot;my_db&quot; });
            });
            it(&quot;handles multiple tags&quot;, () =&gt; {
                expectWrite(&quot;mymeas,my_tag1=90,my_tag2=45&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writePoints([
                    {
                        measurement: &quot;mymeas&quot;,
                        tags: { my_tag1: &quot;90&quot;, my_tag2: &quot;45&quot; },
                    },
                ], { database: &quot;my_db&quot; });
            });
            it(&quot;writes with the .writeMeasurement method&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;mymeas,my_tag=1 myfield=90 1463683075000000000&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writeMeasurement(&quot;mymeas&quot;, [
                    {
                        tags: { my_tag: &quot;1&quot; },
                        fields: { myfield: 90 },
                        timestamp: new Date(1463683075000),
                    },
                ]);
            });
            it(&quot;accepts nanoseconds (as ms)&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;mymeas,my_tag=1 myfield=90 1463683075000000000&quot;, {
                    precision: &quot;n&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writeMeasurement(&quot;mymeas&quot;, [
                    {
                        tags: { my_tag: &quot;1&quot; },
                        fields: { myfield: 90 },
                        timestamp: toNanoDate(&quot;1463683075000000000&quot;),
                    },
                ]);
            });
            it(&quot;accepts timestamp overriding&quot;, () =&gt; {
                setDefaultDB(&quot;my_db&quot;);
                expectWrite(&quot;mymeas,my_tag=1 myfield=90 1463683075000&quot;, {
                    precision: &quot;ms&quot;,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                });
                return influx.writeMeasurement(&quot;mymeas&quot;, [
                    {
                        tags: { my_tag: &quot;1&quot; },
                        fields: { myfield: 90 },
                        timestamp: toNanoDate(&quot;1463683075000000000&quot;),
                    },
                ], { precision: &quot;ms&quot; });
            });
        });
        describe(&quot;.query&quot;, () =&gt; {
            beforeEach(() =&gt; setDefaultDB(&quot;my_db&quot;));
            it(&quot;runs raw queries&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0&quot;,
                    epoch: undefined,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                    params: {},
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.queryRaw(&quot;select * from series_0&quot;).then((res) =&gt; {
                    expect(res).to.deep.equal(dbFixture(&quot;selectFromOne&quot;));
                });
            });
            it(&quot;parses query output&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0&quot;,
                    epoch: undefined,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                    params: {},
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.query(&quot;select * from series_0&quot;).then((res) =&gt; {
                    expect(res.slice()).to.deep.equal([
                        {
                            time: new Date(&quot;2016-09-29T02:19:09.38Z&quot;),
                            my_tag: &quot;1&quot;,
                            my_value: 67,
                        },
                        {
                            time: new Date(&quot;2016-09-29T02:19:09.379Z&quot;),
                            my_tag: &quot;1&quot;,
                            my_value: 32,
                        },
                    ]);
                });
            });
            it(&quot;selects from multiple&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0;select * from series_1&quot;,
                    epoch: undefined,
                    rp: undefined,
                    db: &quot;my_db&quot;,
                    params: {},
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.query([
                    &quot;select * from series_0&quot;,
                    &quot;select * from series_1&quot;,
                ]);
            });
            it(&quot;passes in options&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0&quot;,
                    epoch: &quot;ms&quot;,
                    rp: &quot;asdf&quot;,
                    db: &quot;my_db&quot;,
                    params: {},
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.query([&quot;select * from series_0&quot;], {
                    precision: &quot;ms&quot;,
                    retentionPolicy: &quot;asdf&quot;,
                });
            });
            it(&quot;rewrites nanosecond precisions&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0&quot;,
                    epoch: undefined,
                    rp: &quot;asdf&quot;,
                    db: &quot;my_db&quot;,
                    params: {},
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.query([&quot;select * from series_0&quot;], {
                    precision: &quot;n&quot;,
                    retentionPolicy: &quot;asdf&quot;,
                });
            });
            it(&quot;uses placeholders&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, {
                    q: &quot;select * from series_0 WHERE time &gt; now() - $&lt;since&gt;&quot;,
                    epoch: undefined,
                    rp: &quot;asdf&quot;,
                    db: &quot;my_db&quot;,
                    params: { since: &quot;10s&quot; },
                }, &quot;GET&quot;, dbFixture(&quot;selectFromOne&quot;));
                return influx.query([&quot;select * from series_0 WHERE time &gt; now() - $&lt;since&gt;&quot;], {
                    precision: &quot;n&quot;,
                    retentionPolicy: &quot;asdf&quot;,
                    placeholders: {
                        since: &quot;10s&quot;,
                    },
                });
            });
        });
        describe(&quot;.createRetentionPolicy&quot;, () =&gt; {
            beforeEach(() =&gt; setDefaultDB(&quot;my_db&quot;));
            it(&quot;creates non-default policies&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;create retention policy &quot;7d\\&quot;&quot; on &quot;test&quot; duration 7d replication 1&apos;);
                return influx.createRetentionPolicy(&apos;7d&quot;&apos;, {
                    database: &quot;test&quot;,
                    duration: &quot;7d&quot;,
                    replication: 1,
                });
            });
            it(&quot;creates default policies&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;create retention policy &quot;7d\\&quot;&quot; on &quot;my_db&quot; duration 7d replication 1 default&apos;);
                return influx.createRetentionPolicy(&apos;7d&quot;&apos;, {
                    duration: &quot;7d&quot;,
                    replication: 1,
                    isDefault: true,
                });
            });
        });
        describe(&quot;.alterRetentionPolicy&quot;, () =&gt; {
            beforeEach(() =&gt; setDefaultDB(&quot;my_db&quot;));
            it(&quot;creates non-default policies&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;alter retention policy &quot;7d\\&quot;&quot; on &quot;test&quot; duration 7d replication 1&apos;);
                return influx.alterRetentionPolicy(&apos;7d&quot;&apos;, {
                    database: &quot;test&quot;,
                    duration: &quot;7d&quot;,
                    replication: 1,
                });
            });
            it(&quot;creates default policies&quot;, () =&gt; {
                expectQuery(&quot;json&quot;, &apos;alter retention policy &quot;7d\\&quot;&quot; on &quot;my_db&quot; duration 7d replication 1 default&apos;);
                return influx.alterRetentionPolicy(&apos;7d&quot;&apos;, {
                    duration: &quot;7d&quot;,
                    replication: 1,
                    isDefault: true,
                });
            });
        });
        it(&quot;drops retention policies&quot;, () =&gt; {
            setDefaultDB(&quot;my_db&quot;);
            expectQuery(&quot;json&quot;, &apos;drop retention policy &quot;7d\\&quot;&quot; on &quot;my_db&quot;&apos;);
            return influx.dropRetentionPolicy(&apos;7d&quot;&apos;);
        });
        it(&quot;shows retention policies&quot;, () =&gt; {
            const data = dbFixture(&quot;showRetentionPolicies&quot;);
            expectQuery(&quot;json&quot;, &apos;show retention policies on &quot;my\\&quot;db&quot;&apos;, &quot;GET&quot;, data);
            influx.showRetentionPolicies(&apos;my&quot;db&apos;);
            setDefaultDB(&quot;my_db&quot;);
            expectQuery(&quot;json&quot;, &apos;show retention policies on &quot;my_db&quot;&apos;, &quot;GET&quot;, data);
            return influx.showRetentionPolicies().then((res) =&gt; {
                expect(res.slice()).to.deep.equal([
                    {
                        name: &quot;autogen&quot;,
                        duration: &quot;0s&quot;,
                        shardGroupDuration: &quot;168h0m0s&quot;,
                        replicaN: 1,
                        default: true,
                    },
                    {
                        name: &quot;7d&quot;,
                        duration: &quot;168h0m0s&quot;,
                        shardGroupDuration: &quot;24h0m0s&quot;,
                        replicaN: 1,
                        default: false,
                    },
                ]);
            });
        });
        it(&quot;shows shards&quot;, () =&gt; {
            setDefaultDB(&quot;_internal&quot;);
            expectQuery(&quot;json&quot;, &quot;show shards &quot;, &quot;GET&quot;, dbFixture(&quot;showShards&quot;));
            return influx.showShards().then((res) =&gt; {
                expect(res.slice()).to.deep.equal([
                    {
                        id: 1,
                        database: &quot;_internal&quot;,
                        retention_policy: &quot;monitor&quot;,
                        shard_group: 1,
                        start_time: &quot;2019-06-13T00:00:00Z&quot;,
                        end_time: &quot;2019-06-14T00:00:00Z&quot;,
                        expiry_time: &quot;2019-06-21T00:00:00Z&quot;,
                        owners: &quot;&quot;,
                    },
                ]);
            });
        });
    });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
